<?xml version="1.0" encoding="UTF-8" ?>
<!-- File contains Custom Transformation scripts -->
<custom_transformation_scripts>
	<scr id="8BE52A19-2B2C-6589-6CF0-BD87BF8E27B2" name="Test logical" object="logical" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[finrep = model.design.getBusinessInfoDesign().getDocumentSet().getByName("Finrep");

var app_view = model.getAppView();

ent = model.getEntitySet().getByName("Department");
attrs = ent.getElements();
for (var i=0; i<attrs.length; i++) {
	attr = attrs[i];
	docs = attr.getDocuments();
	if (docs.length != 0 && docs.contains(finrep)) {
		app_view.logMessage(attr.name);
	    	
	}
}]]>
		</script>
	</scr>
	<scr id="81FCF6E0-21AB-AF09-909D-D5F3CB506DC2" name="Add foreign key domain constraints" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Add foreign key domain constraints
 *  PURPOSE: Some columns that are defined on a subtype have a reference to another column via foreign key. 
 *             In this case, after wrapping up, a Not applicable member is added to the referenced column (see Amend columns domain and remove duplicated columns). 
 *             The referenced column might also be referenced by another column, which is defined on a supertype entity, so a Not applicable member should not be present 
 *             in the domain.
 *             In this case, we need to create a constraint on the column of the supertype to restrict the domain values to excelude the member Not applicable.
 *  OBJECT: Applied on relational model
 *  REQUIREMENTS: - Run after Amend columns domain and remove duplicated columns 
 *  DYNAMIC: 
 *  SHORT DESCRIPTION: Checks every table for foreign key columns that are coming from attributes of supertype entities. 
 *                     For these columns, checks if the referenced column's domain contains the member Not applicable. 
 *                     If it does, creates the constraint on the foreign key column.
 *  
*/

// ---- INPUT PARAMETERS ----
script_name = "Add foreign key domain constraints";

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

rel_model = model;
tables = model.getTableSet().toArray();
log_tables_affected = 0;
log_total_num_cols_affected = 0;
log_num_cols = 0;
for (var t=0; t<tables.length; t++){
    log_table_affected = false;
    table = tables[t];
    table_name = table.getName();
    columns = table.getElements();
    indexes = table.getKeys();
    log_num_cols += columns.length;
    cols_removed = new java.util.ArrayList();
    for (var i=0; i<columns.length; i++) {
        col = columns[i];
        log_col_amended = false;
        attr = col.getEngAttribute();
        // Check if column is a part of FK and if it comes from the attribute from the top of hierarchy
        if (col.isFKColumn()==true && attr) {
            orig_entity = attr.getEntity();
            parent = orig_entity.getHierarchicalParent();
            if (parent==null) {
                // Check if referenced column is:
                //    - enumerated, contains Not applicable member
                // In this case we need to add a constraint
                ref_column = col.getReferencedColumn();
                column_domain = ref_column.getDomain();
                column_domain_name = column_domain.getName();
                column_list_of_values = column_domain.getValueList();
                if (column_list_of_values) {
                    // Check if 0 present in values
                    col_values = column_list_of_values.getValues();
                    if (col_values.contains("0")) {
                        log_table_affected = true;
                        log_total_num_cols_affected += 1;
                        app_view.logMessage("- Table " + table_name + " amended");
                        // Set constraint
                        col.setUseDomainConstraints(false);
                        constraint_name = column_domain.getName() + " without Not applicable constraint"
                        app_view.logMessage("--- Created constraint called "+ constraint_name + " on the column " + col.getName());
                        col.setConstraintName(constraint_name);
                        constraint_enumeration = col.createConstraintEnumeration();
                    // Use value list from original attribute
                    attr_domain = attr.getDomain();
                    attr_list_of_values = attr_domain.getValueList();
                    col.setOwnValueList(attr_list_of_values);
                    table.setDirty(true);
                    }
                }
            }
        }
    }
    if (log_table_affected) {
           log_tables_affected += 1
    }
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_total_num_cols_affected + "/" + log_num_cols + " constraints added");
app_view.logMessage("- " + log_tables_affected + "/" + tables.length + " tables affected");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="1726EC74-A64B-0C0F-83DB-2A4BEF0D3DCA" name="Columns order" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[// NOTE: This script was created by SQL Data Modeler developers

// sorts table columns as asked here https://forums.oracle.com/forums/thread.jspa?threadID=2508315&tstart=0
// "...first the pks columns, after them fk columns and after the not null columns"

/** 
 *  SCRIPT NAME: Columns order
 *  PURPOSE: Order columns by type: first primary keys, then foreign keys, madatory column and last optional
 *  OBJECT: applied on relational data model
 *  REQUIREMENTS: 
 *  DYNAMIC: 
 *  SHORT DESCRIPTION: 
*/

// ---- INPUT PARAMETERS ----
script_name = "Columns order";

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");


function addPKcolumns(list,table){
	pk = table.getPK();
	if(pk!=null){
		pcols = pk.getColumns();
		for(var i = 0;i<pcols.length;i++){
			col = pcols[i];
			//in fact don't need this check, because PK columns are processed first
			if(!list.contains(col)){
				list.add(col);
			}
		}
	}
}

function addFKcolumns(list,fkeys){
	for(var k=0;k<fkeys.length;k++){
		fcols = fkeys[k].getColumns();
		for(var i = 0;i<fcols.length;i++){
		  col = fcols[i];
		  if(!list.contains(col)){
			list.add(col);
		  }
		}
	}
}
//adds mandatory or optional columns to list depending on mand parameter
function addMandatoryOptColumns(list,cols, mand){
	for(var i = 0;i<cols.length;i++){
		col = cols[i];
		if(col.isMandatory() == mand && !list.contains(col)){
			list.add(col);
		}
	}
}

tables = model.getTableSet().toArray();
list = new java.util.ArrayList();
log_tables_amended = new java.util.ArrayList();
for (var t=0; t<tables.length; t++){
	list.clear();
	table = tables[t];
	cols = table.getElements();
	// add PK columns to list
	addPKcolumns(list,table);
	// add FK columns to list
	addFKcolumns(list,table.getFKAssociations());
	// add mandatory columns
	addMandatoryOptColumns(list,cols,true);
	// add optional columns
	addMandatoryOptColumns(list,cols,false);
	// use list to reorder columns
	ord_cols = list.toArray();
	for (var n=0; n<ord_cols.length; n++){
		table.moveToIndex(ord_cols[n], n);
	}
	//prevent reordering from enginnering, can be changed with UI
	table.setAllowColumnReorder(false);
	log_tables_amended.add(table.getName());
	table.setDirty(true);
}

app_view.logMessage("- Tables amended: " + log_tables_amended);
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_tables_amended.length + "/" + tables.length + " tables amended");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="00F69B42-A768-0523-C5CA-B6955B698866" name="Set enumerated Column to mandatory" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Set enumerated columns to mandatory
 *  PURPOSE: when wrapping up, all columns from subtypes become optional  
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run last
 *  DYNAMIC: 
 *  SHORT DESCRIPTION: 
*/

// ---- INPUT PARAMETERS ----
script_name = "Set enumerated columns to mandatory";

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

tables = model.getTableSet().toArray();
log_num_cols_affected = 0;
log_tables_affected = 0;
for (var t=0; t<tables.length; t++){
    table = tables[t];
    table_name = table.getName();
    columns = table.getElements();
    log_is_amended = false;
    log_columns_affected = new java.util.ArrayList();
    for (var i=0; i<columns.length; i++) {
        column = columns[i];
        attr =  column.getEngAttribute();
        if (attr!=null) {
            domain_enumerated = attr.getDomain().getValueList();
            if (column.isMandatory()==false && domain_enumerated!=null) {
                log_is_amended = true;
                column.setMandatory(true);
                log_columns_affected.add(column);
                log_num_cols_affected += 1;   
            }
        }
    }
    if (log_is_amended) {
        app_view.logMessage("- Table " + table_name + " amended");
        app_view.logMessage("--- " + log_columns_affected.length + "/" + columns.length + " columns set to mandatory");
        app_view.logMessage("--- Columns set to mandatory: " + log_columns_affected);
        table.setDirty(true);
        log_tables_affected += 1;
    } 
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_num_cols_affected + " columns amended (set to mandatory)");
app_view.logMessage("- " + log_tables_affected + "/" + tables.length + " tables affected");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="930015FE-7A97-CE66-ED49-C3B5973D6329" name="Optional one-to-one relationships" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Optional one-to-one relationships
 *  PURPOSE: during FE, all optional relationships become mandatory foreign keys  
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run before merging one-to-one relationships
 *  DYNAMIC: merge_derived_entities = false, if we want ot keep derived data in a separate entity
 *           In this case, we leave the columns mandatory
 *  SHORT DESCRIPTION: sets Columns of Tables, where Entities had optional one-to-one relationship and only one relationship, to optional
 *                     same for madatory one-to-one relationships on subtypes
*/

// ---- INPUT PARAMETERS ----
var merge_derived_entities = true;
script_name = "Optional one-to-one relationships";

// ----SCRIPT----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

tables = model.getTableSet().toArray();
log_total_tables = tables.length;
log_tables_affected = 0;
log_num_cols = 0;
log_total_num_cols_affected = 0;
for (var t=0; t<tables.length; t++){
    table = tables[t];
    tname = table.getName();
    is_derived = tname.contains("DRVD") || tname.contains("derived") || tname.contains("Derived");
    if (merge_derived_entities==true || (merge_derived_entities==false && is_derived==false)) {
        entity = table.getEngEntity();
        num_of_relations = table.getFKAssociations().length;
        relations = entity.getRelations();
        if (relations.length==1) {
            is_optional_relation = relations[0].isOptionalSource();
            is_identifying = relations[0].isIdentifying();
            is_one_to_one = relations[0].isOneToOne();
            source_entity = relations[0].getSourceEntity();
            source_is_hier_type = source_entity.isHierarchicalEntityType();
            is_subtype = false;
            if (source_is_hier_type) {
                is_subtype = !source_entity.isHierarchicalRoot();
            }
            if (num_of_relations==1 && is_one_to_one && ((is_optional_relation && is_identifying) || (is_subtype))) {
                app_view.logMessage("- Table " + tname + " amended");
                columns = table.getElements();
                log_num_cols += columns.length;
                log_columns_affected = new java.util.ArrayList();
                for (var i = 0; i < columns.length; i++) {
                    column = columns[i];
                    column_name = column.getName();
                    if (column.isFKColumn()==false && column.isPKElement()==false) {
                        column.setMandatory(false);
                        log_columns_affected.add(column_name);
                        log_total_num_cols_affected += 1;
                    }
                    table.setDirty(true);
                }
                app_view.logMessage("--- " + log_columns_affected.length + "/" + columns.length + " columns set to optional");
                app_view.logMessage("--- Columns set to optional: " + log_columns_affected);
                log_tables_affected += 1;  
            }
        }   
    }  
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_total_num_cols_affected + "/" + log_num_cols + " columns amended (set to optional)");
app_view.logMessage("- " + log_tables_affected + "/" + log_total_tables + " tables affected");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="5B9E23C1-3697-AC2E-74AF-A021A235D5D9" name="Entity role and Abstract instrument role" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME: Entity role and Abstract instrument role
 *  PURPOSE: Entity role is a generalisation without primary key, which is related to other generalisations, so it needs to be handled first.   
 *           Abstract instrument role has similar properties as Entity role, it is a generalisation where attributes from 
 *           primary key have the same primary concept (Instrument role type, OTC derivative role type) and have to be merged into one column.
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run before Generalisation
 *  DYNAMIC: input of generalisation tables which need to be handled first
 *           is_preferred_abbreviation=true, if relational model is generated with preferred abbreviations
 *  SHORT DESCRIPTION: During fe, the Table gets a surrogate primary key, which needs to be changed to primary key defined on subtypes. 
 *                     Primary keys on subtypes are: 
 *                     - foreign key columns, which come from the same source column: these are merged.    
 *                     - column, which have the same primary concept: need to be merged into one column (primary concept column) and domain
 *                       need to be amended to a union of members of these columns 
 *                         -- If a table has more than two levels of subtyping (abstract and one other), we exclude this primary column from domain being amended.
 *                         -- This is handled by reduce discriminators script
 *                     After changing its primary key, foreign keys related to this Table need to change index to the new primary key.    
 *                     These foreign keys (primary key columns) need to be set to mandatory.
 *                     
*/

// ---- INPUT PARAMETERS ----
var is_preferred_abbreviation = false;
script_name = "Entity role and Abstract instrument role";
// We exclude amneding the domain of Instrumemnt role type column, since we would need to consider disjoint subtyping
// This is included in Reduce discriminators script
// If the primary concept is also a part of reducing the discriminators, we should not amend its domain here
excluded_to_amend_domains = new java.util.ArrayList([
                                           "INSTRMNT_RL_TYP",
                                           "Instrument_role_type"
                                           ]);

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

var table_name_party = "ENTTY_RL";
var table_name_instrument = "ABSTRCT_INSTRMNT_RL";
// The columns in replacibles have the same primary concept
var replacibles_party = new java.util.ArrayList([
                                       "PRTY_RL_TYP",
                                       "Party_role_type",  
                                       "ORGNSTN_RL_TYP",
                                       "Organisation_role_type", 
                                       "LGL_PRSN_RL_TYP",
                                       "Legal_person_role_type",
                                       "Central_bank_and_private_sector_company_role_type",
                                       "OTHR_ORGNSTN_RL_TYP",
                                       "Entity_group_role_type",
                                       "ENTTY_GRP_RL_TYP",
                                       "Entity_transaction_role_type",
                                       "ENTTY_TRNSCTN_RL_TYP"
                                       ]);

var replacibles_instrument = new java.util.ArrayList([
                                "OTC_DRVTV_RL_TYP",
                                "Over_the_counter_(OTC)_derivative_role_type",
                                "INSTRMNT_RL_TYP",
                                "Instrument_role_type"
                                ]);
var primary_concept_party = "PRTY_RL_TYP";
var primary_concept_instrument = "INSTRMNT_RL_TYP";

if (is_preferred_abbreviation==false) {
    table_name_instrument = "Abstract_instrument_role";
    table_name_party = "Entity_role";
    primary_concept_party = "Party_role_type";
    primary_concept_instrument = "Instrument_role_type";
}

updateGeneralisation(table_name_party, primary_concept_party, replacibles_party);
updateGeneralisation(table_name_instrument, primary_concept_instrument, replacibles_instrument);

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

// ---- FUNCTIONS ----
function getFEName(attribute, is_preferred_abbreviation) {
    /*
    Input: Attribute, Bool
    Output: String
    Description: Returns preffered abbreviation of attribute in case of using preferred abbreviation for fe, 
                 othervise returns attribute names with underscores instead of spaces.
    */
    if (is_preferred_abbreviation==true) {
        fe_name = attribute.getPreferredAbbreviation();
    } else {
        attr_name = attribute.getName();
        fe_name = attr_name.replaceAll(" ", "_"); 
    }
    return fe_name
}


function removeNumbersfromColumns(column) {
    /*
    Input: Column
    Output: Bool
    Description: Removes numbers from column names and returns a boolean whether or not the name was changed.
    */
    table =  column.getTable();
    col_name = column.getName();
    attr = column.getEngAttribute();
    skip = false;
    if (attr) {
        fe_name = attr.getPreferredAbbreviation();
        skip = fe_name.matches(".*\\d.*");
    }
    if (skip==false) {
        new_name = col_name.replaceAll("[0-9]", "");
        column.setName(new_name);
        table.setDirty(true);
    }
    if (col_name != column.getName()) {
        change = true;
    } else {
        change = false;
    }
    return change;
}


function getMatchingDomain(granular_discriminator, leaves_member_list) {
    /*
    Input: Column, HashSet
    Output: Bool
    Description: Goes through all domains and checks if there exists one with matching values (sdd members) from leaves_member_list.
                 If found, assined to granular_discriminator.
                 Returns bool, mathcing domain found or not.
    */ 
    domains = model.design.getDomainSet().toArray();
    matching_domain_found = false;
    table = granular_discriminator.getTable();
    for (var j=0; j<domains.length; j++) {
        domain = domains[j];
        domain_name = domain.getName();
        list_of_values = domain.getValueList();
        // Check only enumerated domains
        if (list_of_values!=null) {
            domain_member_names = new java.util.HashSet();
            member_map = list_of_values.getValuesDescriptionMap();
            m = member_map.keySet().toArray();
            for (var k=0; k<m.length; k++) {
                member_code = m[k];
                description = member_map.get(member_code);
                member = member_code + " | " + description;
                domain_member_names.add(member);
            }
            // Check if this domain has the same members as leaves of the hierarchy
            if (domain_member_names.equals(leaves_member_list)) {
                app_view.logMessage("----- Matching domain found: " + domain_name);
                matching_domain_found = true;
                granular_discriminator.setDomain(domain);
                break;
            }
        }
    }
    table.setDirty(true);
    return matching_domain_found
}


function getColumnMemberList(column) {
    /*
    Input: Column
    Output: HashSet
    Description: Returns a set of values (sdd members) of domain of a column
    */
    domain = column.getDomain();
    value_list = domain.getValueList();
    column_member_names = new java.util.HashSet();
    if (value_list) {
        column_member_map = value_list.getValuesDescriptionMap();    
        m = column_member_map.keySet().toArray();
        for (var k=0; k<m.length; k++) {
            member_code = m[k];
            description = column_member_map.get(member_code);
            member_name = description.split(":")[0];
            member_code_desc = member_code + " | " + description;
            // Each member is identified by its code and description
            column_member_names.add(member_code_desc);
        }
    }
    return column_member_names
}


function getUnassignedDomainMemberIndex() {
    /*
    Input: None
    Output: ArrayList
    Description:  Returns a list [domain index, member index] of last unassigned member or domain
    */
    domains = model.design.getDomainSet().toArray();
    domain_index = 0;
    member_index = 0;
    starting_indexes = new java.util.ArrayList();
    for (i=0; i<domains.length; i++) {
        temp_domain = domains[i];
        domain_name = temp_domain.getName();
        if (domain_name.contains("Unassigned")) {
            candidate_index = parseInt(domain_name.split("_")[2]); // List [Unassigned, domain, index]
            if (candidate_index>domain_index) {
                domain_index = candidate_index;
            }
        }
        domain_value_list = temp_domain.getValueList();
        if (domain_value_list) {
            domain_values = domain_value_list.getValues().toArray();
            for (var j=0; j<domain_values.length; j++) {
                value = domain_values[j];
                if (value.contains("Unassigned")) {
                    code_index = parseInt(value.split("_")[1]);
                    if (code_index>member_index) {
                        member_index = code_index;
                    }
                }
            }
        }
    }
    starting_indexes.add(domain_index);
    starting_indexes.add(member_index);
    return starting_indexes;
}


function createDomain(member_list) {
     /*
    Input: HashSet
    Output: Domain
    Description: Creates a Domain named "Unassigned_domain_<number>" in defaultdomains with constraint enumeration from member_list. 
                 If enumerations (sdd members) are newly created they have a value "Unassigned_<number>". 
    */
    new_domain = null;
    starting_indexes = getUnassignedDomainMemberIndex();
    domain_index = starting_indexes[0] + 1;
    domain_member_index = starting_indexes[1] + 1;
    member_list_array = member_list.toArray();
    if (member_list_array.length>0) {
         new_domain = model.design.createDomain();
         domain_name = "Unassigned_domain_" + domain_index;
        new_domain.setName(domain_name);
        app_view.logMessage("--- Created domain " + new_domain.getName());
        constraint_enumeration = new_domain.createConstraintEnumeration();
        for (i=0; i<member_list_array.length; i++) {
            member = member_list_array[i];
            member_code_des = member.split(" | "); // member = "code | name: description"
            if (member_code_des.length>1) {
                member_code = member_code_des[0];
                member_name = member_code_des[1];
            } else {
                member_code = "Unassigned_" + domain_member_index;
                member_name = member;
            }
            constraint_enumeration.add(member_code, member_name);
            domain_member_index += 1;
        }
        new_domain.setValueList(constraint_enumeration);
        // Set Logical data type to String
        lt_string = model.design.getLogicalDatatypeSet().getByName("String");
        new_domain.setLogicalDatatype(lt_string);
        new_domain.setDirty(true);
    }
    return new_domain;
}


function getHierarchicalTree(entity) {
	leaves = entity.getHierarchicalLeaves();
	hierarchy_tree = new java.util.HashSet();
	hierarchy_tree.add(entity);
	//app_view.logMessage("Entity: " + entity);
	if (entity.isHierarchicalEntityType()) {
		for (var i=0; i<leaves.length; i++) {
			leaf = leaves[i];
			hierarchy_tree.add(leaf);
			parent = leaf.getHierarchicalParent();
			//app_view.logMessage("Parent: " + parent);
			is_downwrapped = parent.getAttributeInherType()=='All atributes';
			// Igore the ones that are downwrapped
			if (!is_downwrapped) {
				while (parent.getName() != entity.getName()) {
					hierarchy_tree.add(parent);
					parent = parent.getHierarchicalParent();
				}
			}
		}
	}
	return hierarchy_tree;
}


function getOverlappingAttributesOfHierarchy(entity) {
    hierarchy_tree = getHierarchicalTree(entity).toArray();
    attributes_to_replace = new java.util.ArrayList();
    attr_fold_map = new java.util.HashMap();
    for (var i=0; i<hierarchy_tree.length; i++) {
    	    ent1 = hierarchy_tree[i];
    	    attrs = ent1.getAttributeSet();
    	    folded_attrs = ent1.getFoldedAttributesMap();
	    keys = folded_attrs.keySet().toArray();
	    for (var j=0; j<keys.length; j++) {
		    attr1_id = keys[j];
		    attr2_id = folded_attrs.get(attr1_id);
		    attr1 = attrs.getObjectByID(attr1_id);
		    orig_attr1 = attr1.getOriginatingAttribute();
		    attr2 = attrs.getObjectByID(attr2_id);
		    orig_attr2 = attr2.getOriginatingAttribute();
		    attributes_to_replace.add(orig_attr1.getName());
		    attr_fold_map.put(attr1, attr2);
	    }
    }
    return [attributes_to_replace, attr_fold_map]
}


function createMappingForAttrAndOverlapping(relational_model, attr_fold_map, attribute, column) {
	f_attr_name = attribute.getName();
	folded = attr_fold_map.get(attribute);
	relational_model.getRMExtendedMap().createMapping(attribute, column);
	//if (column.getTable().getName()=="Entity_role") {
	//	app_view.logMessage("------- Created mapping from attribute " + attribute.getName() + " to column " + column.getName());
	//}
	
	if (folded != null) {
	    relational_model.getRMExtendedMap().createMapping(folded, column);
	    //if (column.getTable().getName()=="Entity_role") {
	    //	app_view.logMessage("------- Created mapping from attribute " + folded.getName() + " to column " + column.getName());
	    //}
	}
	relational_model.setDirty(true);
}


function updateGeneralisation(table_name, primary_concept, replacibles) {
    /*
    Input: String, String, ArrayList
    Output: None
    Description: Updates generalisation tables and their related tables
    */
    rel_model = model;
    tables = model.getTableSet().toArray();
    table = model.getTableSet().getByName(table_name);
    primary_concept_column = table.getElementByName(primary_concept);
    columns_to_remove = new java.util.ArrayList();
    entity = table.getEngEntity();
    // Overlapping attributes of the hierarchy
    folded_attrs_list = getOverlappingAttributesOfHierarchy(entity);
    attributes_to_replace = folded_attrs_list[0];
    attr_fold_map = folded_attrs_list[1];
    pks = new java.util.HashMap();
    fpks = new java.util.ArrayList();
    columns = table.getElements();
    // Prepare set of members seperately for primary concept 
    primary_concept_domain = new java.util.HashSet();
    log_cols_replaced_by_primary_concept = new java.util.ArrayList();
    app_view.logMessage("- Table " + table_name + " amended");
    // Fix Table 
    for (var i=0; i<columns.length; i++) {
        column = columns[i];
        // Remove surrogate pk
        if (column.isSurrogateColumn()==true) {
            columns_to_remove.add(column);
            col_name = column.getName();
            app_view.logMessage("--- Surrogate key " + col_name + " removed");
        } else {
            attribute = column.getEngAttribute();
            // Check if attribute was a primary key (and not foreign key):
            // in this case, check if it is one of the replacibles and replace it with its primary concept
            attr_name = getFEName(attribute, is_preferred_abbreviation); 
            if (attribute.isPKElement()==true && attribute.isFKAttribute()==false) {
                if (replacibles.contains(attr_name)) {
                    log_cols_replaced_by_primary_concept.add(attr_name);
                    attr_name = primary_concept;
                    if (pks.containsKey(primary_concept)==true) {
                        columns_to_remove.add(column);
                        createMappingForAttrAndOverlapping(rel_model, attr_fold_map, attribute, primary_concept_column);
                    } else {
                        column.setName(attr_name);
                    }
                    col_domain = getColumnMemberList(column);
                    primary_concept_domain.addAll(col_domain);
                }
                if (pks.containsKey(attr_name)==false) {
                    pks.put(attr_name, column);    
                } else {
                	mapped_to_col = pks.get(attr_name);
                    columns_to_remove.add(column);
                    createMappingForAttrAndOverlapping(rel_model, attr_fold_map, attribute, mapped_to_col);
                }
            }
            if (attribute.isFKAttribute()==true && attribute.isPKElement()==true) {
                // If foreign keys come from the same entity, (same name of attribute), rename the column and keep only one
                attr_name = getFEName(attribute.getOriginatingAttribute(), is_preferred_abbreviation);
                if (replacibles.contains(attr_name)) {
                    log_cols_replaced_by_primary_concept.add(attr_name);
                    attr_name = primary_concept;
                    if (pks.containsKey(primary_concept)==true) {
                        columns_to_remove.add(column);
                    } else {
                        column.setName(attr_name);    
                    }
                    col_domain = getColumnMemberList(column);
                    primary_concept_domain.addAll(col_domain);
                } else {
                    column.setName(attr_name);    
                }
                if (pks.containsKey(attr_name)==false) {
                    pks.put(attr_name, column); 
                } else {
                	mapped_to_col = pks.get(attr_name);
                    columns_to_remove.add(column);
                    createMappingForAttrAndOverlapping(rel_model, attr_fold_map, attribute, mapped_to_col);
                }
            }
        }
        table.setDirty(true);
    }
    
    // Set new primary key to ENTTY_RL
    var new_index = table.createIndex();
    keys = pks.keySet().toArray();
    log_pk_col_names = new java.util.ArrayList();
    for (var i = 0; i < pks.size(); i++) {
        col = pks.get(keys[i]);
        new_index.add(col);
        log_pk_col_names.add(col.getName());
    }
    new_index.setPK(true);
    app_view.logMessage("--- Primary key constraint amended");
    app_view.logMessage("----- New primary key: " + log_pk_col_names);
    table.setDirty(true);
    
    // Change foreign key associations with ENTTY_RL
    log_related_tables_amended = 0;
    log_related_tables = 0;
    for (var s=0; s<tables.length; s++) {
        related_table = tables[s];
        related_entity = related_table.getEngEntity();
        // Overlapping attributes of the hierarchy
        folded_attrs_list = getOverlappingAttributesOfHierarchy(related_entity);
        attributes_to_replace = folded_attrs_list[0];
        attr_fold_map = folded_attrs_list[1];
        fks = related_table.getFKIndexAssociationsWith(table);
        related_table_name = related_table.getName();
        related_table_columns = related_table.getElements();
        if (related_table_name != table.getName()) {
            log_related_tables += fks.length;
            for (var j=0; j<fks.length; j++) {
                fk = fks[j];
                table_pk_cols_base = fk.getColumns();
                ref_table = fk.getRemoteTable(); // entity role or abstract instrument role
                ref_index = fk.getRemoteIndex();
                ref_table_pk = ref_table.getPK();
                ref_table_cols = ref_table_pk.getColumns();
                app_view.logMessage("--- Related table " + related_table_name + " amended");
                log_related_tables_amended += 1;
                if (ref_index.isPK()==false) {
                    // If it's not a generalisation, add columns from primary key
                    is_generalisation = related_entity.isCreateSurrogateKey();
                    log_new_fk_cols = new java.util.ArrayList();
                    log_connected_cols = new java.util.ArrayList();
                    if (is_generalisation==false) {
                        table_pk_cols_base = fk.getColumns(); // existing columns in related table
                        // Prepare names of pk columns, so that we connect correct columns
                        ref_table_cols_names = new java.util.ArrayList();
                        table_pk_cols_names = new java.util.ArrayList();
                        table_pk_cols_names_sorted = new java.util.ArrayList();
                        fake_index = related_table.createIndex();
                        for (var k=0; k<ref_table_cols.length; k++) {
                            ref_c = ref_table_cols[k];
                            app_view.logMessage(ref_c.getName());
                            log_new_fk_cols.add(ref_c.getName());
                            c = table_pk_cols_base[k];
                            ref_table_cols_names.add(ref_c.getName());
                            table_pk_cols_names.add(c.getName());
                        }
                        for (var k=0; k<ref_table_cols_names.length; k++) {
                            col_name = ref_table_cols_names[k];
                            for (l=0; l<table_pk_cols_names.length; l++) {
                                col_pk = table_pk_cols_names[l];
                                name1 = col_name.replaceAll("[0-9]", "");
                                name2 = col_pk.replaceAll("[0-9]", "");
                                if (name1.contains(name2) || name2.contains(name1) || ((name1.contains("RL_TYP") || name1.contains("role_type")) && (name2.contains("RL_TYP") || name2.contains("role_type")))) {
                                    fake_index.add(table_pk_cols_base[l]);
                                    log_connected_cols.add(table_pk_cols_base[l].getName());
                                    table_pk_cols_names_sorted.add(col_pk);
                                }
                            }
                        }
                        table_pk_cols = fake_index.getColumns();
                        for (var m=0; m<table_pk_cols.length; m++) {
	                   	   attr_from = related_table.getElementByName(table_pk_cols_names_sorted[m]).getEngAttribute();
	                   	   col_to = table_pk_cols[m];
	                   	   createMappingForAttrAndOverlapping(rel_model, attr_fold_map, attr_from, col_to);
	                   }
                        fake_index.remove();
                    } else {
                        table_pk_cols_names = new java.util.ArrayList();
                        table_pk_cols = new_index.getColumns();
                        fake_index = related_table.createIndex();
                        for (var k=0; k<table_pk_cols.length; k++) {
                            c = table_pk_cols[k];
                            c_name  = c.getName();
                            original_c = table.getElementByName(c_name);
                            log_new_fk_cols.add(c_name);
                            log_connected_cols.add(c_name);
                            if (related_table.getElementByName(c_name) == null) {
                            	   created_c = related_table.createColumn();
                                 original_c.copy(created_c);
                                 created_c.setDirty(true);
                            }
                            created_c = related_table.getElementByName(c_name);
                            fake_index.add(created_c);
                            // Find previous column that resembles this one
                            for (var n=0; n<related_table_columns.length; n++) {
                                rel_t_col = related_table_columns[n];
                                rel_t_attr = rel_t_col.getEngAttribute();
                                name1 = rel_t_col.getName().replaceAll("[0-9]", "");
                                name2 = c_name.replaceAll("[0-9]", "");
                                if (name1.contains(name2) || name2.contains(name1) || ((name1.contains("RL_TYP") || name1.contains("role_type")) && (name2.contains("RL_TYP") || name2.contains("role_type")))) {
                                    // Add mappings
                                    createMappingForAttrAndOverlapping(rel_model, attr_fold_map, rel_t_attr, created_c);
                                }
                            }
                        }
                        table_pk_cols = fake_index.getColumns();
                        fake_index.remove();
                    }
                    related_table.setDirty(true);
                    // Change fk constraint
                    fk.changeKeyObject(ref_table_pk, table_pk_cols);
                    app_view.logMessage("----- New foreign key: " + log_new_fk_cols + " on " + log_connected_cols);
                    
                    fk.setMandatory(true);
                    app_view.logMessage("----- Foreign key set to mandatory");
                }
            }
            related_table.setDirty(true);
        }
    }

    // Remove columns
    for (var i = 0; i < columns_to_remove.length; i++) {
        col = columns_to_remove[i];
        col.remove();
    }
    app_view.logMessage("--- " + columns_to_remove.length + "/" + columns.length + " columns removed");
    app_view.logMessage("--- Columns removed: " + columns_to_remove);
    table.setDirty(true);
    
    // Remove empty constraints
    keys = table.getKeys();
    log_empty_constraints_removed = 0;
    for (var i = 0; i < keys.length; i++) {
        index = keys[i];
        index_c = index.getColumns();
        if (index_c.length==0) {
            log_empty_constraints_removed += 1;
            index.remove();
        }
        table.setDirty(true);
    }
    app_view.logMessage("--- " + log_empty_constraints_removed + "/" + keys.length + " keys removed");
    
    // Set relationships to mandatory in entty_rl
    fks = table.getFKAssociationsList();
    log_fks_to_mandatory = 0;
    for (var j=0; j<fks.length; j++) {
        fk = fks[j];
        cols = fk.getColumns();
        for (var i=0; i<cols.length; i++) {
            col = cols[i];
            if (col.isPKElement()) {
                fk.setMandatory(true);
            }
        }
        log_fks_to_mandatory += 1;
        fk.setMandatory(true);
        table.setDirty(true);
    }
    app_view.logMessage("--- " + log_fks_to_mandatory + "/" + fks.length + " foreign keys set to mandatory");
    table.setDirty(true);

    // Updated columns: now we should have no repetition in columns so we can remove numbers from names
    updated_cols = table.getElements();
    for (var i = 0; i < updated_cols.length; i++) {
        col = updated_cols[i];
        removeNumbersfromColumns(col);
    }
    table.setDirty(true);

    // Amend domain of primary concept:
    // Check if domain with these members already exist, otherwise set it to Unknown and print expected members
    
    if (excluded_to_amend_domains.contains(primary_concept)) {
           app_view.logMessage("--- Primary concept column " + primary_concept + " will not be amended (included in other script)");
    } else {
           primary_concept_column = table.getElementByName(primary_concept);
           matching_domain = getMatchingDomain(primary_concept_column, primary_concept_domain);
        app_view.logMessage("--- Primary concept column " + primary_concept + " amended");
        app_view.logMessage("----- New domain allowed values: " + primary_concept_domain);
        if (!matching_domain) {
               app_view.logMessage("------- No match");
               new_domain = createDomain(primary_concept_domain);
               primary_concept_column.setDomain(new_domain);
        }
    }
    table.setDirty(true);
    app_view.logMessage("--- " + log_cols_replaced_by_primary_concept.length + "/" + columns.length + " columns replaced by a primary concept");
    app_view.logMessage("----- Columns replaced by primary concept: " + log_cols_replaced_by_primary_concept);
    app_view.logMessage("--- " + log_related_tables_amended + "/" + log_related_tables + " related tables amended");
}]]>
		</script>
	</scr>
	<scr id="EA562B77-6014-2466-405C-D5B5A1FCB523" name="Generalisation" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Generalisation
 *  PURPOSE: Generalisations have surrogate primary key created after fe. 
 *           When subtypes actually have the same primary keys, we want the generalisation to have that pk.   
 *           EXAMPLE: (INSTRMNT_ID, DBTR_PRTY_RL, DBTR_PRTY_RL_TYP), (INSTRMNT_ID, SRVCR_PRTY_RL, SRVCR_PRTY_RL_TYP) -> 
 *                    (INSTRMNT_ID, PRTY_RL, PRTY_RL_TYP)
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run after Entity role
 *  DYNAMIC: excluded list
 *           is_preferred_abbreviation
 *  SHORT DESCRIPTION: During fe, the Table gets a surrogate primary key, which needs to be changed to primary key defined on subtypes. 
 *                     Changes foreign key relationships, which are now part of the primary key, to mandatory.
*/

// ---- INPUT PARAMETERS ----
var is_preferred_abbreviation = false;
script_name = "Generalisation";

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");
log_tables_affected = 0;

rel_model = model;
domains = model.design.getDomainSet().toArray();
tables = model.getTableSet().toArray();
primary_table_name = "ENTTY_RL";
// We exclude entities where we leave surrogate primary key or were hadled before
excluded = new java.util.ArrayList(["SCTRY_BRRWNG_LNDNG_TRNSCTN_INCLDNG_CSH_CLLTRL", 
                            "Security_borrowing_and_lending_transaction_including_cash_as_collateral_component",
                            "ENTTY_RL", 
                            "Entity_role",
                            "ABSTRCT_INSTRMNT_RL",
                            "Abstract_instrument_role"]);

replacibles = new java.util.ArrayList([
//"PRTY_RL_TYP", 
 //                                      "Party_role_type",    
 //                                      "ORGNSTN_RL_TYP",
 //                                      "Organisation_role_type", 
  //                                     "LGL_PRSN_RL_TYP", 
  //                                     "Legal_person_role_type",
 //                                      "DBTR_PRTY_RL_TYP", 
  //                                     "Debtor_Party_role_type",
  //                                     "SRVCR_PRTY_RL_TYP",
  //                                     "Servicer_Party_role_type",
  //                                     "ISSR_ORGNSTN_RL_TYP",
  //                                     "Other_organisation_role_type",
  //                                     "OTHR_ORGNSTN_RL_TYP",
  //                                     "PRTCTN_PRVD_ORGNSTN_RL_TYPE",
  //                                     "Protection_provider_Organisation_role_type"
  ]);
primary_concept = "PRTY_RL_TYP";
if (is_preferred_abbreviation==false) {
    primary_concept = "Party_role_type";
    primary_table_name = "Entity_role";
}


primary_table = model.getTableSet().getByName(primary_table_name);
primary_concept_column = primary_table.getElementByName(primary_concept);

for (var g=0; g<tables.length; g++) {
    table = tables[g];
    table_name = table.getName();
    // Check if it is a generalisation: Entity didn't have pk, is root of hierarchy, is in a hierarchy
    entity = table.getEngEntity();
    is_hierarchy = entity.isHierarchicalEntityType();
    is_root = entity.isHierarchicalRoot();
    no_pk = entity.isCreateSurrogateKey();
    if (is_hierarchy && is_root && no_pk && !excluded.contains(table.getName())) {
        // Overlapping attributes of the hierarchy
        folded_attrs_list = getOverlappingAttributesOfHierarchy(entity);
        attributes_to_replace = folded_attrs_list[0];
        attr_fold_map = folded_attrs_list[1];
        log_tables_affected += 1;
        app_view.logMessage("- Table " + table_name + " amended");
        app_view.logMessage("- Fold " + attr_fold_map);
        columns_to_remove = new java.util.ArrayList();
        pks = new java.util.HashMap();
        mappers = new java.util.HashMap();
        columns = table.getElements();
        log_cols_replaced_by_primary_concept = new java.util.ArrayList();
        for (var i=0; i<columns.length; i++) {
            column = columns[i];
            if (column.isSurrogateColumn()==true) {
                columns_to_remove.add(column);
                col_name = column.getName();
                app_view.logMessage("--- Surrogate key " + col_name + " removed");
            } else {
                attribute = column.getEngAttribute();
                // check if attribute was a primary key (and not foreign key):
                // in this case, check if it is one of the replacibles and replace it with its head member
                attr_name = getFEName(attribute, is_preferred_abbreviation);
                if (attribute.isPKElement()==true && attribute.isFKAttribute()==false) {
                    // type_ columns, attrs
                    if (replacibles.contains(attr_name)) {
                        log_cols_replaced_by_primary_concept.add(attr_name);    
                        attr_name = primary_concept;
                        if (pks.containsKey(primary_concept)==true) {
                            columns_to_remove.add(column);
                            mappers.put(attribute, primary_concept_column);
                        } else {
                            column.setName(attr_name);
                        }
                    } else {
                        exists = table.getElementByName(attr_name);
                        if (exists != null) {
                            //app_view.logMessage("----- Found matching column with name " + attr_name);
                        } else {
                            //app_view.logMessage("----- Set column name to " + attr_name);
                            column.setName(attr_name);
                        }
                    }
                    if (pks.containsKey(attr_name)==false) {
                        exists = table.getElementByName(attr_name);
                        if (exists != null) {
                            pks.put(attr_name, exists);
                            //app_view.logMessage("----- Chose exsisting column and added to pk " + attr_name);
                        } else {
                            pks.put(attr_name, column);
                            //app_view.logMessage("----- Chose renamed column and added to pk " + attr_name);
                        }
                    } else {
                        mapped_to_col = pks.get(attr_name);
                        columns_to_remove.add(column);
                        //app_view.logMessage("----- Attr already in pk " + attr_name);
                        mappers.put(attribute, mapped_to_col);
                    }
                }
                if (attribute.isFKAttribute()==true && attribute.isPKElement()==true) {
                    // If foreign keys come from the same entity, (same name of attribute), rename the column and keep only one
                    attr_name = getFEName(attribute.getOriginatingAttribute(), is_preferred_abbreviation);
                    app_view.logMessage("----- Originating column name " + attr_name);
                    if (replacibles.contains(attr_name)) {
                        log_cols_replaced_by_primary_concept.add(attr_name);    
                        attr_name = primary_concept;
                        if (pks.containsKey(primary_concept)==true) {
                            columns_to_remove.add(column);
                        } else {
                            column.setName(attr_name);
                        }
                    } else {
                        exists = table.getElementByName(attr_name);
                        if (exists != null) {
                            //app_view.logMessage("----- Found matching column with name " + attr_name);
                        } else {
                            //app_view.logMessage("----- Set column name to " + attr_name);
                            column.setName(attr_name);
                        }
                    }
                    if (pks.containsKey(attr_name)==false) {
                        exists = table.getElementByName(attr_name);
                        if (exists != null) {
                            pks.put(attr_name, exists);
                            //app_view.logMessage("----- Chose exsisting column and added to pk " + attr_name);
                        } else {
                            pks.put(attr_name, column);
                            //app_view.logMessage("----- Chose renamed column and added to pk " + attr_name);
                        }
                        if (column.getName()!=attr_name) {
                            columns_to_remove.add(column);
                            mappers.put(attribute, exists);
                        }
                    } else {
                        if (column.getName()!=attr_name) {
                            mapped_to_col = pks.get(attr_name);
                            columns_to_remove.add(column);
                            //app_view.logMessage("----- Already in pk " + attr_name);
                            mappers.put(attribute, mapped_to_col);
                        }
                    }
                }
            }
            table.setDirty(true);
        }
        
        // Set new primary key
        newIndex = table.createIndex();
        log_pk_col_names = new java.util.ArrayList();
        keys = pks.keySet().toArray();
        for (var i = 0; i < pks.size(); i++) {
            col = pks.get(keys[i]);
            col.setMandatory(true);
            log_pk_col_names.add(col.getName());
            newIndex.add(col);
        }
        newIndex.setPK(true);
        app_view.logMessage("--- Primary key constraint amended");
        app_view.logMessage("----- New primary key: " + log_pk_col_names);
        table.setDirty(true);

        // Change foreign key associations with ENTTY_RL
        log_related_tables_amended = 0;
        log_related_tables = 0;
        for (var s=0; s<tables.length; s++) {
            related_table = tables[s];
            related_entity = related_table.getEngEntity();
            // Overlapping attributes of the hierarchy
            folded_attrs_list = getOverlappingAttributesOfHierarchy(related_entity);
            attributes_to_replace = folded_attrs_list[0];
            attr_fold_map = folded_attrs_list[1];
            fks = related_table.getFKIndexAssociationsWith(table);
            related_table_name = related_table.getName();
            related_table_columns = related_table.getElements();
            if (related_table_name != table.getName() && !excluded.contains(related_table.getName())) {
                log_related_tables += fks.length;
                for (var j=0; j<fks.length; j++) {
                    fk = fks[j];
                    ref_table = fk.getRemoteTable();
                    ref_index = fk.getRemoteIndex();
                    ref_table_pk = ref_table.getPK();
                    ref_table_cols = ref_table_pk.getColumns();
                    app_view.logMessage("--- Related table " + related_table_name + " amended");
                    log_related_tables_amended += 1;
                    if (ref_index.isPK()==false) {
                        // If it's not a generalisation, add columns from primary key
                        is_generalisation = related_entity.isCreateSurrogateKey();
                        log_new_fk_cols = new java.util.ArrayList();
                        log_connected_cols = new java.util.ArrayList();
                        if (is_generalisation==false) {
                            table_pk_cols_base = fk.getColumns(); // existing columns in related table
                            // Prepare names of pk columns, so that we connect correct columns
                            ref_table_cols_names = new java.util.ArrayList();
                            table_pk_cols_names = new java.util.ArrayList();
                            table_pk_cols_names_sorted = new java.util.ArrayList();
                            fake_index = related_table.createIndex();
                            for (var k=0; k<ref_table_cols.length; k++) {
                                ref_c = ref_table_cols[k];
                                log_new_fk_cols.add(ref_c.getName());
                                c = table_pk_cols_base[k];
                                ref_table_cols_names.add(ref_c.getName());
                                table_pk_cols_names.add(c.getName());
                            }
                            for (var k=0; k<ref_table_cols_names.length; k++) {
                                col_name = ref_table_cols_names[k];
                                for (l=0; l<table_pk_cols_names.length; l++) {
                                    col_pk = table_pk_cols_names[l];
                                    name1 = col_name.replaceAll("[0-9]", "");
                                    name2 = col_pk.replaceAll("[0-9]", "");
                                    if (name1.contains(name2) || name2.contains(name1) || ((name1.contains("RL_TYP") || name1.contains("role_type")) && (name2.contains("RL_TYP") || name2.contains("role_type")))) {
                                        fake_index.add(table_pk_cols_base[l]);
                                        log_connected_cols.add(table_pk_cols_base[l].getName());
                                        table_pk_cols_names_sorted.add(col_pk);
                                    }
                                }
                            }
                            table_pk_cols = fake_index.getColumns();
                            for (var m=0; m<table_pk_cols.length; m++) {
                                  attr_from = related_table.getElementByName(table_pk_cols_names_sorted[m]).getEngAttribute();
                                  col_to = table_pk_cols[m];
                                  createMappingForAttrAndOverlapping(rel_model, attr_fold_map, attr_from, col_to);
                          }
                          fake_index.remove();
                        } else {
                            table_pk_cols = new_index.getColumns();
                            fake_index = related_table.createIndex();
                            for (var k=0; k<table_pk_cols.length; k++) {
                                c = table_pk_cols[k];
                                c_name = c.getName();
                                log_new_fk_cols.add(c.getName());
                                log_connected_cols.add(c.getName());
                                if (related_table.getElementByName(c_name) == null) {
	                            	   created_c = related_table.createColumn();
	                                 original_c.copy(created_c);
	                                 created_c.setDirty(true);
	                            }
	                            created_c = related_table.getElementByName(c_name);
	                            fake_index.add(created_c);
                                // Find previous column that resembles this one
                                for (var n=0; n<related_table_columns.length; n++) {
                                    rel_t_col = related_table_columns[n];
                                    rel_t_attr = rel_t_col.getEngAttribute();
                                    name1 = rel_t_col.getName().replaceAll("[0-9]", "");
                                    name2 = c_name.replaceAll("[0-9]", "");
                                    if (name1.contains(name2) || name2.contains(name1) || ((name1.contains("RL_TYP") || name1.contains("role_type")) && (name2.contains("RL_TYP") || name2.contains("role_type")))) {
                                        // Add mappings 
                                        createMappingForAttrAndOverlapping(rel_model, attr_fold_map, rel_t_attr, created_c);
                                    }
                                }
                            }
                            table_pk_cols = fake_index.getColumns();
                            fake_index.remove();
                        }
                        fk.changeKeyObject(ref_table_pk, table_pk_cols);
                        app_view.logMessage("----- New foreign key: " + log_new_fk_cols + " on " + log_connected_cols);
                        fk.setMandatory(true);
                        app_view.logMessage("----- Foreign key set to mandatory");
                    }
                }
                related_table.setDirty(true);
            }
        }

        // Relations, which have fk columns as part of primary key, need to be mandatory
        fks = table.getFKAssociationsList();
        log_fks_to_mandatory = 0;
        log_fk = false;
        for (var j=0; j<fks.length; j++) {
            fk = fks[j];
            cols = fk.getColumns();
            for (var i=0; i<cols.length; i++) {
                col = cols[i];
                if (col.isPKElement()) {
                    log_fk = true;
                    col.setMandatory(true);
                    fk.setMandatory(true);
                }
            } 
            if (log_fk) {
                log_fks_to_mandatory += 1;
            }
        }
        app_view.logMessage("--- " + log_fks_to_mandatory + "/" + fks.length + " foreign keys set to mandatory");
        table.setDirty(true);

        m_keys = mappers.keySet().toArray();
        for (var i = 0; i < mappers.size(); i++) {
            col = mappers.get(m_keys[i]);
            createMappingForAttrAndOverlapping(rel_model, attr_fold_map, m_keys[i], col);
        }
        table.setDirty(true);
        
        // Remove columns in columns_to_remove
        for (var i = 0; i < columns_to_remove.length; i++) {
            col = columns_to_remove[i];
            col.remove();
        }
        app_view.logMessage("--- " + columns_to_remove.length + "/" + columns.length + " columns removed");
        app_view.logMessage("--- Columns removed: " + columns_to_remove);
        
        // Remove empty constraints
        keys = table.getKeys();
        log_empty_constraints_removed = 0;
        for (var i = 0; i < keys.length; i++) {
          index = keys[i];
          index_c = index.getColumns();
          if (index_c.length==0) {
              log_empty_constraints_removed += 1;
              index.remove();
           }
           table.setDirty(true);
        }
        app_view.logMessage("--- " + log_empty_constraints_removed + "/" + keys.length + " keys removed");
    }
    table.setDirty(true);
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_tables_affected + "/" + tables.length + " tables affected");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");


// ---- FUNCTIONS ----
function getFEName(attribute, is_preferred_abbreviation) {
    /*
    Input: Attribute, Bool
    Output: String
    Description: Returns preffered abbreviation of attribute in case of using pref.abbr. for fe, 
                 othervise returns attribute names with underscores instead of spaces
    */ 
    if (is_preferred_abbreviation==true) {
        fe_name = attribute.getPreferredAbbreviation();
    } else {
        attr_name = attribute.getName();
        fe_name = attr_name.replaceAll(" ", "_"); 
    }
    return fe_name
}

function getHierarchicalTree(entity) {
    leaves = entity.getHierarchicalLeaves();
    hierarchy_tree = new java.util.HashSet();
    hierarchy_tree.add(entity);
    if (entity.isHierarchicalEntityType()) {
        for (var i=0; i<leaves.length; i++) {
            leaf = leaves[i];
            hierarchy_tree.add(leaf);
            parent = leaf.getHierarchicalParent();
            is_downwrapped = parent.getAttributeInherType()=='All atributes';
            // Igore the ones that are downwrapped
            if (!is_downwrapped) {
                while (parent.getName() != entity.getName()) {
                    hierarchy_tree.add(parent);
                    parent = parent.getHierarchicalParent();
                }
            }
        }
    }
    return hierarchy_tree;
}


function getOverlappingAttributesOfHierarchy(entity) {
    hierarchy_tree = getHierarchicalTree(entity).toArray();
    attributes_to_replace = new java.util.ArrayList();
    attr_fold_map = new java.util.HashMap();
    for (var i=0; i<hierarchy_tree.length; i++) {
        ent1 = hierarchy_tree[i];
        attrs = ent1.getAttributeSet();
        folded_attrs = ent1.getFoldedAttributesMap();
        keys = folded_attrs.keySet().toArray();
        for (var j=0; j<keys.length; j++) {
            attr1_id = keys[j];
            attr2_id = folded_attrs.get(attr1_id);
            attr1 = attrs.getObjectByID(attr1_id);
            orig_attr1 = attr1.getOriginatingAttribute();
            attr2 = attrs.getObjectByID(attr2_id);
            orig_attr2 = attr2.getOriginatingAttribute();
            attributes_to_replace.add(orig_attr1.getName());
            attr_fold_map.put(attr1, attr2);
        }
    }
    return [attributes_to_replace, attr_fold_map]
}


function createMappingForAttrAndOverlapping(relational_model, attr_fold_map, attribute, column) {
    f_attr_name = attribute.getName();
    folded = attr_fold_map.get(attribute);
    relational_model.getRMExtendedMap().createMapping(attribute, column);
    app_view.logMessage("------- Created mapping from attribute " + attribute + " to column " + column);
    if (folded != null) {
        relational_model.getRMExtendedMap().createMapping(folded, column);
        app_view.logMessage("------- Created mapping from attribute " + folded.getName() + " to column " + column.getName());
    }
}]]>
		</script>
	</scr>
	<scr id="F315EFDF-2EC6-1624-9FF1-D568135D970A" name="Disjoint subtyping" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Disjoint subtyping
 *  PURPOSE: For disjoint subtypes or implicit subtyping different form of merging applies.  
 *  EXAMPLE: LDM1: "Financial asset in the form of an instrument or security position" ->  
 *           columns from Financial asset according to International Financial Reporting Standard (IFRS) and 
 *           Financial asset according to national general accepted accounting principles (nGAAP)
 *           need to be copied into remaining disjoint subtypes and then Tables deleted
 *              LDM2: columns from Fair valued financial liability have to be copied into Financial liability in the form of a debt security issued, 
 *           then table deleted
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run before removal of duplicated columns
 *  DYNAMIC: 
 *  SHORT DESCRIPTION: Where the is no pk on Entities in one arc but there are in the other, make columns in the one without pks optional, 
 *                     copy them into other arc subtypes, remove subtypes without pks
*/

// ---- INPUT PARAMETERS ----
script_name = "Disjoint subtyping";

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");
tables = model.getTableSet().toArray();
log_tables_affected = 0;
log_tables_removed = new java.util.ArrayList();
for (var t=0; t<tables.length; t++){
    table = tables[t];
    table_name = table.getName();
    entity = table.getEngEntity();
    is_hier = entity.isHierarchicalEntityType();
    relations = entity.getRelations();
    if (is_hier || relations.length>0) {
        // Find ones with two arcs or one and optional-one-to-one-relationship 
        arcs = table.getArcs();
        num_of_arcs = arcs.length - 1; // fe adds one joint arc
    
        primaries = new java.util.ArrayList(); // they have primary key
        removables = new java.util.ArrayList(); // no primary key
        // Disjoint implicit subtyping:
        // primary key is defined on the same level as impict subtype (on other entities on the same level of hierarchy), 
        // but implicit subtype does not have a primary key 
        if (relations) {
            relation = relations[0];
            source_ent = relation.getSourceEntity();
            source_table = source_ent.getEngTable(model);
            leaves = source_ent.getHierarchicalLeaves();
            implicit_pk = entity.getPK();
            pk_on_subtypes = true;
            for (var i=0; i<leaves.length; i++) {
                leaf = leaves[i];
                if (leaf.getPK()==null) {
                    pk_on_subtypes = false;    
                }
            }
            is_disjoint_implicit = relations.length==1 && implicit_pk==null && pk_on_subtypes==true
            if (is_disjoint_implicit) {
                 app_view.logMessage("- Table " + table_name + " amended");
                 app_view.logMessage("--- Is disjoint implicit subtype");
                 log_tables_affected += 1;
                relations = entity.getRelations();
                relation = relations[0];
                source_ent = relation.getSourceEntity();
                columns = table.getElements();
                log_set_to_mandatory = 0;
                removables.add(table);
                for (var i=0; i<columns.length; i++) {
                    column = columns[i];
                    if (column.isFKColumn()==false && column.isPKElement()==false) {
                        column.setMandatory(false);
                        log_set_to_mandatory +=1;
                    }
                    table.setDirty(true);
                }
                app_view.logMessage("--- " + log_set_to_mandatory + "/" + columns.length + "columns set to optional"); 
                for (var i=0; i<leaves.length; i++) {
                    leaf = leaves[i].getEngTable(model);
                    primaries.add(leaf);
                }
            }
        }
       
        // Disjoint subtyping: find ones with pks on entity
        if (num_of_arcs==2) {
              app_view.logMessage("--- Is disjoint subtype");
            for (var i = 1; i < 1+num_of_arcs; i++) {
                arc = arcs[i];
                fkeys = arc.getFkeys();
                for (var j = 0; j < fkeys.length; j++) {
                    fkey = fkeys[j];
                    fk_table = fkey.getTable();
                    fk_entity = fk_table.getEngEntity();
                    pk = fk_entity.getPK();
                    if (pk!=null) {
                        primaries.add(fk_table);
                    } else {
                        leaves = fk_entity.getHierarchicalLeaves();
                        if (leaves.length==1) {
                            removables.add(fk_table);
                            cols = fk_table.getElements();
                            log_cols_to_optional = 0;
                            for (var k=0; k<cols.length; k++) {
                                col = cols[k];
                                col.setMandatory(false);
                                log_cols_to_optional += 1;
                            }
                            app_view.logMessage("--- " + log_cols_to_optional + "/" + cols.length + "columns set to optional");
                        } else {
                            for (var l=0; l<leaves.length; l++) {
                                leaf = leaves[l];
                                leaf_table = leaf.getEngTable(model);
                                if (leaf_table) {
                                    primaries.add(leaf_table);
                                }    
                            }    
                        }
                    }
                } 
            }
        } 
    
        // Copy columns from removables to primaries if not added yet
        for (var i=0; i<removables.length; i++) {
            removable = removables[i];
            log_tables_removed.add(removable.getName());
            log_num_copied_cols = 0;
            cols = removable.getElements();
            log_cols_to_copy = new java.util.ArrayList();
            for (var k=0; k<cols.length; k++) {
                col = cols[k];
                if (!col.isFKColumn()) {
                    log_cols_to_copy.add(col.getName());
                    for (var j=0; j<primaries.length; j++) {
                    primary = primaries[j];
                    app_view.logMessage("--- Copied columns from " + removable.getName() + " to " + primary.getName());
                    is_present = primary.getElementByName(col.getName());
                        if (is_present==null) {
                            c = primary.createColumn();
                            col.copy(c);
                            log_num_copied_cols += 1;
                            primary.setDirty(true);
                        } 
                    }
                }
            }
            app_view.logMessage("----- " + log_num_copied_cols + "/" + cols.length + " columns copied");
            app_view.logMessage("----- Copied columns: " + log_cols_to_copy);
            removable.remove();
            app_view.logMessage("--- Table " + removable.getName() + " removed");
        }
    }
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_tables_removed.length + "/" + tables.length + " tables affected");
app_view.logMessage("- " + log_tables_affected + "/" + tables.length + " tables removed");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="206237BE-D0FA-B7F9-79F0-83D6DDCC2195" name="Merge one-to-one relationships" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME: Merge one-to-one relationships
 *  PURPOSE:   
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run after optional one-to-one relationships
 *  DYNAMIC: merge_derived_entities
 *  SHORT DESCRIPTION: copies columns from Tables with one one-to-one relationship to target table and removes source Table
*/

// ---- INPUT PARAMETERS ----
merge_derived_entities = true;
script_name = "Merge one-to-one relationships";

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

rel_model = model;
tables = model.getTableSet().toArray();
log_tables_deleted = new java.util.ArrayList();
log_cols_moved = 0;
for (var t = 0; t < tables.length; t++){
    table = tables[t];
    tname = table.getName();
    is_derived = tname.contains("DRVD") || tname.contains("derived") || tname.contains("Derived");
    if (merge_derived_entities==true || (merge_derived_entities==false && is_derived==false)) {
        entity = table.getEngEntity();
        num_of_relations = table.getFKAssociations().length;
        relations = entity.getRelations();
        if (num_of_relations==1) {
            //is_identifying = relations[0].isIdentifying();
            is_identifying = true;
            is_one_to_one = false;
            // If exactly one relationship is one to one, we merge it
            is_hier_entity = entity.isHierarchicalEntityType();
            is_one_to_one = relations[0].isOneToOne();
            
            if (num_of_relations==1 && is_identifying && is_one_to_one && !is_hier_entity) {
            	 attr_fold_map = new java.util.HashMap();
                fk = table.getFKAssociations()[0];
                target_table = fk.getRemoteTable();
                columns = table.getElements();
                app_view.logMessage("- Table " + tname + " merged into table " + target_table.getName());
                // Copy columns from table to target and remove table
                log_merged_columns = new java.util.ArrayList();
                for (var i = 0; i < columns.length; i++) {
                    column = columns[i];
                    if (column.isFKColumn()==false) {
                    	attr = column.getEngAttribute();
	                    log_merged_columns.add(column.getName());
	                    col = target_table.createColumn();
	                    column.copy(col);
	                    createMappingForAttrAndOverlapping(rel_model, attr_fold_map, attr, col);
	                    
	                    if (is_derived){
	                    	new_name = "Derived_" + col.getName();
	                    	col.setName(new_name)        
	                    }
	                    target_table.setDirty(true);
                    }    
                }
                log_cols_moved += columns.length;
                app_view.logMessage("--- " + log_merged_columns.length + "/" + columns.length + " columns moved");
                app_view.logMessage("--- Columns moved: " + log_merged_columns);
                target_table.setDirty(true);
                log_tables_deleted.add(tname);
                rel_model.getRMExtendedMap().createMapping(entity, target_table);
			 app_view.logMessage("------- Created mapping from entity " + entity.getName() + " to table " + target_table.getName());
                table.remove();
            }
        }
    }
}
rel_model.setDirty(true);
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_tables_deleted.length + "/" + tables.length + " tables deleted");
app_view.logMessage("- " + log_cols_moved + " columns moved");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");


function createMappingForAttrAndOverlapping(relational_model, attr_fold_map, attribute, column) {
    f_attr_name = attribute.getName();
    folded = attr_fold_map.get(attribute);
    relational_model.getRMExtendedMap().createMapping(attribute, column);
    app_view.logMessage("------- Created mapping from attribute " + attribute + " to column " + column);
    if (folded != null) {
        relational_model.getRMExtendedMap().createMapping(folded, column);
        app_view.logMessage("------- Created mapping from attribute " + folded.getName() + " to column " + column.getName());
    }
}]]>
		</script>
	</scr>
	<scr id="AB58D57D-DE40-A3BB-AE77-2DC54A6674C5" name="Remove unique constraints" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME: Remove unique constraints
 *  PURPOSE: when wrapping up, primary keys of subtypes are converted into unique constraints which do not hold anymore
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run after entity role, before generalisation
 *  DYNAMIC: 
 *  SHORT DESCRIPTION: removes unique constraints on Tables and indexes, which are not used by any constraint
*/

// ---- INPUT PARAMETERS ----
script_name = "Remove unique constraints";

// ---- SCRIPT ----
var app_view = model.getAppView();
tables = model.getTableSet().toArray();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");
log_tables_amended = 0;
log_total_const_removed = 0;
for (var g=0; g<tables.length; g++) {
    table = tables[g];
    table_name = table.getName();
    keys = table.getKeys();
    log_is_amended = false;
    log_const_removed = 0;
    for (var i=0; i<keys.length; i++) {
        index = keys[i];
        // Indexes, by default if not changed, have state Unique Plain Index
        state = index.getIndexState();
        if (state=="Unique Plain Index" || (index.isPK()==false && index.isUnique()==true)) {
            log_is_amended = true;
            index.remove();
            table.setDirty(true);
            log_const_removed += 1;
            log_total_const_removed += 1;
        }
    }
    if (log_is_amended) {
        log_tables_amended += 1;
        app_view.logMessage("- Table " + table_name + " amended");
        app_view.logMessage("--- " + log_const_removed + "/" + keys.length + " unique constraints removed");
    }
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_tables_amended + "/" + tables.length + " tables amended");
app_view.logMessage("- " + log_total_const_removed + " unique constraints deleted");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="817B2CB5-7B46-B3F6-E218-C00B4217A9D8" name="Set foreign keys to primary key index" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Set foreign keys to primary key index
 *  PURPOSE: When wrapping up, primary keys of subtypes are converted into unique constraints. 
 *             If some Entity is related to such Subtype, in relational model this relationship becomes a foreign key, which has index     
 *             of unique constraint created.
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run after generalisation
 *  DYNAMIC: 
 *  SHORT DESCRIPTION: Goes through foreign keys and finds the ones that are defined on a unique constraint index. In this case, it 
 *                     sets the index to primary key index of a Table.
*/

// ---- INPUT PARAMETERS ----
script_name = "Set foreign keys to primary key index";

// ---- SCRIPT ----
var app_view = model.getAppView();
tables = model.getTableSet().toArray();
new_index_columns = new java.util.ArrayList();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");
log_total_num_fks = 0;
log_total_fks_affected = 0;
log_tables_amended = 0;
// Change foreign key associations
for (var s=0; s<tables.length; s++) {
    related_table = tables[s];
    table_name = related_table.getName();
    entity = related_table.getEngEntity();
    no_pk = entity.isCreateSurrogateKey();
    fks = related_table.getFKAssociationsList();
    log_total_num_fks += fks.length;
    is_amended = false;
    log_related_tables_amended = new java.util.ArrayList();
    log_fks_affected = 0;
    // Exclude generalisations
    if (no_pk==false) {
        for (var j=0; j<fks.length; j++) {
            fk = fks[j];
            ref_table = fk.getRemoteTable();
            ref_index = fk.getRemoteIndex();
            ref_table_pk = ref_table.getPK();
            if (ref_index.isPK()==false) {
                table_pk_cols_base = fk.getColumns();
                // Prepare names of pk columns, so that we connect correct columns
                ref_table_cols = ref_table_pk.getColumns();
                ref_table_cols_names = new java.util.ArrayList();
                table_pk_cols_names = new java.util.ArrayList();
                fake_index = related_table.createIndex();
                for (var k=0; k<ref_table_cols.length; k++) {
                    ref_c = ref_table_cols[k];
                    c = table_pk_cols_base[k];
                    ref_table_cols_names.add(ref_c.getName());
                    table_pk_cols_names.add(c.getName());
                }
                for (var k=0; k<ref_table_cols_names.length; k++) {
                    col_name = ref_table_cols_names[k];
                    for (l=0; l<table_pk_cols_names.length; l++) {
                        col_pk = table_pk_cols_names[l];
                        name1 = col_name.replaceAll("[0-9]", "");
                        name2 = col_pk.replaceAll("[0-9]", "");
                        if (name1.contains(name2) || name2.contains(name1)) {
                            fake_index.add(table_pk_cols_base[l]);
                        }
                    }
                }
                table_pk_cols = fake_index.getColumns();
                fk.changeKeyObject(ref_table_pk, table_pk_cols);
                fake_index.remove();
                fk.setMandatory(true);
                log_total_fks_affected += 1;
                is_amended = true;
                log_related_tables_amended.add(ref_table.getName());
                log_fks_affected += 1;
            }
        }
        if (is_amended==true) {
            related_table.setDirty(true);
            app_view.logMessage("- Table " + table_name + " amended");
            app_view.logMessage("--- " + log_fks_affected + "/" + fks.length + " foreign keys amended");
            app_view.logMessage("--- Amended foreign keys with tables: " + log_related_tables_amended);
            log_tables_amended += 1;  
        }
    }
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_tables_amended + "/" + tables.length + " tables amended");
app_view.logMessage("- "+ log_total_fks_affected + "/" + log_total_num_fks + " foreign keys amended");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="D29378AF-543A-AD4B-4EBF-75CE9E61FAA3" name="Reduce discriminators" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Reduce discriminators
 *  PURPOSE: In subtyping, disciminators are present for every level of hierarchy. 
 *           This script is run in case we don't want all discriminitors present
 *           in the target wrap up Entity but only one, which contains hierarchical leaves as members of its domain. 
 *           In case of disjoint subtyping, additional discriminator remains present.
 *           When we wrap down to the leaf of the hierarchy, creation of new discriminator is ignored, we only need to remove all
 *           discriminators which were passed down.
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run last
 *  DYNAMIC: Its use is optional.
 *           Provided is a list of discriminators which we do not want to merge (from disjoint subtypes).    
 *           Manually added maps of members to Entities. 
 *           Entity role and Abstract instrument role tables are excluded.
 *  SHORT DESCRIPTION: Removes lower level discriminators and creates a new one with TYP_<table_name> code. 
 *                     When a discriminator is a primary key, the new discriminator needs to be set to primary key.    
 *                     If the table with changed primary has relationships, they need to be changed to a new column.
 *                     Foreign key discriminators need to be ignored.
 *                    
 *                     In Logging page messages are seen, there are two types for every supertype:    
 *                     1. """No matching domain for discriminator of table table_name found.
 *                    Expected members: leaves_names_list
 *                      Expected sdd domain: table_name + type"""
 *                    2.  """Matching domain for discriminator of table table_name found:
 *                         domain_name""" 
 *                    In the case of first message, new sdd subdomain needs to be created. 
 *                     
*/

// ----INPUT PARAMETERS----
var is_preferred_abbreviation = false;
script_name = "Reduce discriminators";

// ----SCRIPT----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

// Discriminators which belong to disjoint subtype
discriminators_not_merged = new java.util.ArrayList(["ORGNSTN_TYP_BY_PRCDNG_STTS",
                                           "Organisation_type_by_legal_proceeding_status",    
                                           "INSTRMNT_TYP_ORGN",
                                           "Instrument_type_by_origin",
                                           "SCRTY_TYP_BY_IDNTFR",
                                           "Security_type_by_identifier",
                                           "SCRTY_BRRWNG_LNDNG_TRNSCTN_CMPNNT_TYP_BY_DRCTN",
                                           "Security_borrowing_and_lending_transaction_component_type_by_direction",
                                           "RTNG_SYSTM_TYP_BY_NTR",
                                           "Rating_system_type_by_nature_(Grade_vs._Numeric)",
                                           // Financial asset instrument
                                           "Financial_asset_instrument_type_by_CRR,_Article_123_(Retail_exposure)",
                                           "FNNCL_ASST_INSTRMNT_TYP_CRR_123",
                                           "Financial_asset_instrument_type_by_interest_rate_only",
                                           "FNNCL_ASST_INSTRMNT_TYP_INTRST_RT_ONL",
                                           "Financial_asset_instrument_type_by_fixed_interest_rate",
                                           "FNNCL_ASST_INSTRMNT_TYP_FXD_INTRST_RT",
                                           "Financial_asset_instrument_type_by_renegotiation_status",
                                           "FNNCL_ASST_INSTRMNT_TYP_RNGTTN_STTS",
                                           "Abstract_instrument_role_type",
                                           "ABSTRCT_INSTRMNT_RL_TYP",
                                           "PRTY_TYP_ADDRS",
                                           "Party_type_by_address"
                                           ]);

                                           
excluded_tables = new java.util.ArrayList(["ENTTY_RL",
                                           "Entity_role",
                                           ]);
excluded_columns = new java.util.ArrayList(["ABSTRCT_INSTRMNT_RL_TYP",
                                           "Abstract_instrument_role_type"
                                           ]);

log_num_discriminators_not_merged = discriminators_not_merged.length/2;
log_num_excluded_tables = excluded_tables.length/2;
app_view.logMessage("-" + log_num_discriminators_not_merged + " discriminators not merged");
app_view.logMessage("-" + log_num_excluded_tables + " tables excluded");                                       

// Prepare Entity Member map
rel_model = model;
entity_member_map = mapEntitiesToMembers();
entity_member_map_keys = entity_member_map.keySet().toArray();
tables = model.getTableSet().toArray();
var entity_name_entity_map = getEntityNameEntityMap();
log_tables_affected = 0;
log_total_disc_removed = 0;
log_total_disc = 0;
for (var t=0; t<tables.length; t++) { 
    table = tables[t];
    table_name = table.getName();
    if (!excluded_tables.contains(table_name)) {
        disjoint_domain_member_names_all = new java.util.ArrayList();
        main_entity = table.getEngEntity();
        app_view.logMessage("Ent: " + main_entity.getName());
        is_hier = main_entity.isHierarchicalEntityType();
        is_root = main_entity.isHierarchicalRoot();
        is_leaf = main_entity.getHierarchicalChildrenCount()==0;
       
        // Get all current discriminator columns: they have _TYP in the name
        num_levels = 1;
        columns = table.getElements();
        discriminators_to_remove = new java.util.ArrayList();
        new_discriminators = new java.util.ArrayList();
        app_view.logMessage("- Table " + table_name + " considered");
        app_view.logMessage(main_entity.getHierarchicalChildren());
        app_view.logMessage("Hier: " + is_hier + " Root:" + is_root + " Leaf: " + is_leaf); 
        for (var i=0; i<columns.length; i++) {
            col = columns[i];
            col_name = col.getName();
            is_fk = col.isFKColumn();
            if ((col_name.contains("_TYP") || col_name.contains("_type")) && !discriminators_not_merged.contains(col_name) && !is_fk) {
                discriminators_to_remove.add(col);
                num_levels += 1;
                if (col_name.contains("_TYP") || col_name.contains("_type")) {
                    log_total_disc += 1;
                }
            }
            if (is_hier && num_levels==3) {
                log_tables_affected += 1;
            }

            // If Table has disjoint subtyping, create a list of members of the domain of all disjoint discriminators 
            if (discriminators_not_merged.contains(col_name) && !excluded_columns.contains(col_name)) {
                 disjoint_domain_member_names = new java.util.ArrayList();
                app_view.logMessage("--- Column " + col_name + " is a disjoint discriminator");
                new_discriminators.add(col);
                // Get the domain of disjoint discriminator. Get members
                disjoint_domain = col.getDomain();
                domain_name = disjoint_domain.getName();
                disjoint_list_of_values = disjoint_domain.getValueList();
                member_map = disjoint_list_of_values.getValuesDescriptionMap();
                m = member_map.keySet().toArray();
                for (var k=0; k<m.length; k++) {
                    member_code = m[k];
                    description = member_map.get(member_code);
                    member_name = description.split(":")[0];
                    member = member_code + ": " + member_name;
                    disjoint_domain_member_names.add(member);
                }
                // Find Entities that are mapped to these members
                disjoint_child_entities = new java.util.ArrayList();
                for (var k=0; k<disjoint_domain_member_names.length; k++) {
                    member_name = disjoint_domain_member_names[k]; // code: member name
                    // Get entities from member names
                    for (var l=0; l<entity_member_map_keys.length; l++) {
                        candidate_ent_key = entity_member_map_keys[l]; // Entity name
                        candidate_ent = entity_member_map[candidate_ent_key]; // code: member name
                        memb = entity_member_map[candidate_ent_key].split(" | ")[1];
                        if (memb==member_name) {
                            disjoint_child_entities.add(candidate_ent_key);
                            break;
                        }
                    }
                }
                // Get leaves of these members (children). Merge lists of leaves
                // Now we have a list of child entity names. From them, we need to get their leaf entities
                disjoint_child_entities_leaves = new java.util.ArrayList();
                // Merge leaves from all dijoint children
                for (var k=0; k<disjoint_child_entities.length; k++) {
                    child_name = disjoint_child_entities[k]; // Entity name
                    // If child has no children it is a leaf
                    child = entity_name_entity_map.get(child_name);
                    num_grandchildren = child.getHierarchicalChildrenCount();
                    if (num_grandchildren==0) {
                        disjoint_child_entities_leaves.add(child);
                    } else {
                        disj_leaves = child.getHierarchicalLeaves();                        
                        disjoint_child_entities_leaves.addAll(disj_leaves);
                    }
                }
                // Map leaf entites to members. Check against existing domains.
                // Find expected members of the domain
                disj_leaves_member_list = new java.util.HashSet();
                for (var j=0; j<disjoint_child_entities_leaves.length; j++) {
                    leaf = disjoint_child_entities_leaves[j];
                    leaf_entity_name = leaf.getName();
                    mapped_entity = entity_member_map.get(leaf_entity_name);
                    // remove domain name, we compare actual members 
                    mapped_entity_member = mapped_entity.split(" | ")[1];
                    disj_leaves_member_list.add(mapped_entity_member);
                }
                // Maybe add Not applicable
                add_not_applicable = addNotApplicable(col);
                if (add_not_applicable) {
                    disj_leaves_member_list.add("0: Not applicable");
                }
                disjoint_domain_member_names_all.addAll(disj_leaves_member_list);
                // Find matching domain
                matching_domain_found = getMatchingDomain(col, disj_leaves_member_list);
                if (!matching_domain_found) {
                    app_view.logMessage("----- Allowed values: " + disj_leaves_member_list);
                    app_view.logMessage("----- No matching domain found.");
                    new_domain = createDomain(disj_leaves_member_list);
                    col.setDomain(new_domain);
                }
            }
        } // Status: updated disjoint discriminators domains, list disjoint_domain_member_names_all contains all members from these discriminators
        
        // If table is not a leaf of the hierarhy, change descriminator columns
        if (is_hier && num_levels>2) {
            is_pk = false;
            // Remove lower level discriminators
            // Mark if one of them is a primary key
            attrs_to_map = new java.util.ArrayList();
            for (var i=0; i<discriminators_to_remove.length; i++) {
                col = discriminators_to_remove[i];
                col_is_pk =  col.isPKElement();
                attrs_to_map.add(col.getEngAttribute());
                if (col_is_pk) {
                    is_pk = true;
                    // Find foreign indexes which include this column
                    fk_index = col.getFKIndexAssociation();
                }
                col.remove();
            }
            log_total_disc_removed += discriminators_to_remove.length;
            app_view.logMessage("--- " + discriminators_to_remove.length + " discriminators removed");
            app_view.logMessage("--- Discriminators removed: " + discriminators_to_remove);
            // Create new column with leaves of the hierarchy, if it does not exist yet and table is not entity leaf
            if (!is_leaf) {
                discriminator_name = "TYP_" + table_name;
                if (is_preferred_abbreviation==false) {
                    discriminator_name = "Type_of_" + table_name; 
                }
                if (table.getElementByName(discriminator_name)==null) {
                    granular_discriminator = table.createColumn();
                    granular_discriminator.setName(discriminator_name);
                    granular_discriminator.setMandatory(true);
                    app_view.logMessage("--- Discriminator added: " + discriminator_name);
                    if (is_pk) {
                        pk = table.getPKorUnique();
                        pk.add(granular_discriminator);
                        app_view.logMessage("----- Added to primary key constraint");
                    }
                } else {
                    app_view.logMessage("--- Discriminator found: " + discriminator_name);
                    granular_discriminator = table.getElementByName(discriminator_name);
                    if (is_pk) {
                        pk = table.getPKorUnique();
                        pk.add(granular_discriminator);
                        app_view.logMessage("----- Added to primary key constraint");
                    }
                }
                new_discriminators.add(granular_discriminator);
                app_view.logMessage("--- New discriminators: " + new_discriminators);

                // Add Mapping information from deleted discriminators to created discriminator
                for (var j=0; j<attrs_to_map.length; j++) {
                	attr_to_map = attrs_to_map[j];
                	rel_model.getRMExtendedMap().createMapping(attr_to_map, granular_discriminator);
			 	app_view.logMessage("------- Created mapping from attribute " + attr_to_map.getName() + " to column " + granular_discriminator.getName());
                }
			 
                
                // Find leaves of the hierarchy for granular discriminator
                leaves = main_entity.getHierarchicalLeaves();
                app_view.logMessage("Levaes: " + leaves);
                // If we have disjoint subtyping, split leaves into which type of subtyping they belong
                num_of_discriminators = new_discriminators.length
                granular_discriminator_attr = granular_discriminator.getEngAttribute();
                // Find expected members of the domain
                leaves_member_list = new java.util.HashSet();
                for (var j=0; j<leaves.length; j++) {
                    leaf = leaves[j];
                    leaf_entity_name = leaf.getName();
                    mapped_entity = entity_member_map.get(leaf_entity_name);
                    // Remove domain name, we compare actual members 
                    mapped_entity_member = mapped_entity.split(" | ")[1];
                    if (!disjoint_domain_member_names_all.contains(mapped_entity_member)) {
                        leaves_member_list.add(mapped_entity_member);
                    }
                }
                app_view.logMessage("--- Leaves of the discriminator: " + leaves_member_list);
                // Check if a domain with these members exists
                matching_domain_found = getMatchingDomain(granular_discriminator, leaves_member_list); 
                if (!matching_domain_found) { 
                    app_view.logMessage("----- No matching domain found.");
                    new_domain = createDomain(leaves_member_list);
                    granular_discriminator.setDomain(new_domain);
                }
            }
            
        }
    }
    table.setDirty(true);
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_total_disc_removed + "/" + log_total_disc + " discriminators removed");
app_view.logMessage("- " + log_tables_affected + "/" + tables.length + " tables affected");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

// ---- FUNCTIONS ----
function mapEntitiesToMembers(){
    /*
    Input: None
    Output: HashMap<String, String>
    Description: Map with key: "entity name", value: "domain name | sdd member code: member name" 
    */ 
    tables = model.getTableSet().toArray();
    entites = model.design.getLogicalDesign().getEntitySet().toArray();
    entity_member_map = new java.util.HashMap();
    no_match = 0;
    // For every entity, find it's parent and check if the entity name is present in members list of discriminator
    for (var i=0; i<entites.length; i++) {
        entity = entites[i];
        entity_name = entity.getName();
        is_hier = entity.isHierarchicalEntityType();
        is_root = entity.isHierarchicalRoot();
        // exclude entities, which are not hierarchial type, and roots
        if (is_hier && !is_root) {
            match = false;
            // Find it's parent and check if the entity name is present in members list of parent
            parent = entity.getHierarchicalParent();
            parent_attrs = parent.getAttributes();
            discriminators = new java.util.ArrayList();
            members = new java.util.ArrayList();
            for (var j=0; j<parent_attrs.length; j++) {
                attr = parent_attrs[j];
                is_discriminator = attr.getName().contains(" type");
                if (is_discriminator) {
                    discriminators.add(attr);
                    domain = attr.getDomain();
                    domain_name = domain.getName();
                    list_of_values = domain.getValueList();
                    if (list_of_values) {
                        member_map = list_of_values.getValuesDescriptionMap();
                        m = member_map.keySet().toArray();
                        for (var k=0; k<m.length; k++) {
                            member_code = m[k];
                            description = member_map.get(member_code);
                            if (domain_name != "Forbearance measure type") {
                                member_name = description.split(":")[0];
                            } else {
                                member_name = description;
                            }
                            member = domain_name + " | " + member_code + ": " + member_name;
                            if (member_name==entity_name || member_name==entity_name + "s") {
                                entity_member_map.put(entity_name, member);
                                match = true;
                                break;
                            }
                            members.add(member);
                        }
                    }
                }
            }
            if (!match) {
                no_match += 1;
                // No member had a matching name
            }
        }
    }
    
    // Members, which need to be mapped manually
    entity_member_map.put("Asset", "Balance sheet item type | 499: All assets");
    entity_member_map.put("Banking book", "Prudential portfolio | 2: Non-trading book");
    entity_member_map.put("Central counterparty client", "Party role type | 26: Centralcounterpartyclient");
    entity_member_map.put("Credit risk mitigation arragement", "Protection arrangement type | 6: Credit risk mitigation arrangement");
    entity_member_map.put("Currency collateral", "Financial collateral type | 77: Currency");
    entity_member_map.put("Current tax liability", "Tax liability type | 710: Current tax liabilities");
    entity_member_map.put("Deferred tax liability", "Tax liability type | 720: Deferred tax liabilities");
    entity_member_map.put("Deposit collateral", "Financial collateral type | 78: Deposit");
    entity_member_map.put("Deposit taking corporation", "Party role type | 27: Deposittakingcorporation");
    entity_member_map.put("Deposit with agreed maturity", "Other deposit type | 522: Deposits with agreed maturity - other than counterpart liability to non-derecognised loans");
    entity_member_map.put("Financial asset", "Asset type | 40: Financial instruments. Creditor");
    entity_member_map.put("Financial guarantee instrument covering a Debt security", "Financial guarantee instrument type | 13: Financial guarantee instrument for a Debt security");
    entity_member_map.put("Financial guarantee instrument not covering a Debt security", "Financial guarantee instrument type | 14: Financial guarantee instrument not for a Debt security");
    entity_member_map.put("Financial guarantee protection item", "Protection item type | 74: Financial guarantee");
    entity_member_map.put("Financial lease", "Loan type | 80: Finance leases");
    entity_member_map.put("Financial liability", "Liability type | 1100: Financial instruments. Debtor");
    entity_member_map.put("Funds for general banking risk", "Provision type | 701: Provisions. Funds for general banking risks");
    entity_member_map.put("Gold collateral", "Commodity collateral type | 13: Gold");
    entity_member_map.put("Goodwill", "Type of non-financial asset | 420: Intangible assets. Goodwill");
    entity_member_map.put("Graded rating system", "Rating system type by nature (Grade vs. Numeric) type | 5: Graded Rating System");
    entity_member_map.put("International organisation or General government", "Organisation type | 24: International organisation or general government");
    entity_member_map.put("Investment property", "Type of non-financial asset | 413: Tangible assets. Investment property");
    entity_member_map.put("Liability", "Balance sheet item type | 749: All liabilities");
    entity_member_map.put("Loan collateral", "Financial collateral type | 16: Loans");
    entity_member_map.put("Machinery and equipment collateral", "Non-registered collateral type | 85: Machinery and equiptment collateral");
    entity_member_map.put("Non-central government rating system", "Issuer based rating system type | 4: Non-Central government rating system");
    entity_member_map.put("Non-financial liabilty", "Liability type | 1302: Non-financial liabilites");
    entity_member_map.put("Off-balance instrument", "Instrument type by product | 948: Off balance sheet instruments"); 
    entity_member_map.put("Original lender", "Party role type | 21: Originallender");
    entity_member_map.put("Other deposit", "Deposit type | 551: Other deposits not part of minimum reserve system (IMF purposes)");
    entity_member_map.put("Other employee benefit", "Employee benefit type | 702: Provisions. Employee benefits. Other than pension and other post-employment defined benefit obligations");
    entity_member_map.put("Other financial collateral", "Financial collateral type | 72: Other financial protection");
    entity_member_map.put("Other intangible asset", "Type of non-financial asset | 430: Intangible assets other than Goodwill");
    entity_member_map.put("Other non-financial asset", "Type of non-financial asset | 1300: Non-financial assets other than Goodwill, Tax asset, Investment property, Other intangible asset or Property, plant and equipment");
    entity_member_map.put("Other non-financial liability", "Type of non-financial liability or provision | 1301: Non-financial liabilites other than Tax liability, Share capital repayable on demand or Provision");
    entity_member_map.put("Other over the counter (OTC) Derivative instrument", "Over the counter (OTC) Derivative instrument type | 5: Other OTC Derivative instrument");
    entity_member_map.put("Other over the counter (OTC) Swap", "OTC Swap type | 8: Other OTC Swap");
    entity_member_map.put("Other provision", "Provision type | 707: Provisions. Other than Employee benefits, Restructuring, Pending legal issues and tax litigation, Off-balance sheet exposures subject to credit risk");
    entity_member_map.put("Other loans", "Loan type | 1022: Other loans");
    entity_member_map.put("Over the counter (OTC) Credit default swap", "OTC Swap type | 7: OTC Credit default swap");
    entity_member_map.put("Over the counter (OTC) Credit spread option", "OTC Option type | 9: OTC Credit spread option");
    entity_member_map.put("Over the counter (OTC) Forward", "Over the counter (OTC) Derivative instrument type | 380: Forward");
    entity_member_map.put("Over the counter (OTC) Option", "Over the counter (OTC) Derivative instrument type | 390: Option");
    entity_member_map.put("Over the counter (OTC) Option other than Over the counter (OTC) Credit spread option", "OTC Option type | 10: OTC Option other than OTC Credit spread option");
    entity_member_map.put("Over the counter (OTC) Swap", "Over the counter (OTC) Derivative instrument type | 370: Swap");
    entity_member_map.put("Over the counter (OTC) Total return swap", "OTC Swap type | 6: OTC Total return swap");
    entity_member_map.put("Pending legal issues and tax litigation", "Provision type | 705: Provisions. Pending legal issues and tax litigation");
    entity_member_map.put("Pension and other post-employment defined benefit obligation", "Employee benefit type | 703: Provisions. Employee benefits. Pension and other post-employment defined benefit obligations");
    entity_member_map.put("Property, plant and equipment", "Type of non-financial asset | 416: Tangible assets. Property, plant and equipment");
    entity_member_map.put("Protection provider", "Party role type | 24: Protectionprovider");
    entity_member_map.put("Rating grade for issuer based rating system for central government", "Rating grade for issuer based rating systems type | 4: Rating grade for issuer based rating systems for Central government");
    entity_member_map.put("Rating grade for issuer based rating system for non-central government", "Rating grade for issuer based rating systems type | 3: Rating grade for issuer based rating systems for non-Central government");
    entity_member_map.put("Reporting agent internal group role", "Group role type | 1: Reporting agent (group)");
    entity_member_map.put("Restructuring", "Provision type | 704: Provisions. Restructuring");
    entity_member_map.put("Security collateral", "Financial collateral type | 12: Securities");
    entity_member_map.put("Suspense item", "Advance type | 130: Suspence items");
    entity_member_map.put("Swap provider", "Party role type | 23: Swapprovider");
    entity_member_map.put("Tax liability", "Type of non-financial liability or provision | 721: Tax liabilities");
    entity_member_map.put("Traditional securitisation", "Securitisation type | 1: Traditional securititsation");
    entity_member_map.put("Transferable deposit", "Overnight deposit type | 511: Tranferable deposit");
    entity_member_map.put("Other overnight deposit", "Overnight deposit type | 512: Other overnight deposits");
    entity_member_map.put("Subsidiary (of the reporting agent)", "Other organisation role type | 30: Subsidiary");
    entity_member_map.put("Joint venture (of the reporting agent)", "Other organisation role type | 31: Joint venture");
    entity_member_map.put("Associate (of the reporting agent)", "Other organisation role type | 32: Associate");
    entity_member_map.put("Trade receivable collateral", "Financial collateral type | 17: Trade receivables");
    entity_member_map.put("Life insurance policy pledged collateral", "Financial collateral type | 2: Life insurance policies pledged");

    
    //app_view.logMessage("No match: " + no_match);
    return entity_member_map
}

function getMatchingDomain(granular_discriminator, leaves_member_list) {
     /*
    Input: Column, HashSet
    Output: Bool
    Description: Goes through all domains and checks if there exists one with matching values (sdd members) from leaves_member_list.
                 If found, assined to granular_discriminator.
                 Returns bool, mathcing domain found or not.
    */
    domains = model.design.getDomainSet().toArray();
    matching_domain_found = false;
    table = granular_discriminator.getTable();
    for (var j=0; j<domains.length; j++) {
        domain = domains[j];
        domain_name = domain.getName();
        list_of_values = domain.getValueList();
        // Check only enumerated domains
        if (list_of_values!=null) {
            domain_member_names = new java.util.HashSet();
            member_map = list_of_values.getValuesDescriptionMap();
            m = member_map.keySet().toArray();
            for (var k=0; k<m.length; k++) {
                member_code = m[k];
                description = member_map.get(member_code);
                member_name = description.split(":")[0];
                member = member_code + ": " + member_name;
                domain_member_names.add(member);
            }
            // Check if this domain has the same members as leaves of the hierarchy
            if (domain_member_names.equals(leaves_member_list)) {
                app_view.logMessage("----- Matching domain found: " + domain_name);
                matching_domain_found = true;
                granular_discriminator.setDomain(domain);
                break;
            }
        }
    }
    table.setDirty(true);
    return matching_domain_found
}


function getUnassignedDomainMemberIndex() {
    /*
    Input: None
    Output: ArrayList
    Description:  Returns a list [domain index, member index] of last unassigned member or domain
    */
    domains = model.design.getDomainSet().toArray();
    domain_index = 0;
    member_index = 0;
    starting_indexes = new java.util.ArrayList();
    for (i=0; i<domains.length; i++) {
        temp_domain = domains[i];
        domain_name = temp_domain.getName();
        if (domain_name.contains("Unassigned")) {
            candidate_index = parseInt(domain_name.split("_")[2]); // List [Unassigned, domain, index]
            if (candidate_index>domain_index) {
                domain_index = candidate_index;
            }
        }
        domain_value_list = temp_domain.getValueList();
        if (domain_value_list) {
            domain_values = domain_value_list.getValues().toArray();
            for (var j=0; j<domain_values.length; j++) {
                value = domain_values[j];
                if (value.contains("Unassigned")) {
                    code_index = parseInt(value.split("_")[1]);
                    if (code_index>member_index) {
                        member_index = code_index;
                    }
                }
            }
        }
    }
    starting_indexes.add(domain_index);
    starting_indexes.add(member_index);
    return starting_indexes;
}


function createDomain(member_list) {
    /*
    Input: HashSet
    Output: Domain
    Description: Creates a Domain named "Unassigned_domain_<number>" in defaultdomains with constraint enumeration from member_list. 
                 If enumerations (sdd members) are newly created they have a value "Unassigned_<number>". 
    */
    new_domain = null;
    starting_indexes = getUnassignedDomainMemberIndex();
    domain_index = starting_indexes[0] + 1;
    domain_member_index = starting_indexes[1] + 1;
    member_list_array = member_list.toArray();
    if (member_list_array.length>0) {
         new_domain = model.design.createDomain();
         domain_name = "Unassigned_domain_" + domain_index;
        new_domain.setName(domain_name);
        app_view.logMessage("--- Created domain " + new_domain.getName());
        constraint_enumeration = new_domain.createConstraintEnumeration();
        for (i=0; i<member_list_array.length; i++) {
            member = member_list_array[i];
            member_code_des = member.split(": "); // member = "code: name: description"
            if (member_code_des.length>1) {
                member_code = member_code_des[0];
                member_name = member_code_des[1];
            } else {
                member_code = "Unassigned_" + domain_member_index;
                member_name = member;
            }
            constraint_enumeration.add(member_code, member_name);
            domain_member_index += 1;
        }
        new_domain.setValueList(constraint_enumeration);
        // Set Logical data type to String
        lt_string = model.design.getLogicalDatatypeSet().getByName("String");
        new_domain.setLogicalDatatype(lt_string);
        new_domain.setDirty(true);
    }
    return new_domain;
}


function getEntityNameEntityMap() {
    /*
    Input: None
    Output: HashMap<String, Entity>
    Description: Map from entity name to entity object
    */
    enitites = model.design.getLogicalDesign().getEntitySet().toArray();
    entityNameEntityMap = new java.util.HashMap();
    for (var i=0; i<enitites.length; i++) {
        entity = enitites[i];
        entity_name = entity.getName();
        entityNameEntityMap.put(entity_name, entity);
    }
    //app_view.logMessage(entityNameEntityMap);
    return entityNameEntityMap    
}


function addNotApplicable(column){
    /* 
    Input: Column
    Output: HashSet
    Description: Returns a set of members of the column, when Not applicable member is added, and empty set when domain should not be changed.
                 Add member Not applicable to a domain of column according to forward egineering strategy.
                 Only for column from subtypes of table's entity: we do not want to include columns which were "wrapped down".
    */
    attr = column.getEngAttribute();
    is_mandatory = true;
    member_names = new java.util.HashSet();
    if (attr) {
        attr_name = attr.getName();
        entity = attr.getEntity();
        is_hier = entity.isHierarchicalEntityType();
        parent = entity.getHierarchicalParent();
        // Typo in the class definition
        is_ignored = entity.getAttributeInherType()=="All atributes";
        relations = entity.getRelations();
        if (relations.length==1) {
            // Optional relationships need to have added member Not applicable for enumerated domains
            is_optional_relation = relations[0].isOptionalSource();
            is_identifying = relations[0].isIdentifying();
            is_one_to_one = relations[0].isOneToOne();
            if (is_optional_relation && is_identifying && is_one_to_one && !is_ignored) {
                is_mandatory = false;
            }
        }
        if (is_hier && !is_ignored) {
            // Go through the hierarchy, on every level check if it is present also in all siblings
            // If it is missing in at least one, we add Not applicable
            while (parent!=null) {
                children = parent.getHierarchicalChildren().toArray();
                for (var i=0; i<children.length; i++) {
                    child = children[i];
                    attr_match = child.getElementByName(attr_name);
                    if (!attr_match) {
                        is_mandatory = false;
                        parent = null;
                        break;
                    }
                }
                if (parent) {
                    parent = parent.getHierarchicalParent();
                }
            }
        }
    }
    return !is_mandatory;
}]]>
		</script>
	</scr>
	<scr id="E44A03A8-114B-6D66-073E-201888051DF1" name="(Helper) Map entites to members" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Map Entities to Members
 *  PURPOSE: Every discriminator Column has a domain, which includes members that represent subtype Enitites.
 *           These members sometimes do not have the same name as the Entity, so we cannot connect entity with a member. 
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: only helper script, creates a map {Entity: domain name | member code: description}
 *  DYNAMIC: Helper script to check if map is correct, does not affect the relation model 
 *  SHORT DESCRIPTION: For every entity, prints out a match member found or a list of possible matches.
*/

// ---- INPUT PARAMETERS ----
script_name = "(Helper) Map Entities to Members";

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

tables = model.getTableSet().toArray();
entites = model.design.getLogicalDesign().getEntitySet().toArray();
entity_member_map = new java.util.HashMap();
no_match = 0;
for (var i=0; i<entites.length; i++) {
    entity = entites[i];
    entity_name = entity.getName();
    is_hier = entity.isHierarchicalEntityType();
    is_root = entity.isHierarchicalRoot();
    // Exclude entities, which are not hierarchial type and roots
    if (is_hier && !is_root) {
        match = false;
        // Find its parent and check if the entity name is present in members list of parent
        parent = entity.getHierarchicalParent();
        parent_attrs = parent.getAttributes();
        discriminators = new java.util.ArrayList();
        members = new java.util.ArrayList();
        for (var j=0; j<parent_attrs.length; j++) {
            attr = parent_attrs[j];
            is_discriminator = attr.getName().contains(" type");
            if (is_discriminator) {
                discriminators.add(attr);
                domain = attr.getDomain();
                domain_name = domain.getName();
                list_of_values = domain.getValueList();
                if (list_of_values) {
                    member_map = list_of_values.getValuesDescriptionMap();
                    m = member_map.keySet().toArray();
                    for (var k=0; k<m.length; k++) {
                        member_code = m[k];
                        description = member_map.get(member_code);
                        member_name = description.split(":")[0];
                        member = domain_name + " | " + member_code + ": " + member_name;
                        if (member_name==entity_name || member_name==entity_name + "s") {
                            entity_member_map.put(entity_name, member);
                            app_view.logMessage("--- Matching member for entity " + entity_name + " found: " + member);
                            match = true;
                            break;
                        }
                        members.add(member);
                    } 
                }   
            }
        }
        if (!match) {
            no_match += 1;
            // No member had a matching name, show members from domain
            app_view.logMessage("--- No matching member for entity " + entity_name + " found.");
            app_view.logMessage("----- Possible matches " + members);
        }
    }
}

// Members, which need to be mapped manually


app_view.logMessage("- Enitiy member map: " + entity_member_map);
app_view.logMessage("- No match: " + no_match);

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="ED606DD2-A828-D650-38AA-264A68187C81" name="(Helper) Add member Not applicable" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Add member Not applicable
 *  PURPOSE: In LDM no domain should have member not applicable, since the model is normalised. 
 *           In IL there are many examples where now member No applicable is needed:
 *           - Wrapping up: enumerated columns, which were present in only some of the subtypes in one level hierarchy
 *           - Merging: enumerated Columns in Tables with optional relationships after merging
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: 
 *  DYNAMIC: Helper script for creating of new Domains, does not affect the relation model 
 *  SHORT DESCRIPTION: Prints out domains of columns which need to be changed
*/

// ---- INPUT PARAMETERS ----
script_name = "(Helper) Add member Not applicable";
app_view = model.getAppView();

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

function addNotApplicable(column){
    attr = column.getEngAttribute();
    is_mandatory = true;
    var member_names = new java.util.HashSet();
    if (attr) {
        attr_name = attr.getName();
        entity = attr.getEntity();
        is_hier = entity.isHierarchicalEntityType();
        parent = entity.getHierarchicalParent();
        is_ignored = entity.getAttributeInherType()=="All atributes";
        if (is_hier && !is_ignored) {
            while (parent!=null) {
                children = parent.getHierarchicalChildren().toArray();
                app_view.logMessage(children);
                for (var i=0; i<children.length; i++) {
                    child = children[i];
                    attr_match = child.getElementByName(attr_name);
                    if (!attr_match) {
                        is_mandatory = false;
                        parent = null;
                        break;
                    }
                }
                if (parent) {
                    parent = parent.getHierarchicalParent();
                }
            }
        }
        
        if (!is_mandatory) {
            domain = column.getDomain();
            list_of_values = domain.getValueList();
            member_map = list_of_values.getValuesDescriptionMap();
            m = member_map.keySet().toArray();
            for (var k=0; k<m.length; k++) {
                member_code = m[k];
                description = member_map.get(member_code);
                // Each member is identified by its code and description
                member_code_desc = member_code + " | " + description;
                member_names.add(member_code_desc);
            }
            member_names.add("0 | Not applicable");
            app_view.logMessage("--- Added not applicable to column " + column.getName());
        }
    }
    return member_names;
}


tables = model.getTableSet();
for (var j=0; j<tables.length; j++) {
	cols = table.getElements();
	app_view.logMessage("- Table " + table.getName() + " considered");
	for (var i=0; i<cols.length; i++) {
	    col = cols[i];
	    vl = col.getDomain().getValueList();
	    app_view.logMessage(col.getName());
	    if (vl) {
	        addNotApplicable(col);
	    }
	}
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="6B2F5150-E811-3055-56C2-518DDBEAF086" name="(Helper) Find disjoint subtyping" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Find disjoint subtyping
 *  PURPOSE: Helper script to check if we included all disjoint subtypes in script Reduce discriminators
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: 
 *  DYNAMIC:  
 *  SHORT DESCRIPTION: Prints out Entites with dissjoint subtyping 
*/

// ---- INPUT PARAMETERS ----
script_name = "Find disjoint subtyping";

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

enitites = model.design.getLogicalDesign().getEntitySet().toArray();
disjoint = new java.util.ArrayList();
for (var i=0; i<enitites.length; i++){
    entity = enitites[i];
    is_hier = entity.isHierarchicalEntityType();
    entity_name = entity.getName();
    if (is_hier) {
        // Find ones with two arcs or one and optional-one-to-one-relationship 
        arcs = entity.getArcs();
        num_of_arcs = arcs.length; // fe adds one joint arc
        if (num_of_arcs > 1) {
        	disjoint.add(entity_name);
        }
    }
}
app_view.logMessage("- " + disjoint.length + "/" + enitites.length + "entities with disjoint subtypes")
app_view.logMessage("- Entities with disjoint subtypes: " + disjoint)

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="B91863B8-0AB9-FE2B-3B95-1AAA4A16D024" name="Order columns alphabetically" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Order columns alphabetically
 *  PURPOSE: 
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run previous to last, before Columns order
 *  DYNAMIC: 
 *  SHORT DESCRIPTION: 
*/

// ---- INPUT PARAMETERS ----
script_name = "Order columns alphabetically";

// ---- SCRIPT ----
app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");
tables = model.getTableSet().toArray();
name_list = new java.util.ArrayList();
log_num_tables_amended = 0;
log_tables_amended = new java.util.ArrayList();
for (var t=0; t<tables.length; t++){
    name_list.clear();
    table = tables[t];
    table_name = table.getName();
    cols = table.getElements();
    // Create list with columns
    for (var i=0; i<cols.length; i++) {
        col = cols[i];
        name_list.add(col);
    }
    name_list.sort(ascending_sort);
    ord_cols = name_list.toArray();
    
    for (var n=0; n<ord_cols.length; n++){
        table.moveToIndex(ord_cols[n],n);
    }
    // Prevent reordering from enginnering, can be changed with UI
    table.setAllowColumnReorder(false);
    log_num_tables_amended += 1;
    log_tables_amended.add(table_name);
    table.setDirty(true);
}

app_view.logMessage("- Tables amended: " + log_tables_amended);
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_num_tables_amended + "/" + tables.length + " tables amended");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");


// ---- FUNCTIONS ----
function ascending_sort(a, b){
    var name_a = a.getName().toLowerCase(); 
    var name_b = b.getName().toLowerCase();
    if (name_a < name_b) {
        return -1;
    }
    if (name_a > name_b) {
        return 1;
    }
    return 0;
}]]>
		</script>
	</scr>
	<scr id="A04CF535-A284-D14C-7184-4F5B9747382E" name="Remove numbers from column names" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Remove numbers from column names
 *  PURPOSE: When we remove duplicated columns, we did not necessearly choose the one without numbers.
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run last
 *  DYNAMIC: 
 *  SHORT DESCRIPTION: 
*/

// ---- INPUT PARAMETERS ----
script_name = "Remove numbers from column names";

// ---- SCRIPT ----
excluded = new java.util.ArrayList(["FNNCL_ASST_INSTRMNT_TYP_CRR_123", "RTL_EXPSR_ACCRDNG_CRR_INDCTR", "ASST_CLSS_CRR_129"]);
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");
log_tables_amended = 0;
log_num_cols_amended = 0;
log_total_cols = 0;

tables = model.getTableSet().toArray();
for (var i=0; i<tables.length; i++) {
    table = tables[i];
    table_name = table.getName();
    cols = table.getElements();
    log_is_amended = false;
    log_columns_amended = new java.util.ArrayList();
    log_total_cols += cols.length;
    for (var j=0; j<cols.length; j++) {
        col = cols[j];
        attr = col.getEngAttribute();
        if (attr != null && !excluded.contains(attr.getPreferredAbbreviation())) {
	        change = removeNumbersfromColumns(col);
	        if (change == true) {
	            log_columns_amended.add(col.getName());
	            log_is_amended = true;
	            log_num_cols_amended += 1;
	        }
        }
    }
    if (log_is_amended) {
        app_view.logMessage("- Table " + table_name + " amended");
        app_view.logMessage("--- " + log_columns_amended.length + "/" + cols.length + " column names changed");
        app_view.logMessage("--- Columns amended: " + log_columns_amended);
        log_tables_amended += 1;
    }
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_tables_amended + "/" + tables.length + " tables amended");
app_view.logMessage("- " + log_num_cols_amended + "/" + log_total_cols + " columns amended");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");


// ---- FUNCTIONS ----
function removeNumbersfromColumns(column) {
    /*
    Input: Column
    Output: Bool
    Description: Removes numbers from column names and returns a boolean whether or not the name was changed.
    */
    table =  column.getTable();
    col_name = column.getName();
    attr = column.getEngAttribute();
    skip = false;
    if (attr) {
        fe_name = attr.getPreferredAbbreviation();
        skip = fe_name.matches(".*\\d.*");
    }
    if (skip==false) {
        new_name = col_name.replaceAll("[0-9]", "");
        column.setName(new_name);
        table.setDirty(true);
    }
    if (col_name != column.getName()) {
        change = true;
    } else {
        change = false;
    }
    return change;
}]]>
		</script>
	</scr>
	<scr id="D7141595-4CFD-02D0-64E8-4D9F53FB70A7" name="Remove duplicated relationships" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Remove duplicated relationships
 *  PURPOSE: when wrapping up, relationships which were defined on subtypes are now moved to the supertype and can be duplicated  
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run after Generalisation
 *  DYNAMIC: EXCLUDED list
 *  SHORT DESCRIPTION: removes duplicated relationships and their associated columns
*/

// TODO: excluded -> check if entity had duplicated relationship, in that case keep the relationship

// ---- INPUT PARAMETERS ----
script_name = "Remove duplicated relationships";

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");
log_num_tables_amended = 0;
log_total_num_fks_removed = 0;
log_total_num_fks = 0;
tables = model.getTableSet().toArray();
// Exclude Entitites, which have duplicated relationships
excluded = new java.util.ArrayList(["FNNCL_ASST_INSTRMNT_RL", 
							 "Financial_asset_instrument_role",
                                    "LNKD_ENTRPRS", 
                                    "Linked_enterprise",
                                    "PRTNR_ENTRPRS",
                                    "Partner_enterprise", 
                                    "JNT_CNTRPRTY_LGL_PRSN_ASSGNMNT",
                                    "Joint_counterparty_Legal_person_assignment", 
                                    "EXCHNG_TRDBL_DRVTV_PSTN",
                                    "Exchange_tradable_derivative_position",
                                    "FNNCL_ASST_INSTRMNT_CLLTRL_RCVD_INSTRMNT_ASSGNMNT",
                                    "Financial_asset_instrument_Collateral_received_instrument_assignment",
                                    "IMMDT_PRNT",
                                    "Immediate_parent",
                                    "Party",
                                    "PRTY"
                                    ]);

for (var t=0; t<tables.length; t++){
    table = tables[t];
    tname = table.getName();
    entity = table.getEngEntity();
    log_is_amended = false;
    log_fks_removed_tables = new java.util.HashSet();
    log_num_fks_removed = 0;
    // Check if table is supposed to have duplicated relationship
    // TODO: Either the entity had duplicated relationship, or it is a relationship between two subtypes
    if (excluded.contains(tname)==false) {
        // Find all foreign keys
        table_relations = table.getFKAssociationsList();
        // Find relationships with same target table
        log_total_num_fks += table_relations.length;
        for (var i=0; i<table_relations.length; i++) {
            rel  = table_relations[i];
            source_table = rel.getRemoteTable();
            for (var j=i+1; j<table_relations.length; j++) {
                rel2 = table_relations[j];
                source_table2 = rel2.getRemoteTable();
                if (source_table.getName()==source_table2.getName()) {
                    cols = rel2.getColumns();
                    // Remove others
                    entity = table.getEngEntity();
                    is_hierarchy = entity.isHierarchicalEntityType();
                    is_root = entity.isHierarchicalRoot();
                    no_pk = entity.isCreateSurrogateKey();
                    log_is_amended = true;
                    log_fks_removed_tables.add(source_table.getName());
                    log_num_fks_removed += 1;
                    if (!is_hierarchy && !is_root && !no_pk) {
                        for (var k=0; k<cols.length; k++) {
                            col = cols[k];
                            col.remove();
                            table.setDirty(true);
                            source_table2.setDirty(true);
                        }
                    }
                    // !! Idea: remove empty foreign keys!!
                    log_total_num_fks_removed += 1;
                    rel2.remove();
                    table.setDirty(true);
                    source_table2.setDirty(true);
                }
            }
            table.setDirty(true);
        }
        if (log_is_amended) {
            log_num_tables_amended += 1;
            app_view.logMessage("- Table " + tname + " amended");
            app_view.logMessage("--- " + log_num_fks_removed + "/" + table_relations.length + " foreign keys removed");
            app_view.logMessage("--- Removed foreign keys with: " + log_fks_removed_tables);
       }
    }
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_num_tables_amended + "/" + tables.length + " tables amended");
app_view.logMessage("- " + log_total_num_fks_removed + "/" + log_total_num_fks + " foreign keys removed");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="165F2732-3843-6FC9-EE4D-F50728F3442E" name="Add DERIVED_ to derived columns" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Add DERIVED_ to derived columns
 *  PURPOSE: Optional script for adding DERIVED_to the code of the column, so that derived data is more explicit.
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run last
 *  DYNAMIC: is_preferred_abbreviation
 *  SHORT DESCRIPTION: 
*/

// ----INPUT PARAMETERS----
var is_preferred_abbreviation = true;
script_name = "Add DERIVED_ to derived columns";

// ----SCRIPT----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");
log_num_tables_amended = 0;
log_total_num_cols_amended = 0;
log_total_num_cols = 0;
var derived_prefix = "DERIVED_";
if (is_preferred_abbreviation==false) {
    derived_prefix = "Derived_";
}
tables = model.getTableSet().toArray();
for (var i=0; i<tables.length; i++) {
    table = tables[i];
    table_name = table.getName();
    cols = table.getElements();
    log_total_num_cols += cols.length;
    log_is_amended = false;
    log_fks_renamed_cols = new java.util.ArrayList();
    for (var j=0; j<cols.length; j++) {
        col = cols[j];
        col_name = col.getName();
        attr = col.getEngAttribute();
        if (attr) {
            entity = attr.getEntity();
            entity_name = entity.getName();
            is_derived = entity_name.contains("derived") || entity_name.contains("Derived");
            if (is_derived) {
                log_is_amended = true;
                log_total_num_cols_amended +=1;
                log_fks_renamed_cols.add(col_name);
                new_col_name = derived_prefix + col_name;
                col.setName(new_col_name);
            }
        }
    }
    if (log_is_amended) {
        log_num_tables_amended += 1;
        app_view.logMessage("- Table " + table_name + " amended");
        app_view.logMessage("--- " + log_fks_renamed_cols.length + "/" + cols.length + " columns renamed");
        app_view.logMessage("--- Renamed columns: " + log_fks_renamed_cols);
    }
    table.setDirty(true);
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_num_tables_amended + "/" + tables.length + " tables amended");
app_view.logMessage("- " + log_total_num_cols_amended + "/" + log_total_num_cols + " columns renamed");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="CCE8E0A7-D9EC-99D6-D7CF-3314126AA25B" name="Merge columns with the same concept" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Merge columns with the same concept
 *  PURPOSE: Some attributes are not actually the same but in the forward engineered model they should be merged into one column.
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run last
 *  DYNAMIC: map of <target column to be merged>: <column to be merged and removed>
 *  SHORT DESCRIPTION: 
*/

var merge_columns = new java.util.HashMap();

// ---- INPUT PARAMETERS ----
script_name = "Merge columns with the same concept";
merge_columns.put("Country code", "Non-reporting member state Country code");


// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

tables = model.getTableSet().toArray();
log_tables_affected = 0;
log_columns_merged = 0;
log_num_columns = 0;
domains = model.design.getDomainSet().toArray(); 
for (var i=0; i<tables.length; i++) {
    table = tables[i];
    table_name = table.getName();
    cols = table.getElements();
    log_num_columns += cols.length;
    for (var j=0; j<cols.length; j++) {
        col = cols[j];
        col_name = col.getName();
        attr = col.getEngAttribute();
        if (attr) {
            attr_name = attr.getName();
            is_merged = merge_columns.get(attr_name);
            if (is_merged) {
                 app_view.logMessage("- Table " + table_name + " amended");
                 log_tables_affected += 1;
                // Go through all other columns
                // If present in map, merge it
                for (var k=0; k<cols.length; k++) {
                    col2 = cols[k];
                    attr2 = col2.getEngAttribute();
                    if (attr2) {
                        attr2_name = attr2.getName();
                        if (is_merged==attr2_name){
                            log_columns_merged += 1;
                            app_view.logMessage("--- Merging column " + col_name + " with " + col2.getName());
                            // Merge columns: remove not primary and amend the domain
                            col_domain = col.getDomain();
                            col_list_of_values = col_domain.getValueList();
                            if (col_list_of_values) {
                                // If enumerated, merge domains, otherwise just delete the second column
                                column_member_names = new java.util.HashSet();
                                getMemberNames(col, column_member_names);
                                getMemberNames(col2, column_member_names);
                                app_view.logMessage("----- New domain allowed values: " + column_member_names);
                                // Check if a domain with these members already exists
                                matching_domain_found = getMatchingDomain(col, column_member_names);
                                // Now we check if we found a matching domain, otherwise it needs to be created
                                if (!matching_domain_found) {
                                    new_domain = createDomain(column_member_names);
                                    col.setDomain(new_domain);
                                    col.setDirty(true);
                                } else {
                                    app_view.logMessage("------- New Domain: " + col.getDomain().getName());
                                }
                            }
                            col2.remove();
                            app_view.logMessage("----- Column " + col2.getName() + " removed");
                            // If column was a foreign key, remove foreign key constraint
                            fks = table.getFKAssociationsList();
                            log_fks_removed = 0;
                            for (var l=0; l<fks.length; l++) {
                                fk = fks[l];
                                fk_cols = fk.getColumns();
                                if (fk_cols.length==0) {
                                    log_fks_removed += 1;
                                    fk.remove();
                                }
                            }
                            app_view.logMessage("------- " + log_fks_removed + "/" + fks.length + " foreign keys removed");
                            table.setDirty(true);
                        }
                    }
                }
            }
        }
    }
    table.setDirty(true);
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_columns_merged + "/" + log_num_columns + " columns amended");
app_view.logMessage("- " + log_tables_affected + "/" + tables.length + " tables affected");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");


// ---- FUNCTIONS ----
function getMemberNames(column, column_member_names) {
    /*
    Input: Column, HashSet
    Output: HashSet
    Description: Extends a set of values with values from column's domain
    */
    domain = column.getDomain();
    column_list_of_values = domain.getValueList();
    column_member_map = column_list_of_values.getValuesDescriptionMap();
    m = column_member_map.keySet().toArray();
    for (var k=0; k<m.length; k++) {
        member_code = m[k];
        description = column_member_map.get(member_code);
        // Each member is identified by its code and description
        member_code_desc = member_code + " | " + description;
        column_member_names.add(member_code_desc);
    }
}


function getMatchingDomain(granular_discriminator, leaves_member_list) {
    /*
    Input: Column, HashSet
    Output: Bool
    Description: Goes through all domains and checks if there exists one with matching values (sdd members) from leaves_member_list.
                 If found, assined to granular_discriminator.
                 Returns bool, mathcing domain found or not.
    */ 
    domains = model.design.getDomainSet().toArray();
    matching_domain_found = false;
    table = granular_discriminator.getTable();
    for (var j=0; j<domains.length; j++) {
        domain = domains[j];
        domain_name = domain.getName();
        if (domain_name.contains("typ") || domain_name.contains("Typ")) {
            list_of_values = domain.getValueList();
            // Check only enumerated domains
            if (list_of_values!=null) {
                domain_member_names = new java.util.HashSet();
                member_map = list_of_values.getValuesDescriptionMap();
                m = member_map.keySet().toArray();
                for (var k=0; k<m.length; k++) {
                    member_code = m[k];
                    description = member_map.get(member_code);
                    member_name = description.split(":")[0];
                    member = member_code + ": " + member_name;
                    domain_member_names.add(member);
                }
                // Check if this domain has the same members as leaves of the hierarchy
                if (domain_member_names.equals(leaves_member_list)) {
                    app_view.logMessage("----- Matching domain found: " + domain_name);
                    matching_domain_found = true;
                    granular_discriminator.setDomain(domain);
                    break;
                }
            }
        }
    }
    table.setDirty(true);
    return matching_domain_found
}


function getUnassignedDomainMemberIndex() {
    /*
    Input: None
    Output: ArrayList
    Description:  Returns a list [domain index, member index] of last unassigned member or domain
    */
    domains = model.design.getDomainSet().toArray();
    domain_index = 0;
    member_index = 0;
    starting_indexes = new java.util.ArrayList();
    for (i=0; i<domains.length; i++) {
        temp_domain = domains[i];
        domain_name = temp_domain.getName();
        if (domain_name.contains("Unassigned")) {
            candidate_index = parseInt(domain_name.split("_")[2]); // List [Unassigned, domain, index]
            if (candidate_index>domain_index) {
                domain_index = candidate_index;
            }
        }
        domain_value_list = temp_domain.getValueList();
        if (domain_value_list) {
            domain_values = domain_value_list.getValues().toArray();
            for (var j=0; j<domain_values.length; j++) {
                value = domain_values[j];
                if (value.contains("Unassigned")) {
                    code_index = parseInt(value.split("_")[1]);
                    if (code_index>member_index) {
                        member_index = code_index;
                    }
                }
            }
        }
    }
    starting_indexes.add(domain_index);
    starting_indexes.add(member_index);
    return starting_indexes;
}


function createDomain(member_list) {
    /*
    Input: HashSet
    Output: Domain
    Description: Creates a Domain named "Unassigned_domain_<number>" in defaultdomains with constraint enumeration from member_list. 
                 If enumerations (sdd members) are newly created they have a value "Unassigned_<number>". 
    */
    new_domain = null;
    starting_indexes = getUnassignedDomainMemberIndex();
    domain_index = starting_indexes[0] + 1;
    domain_member_index = starting_indexes[1] + 1;
    member_list_array = member_list.toArray();
    if (member_list_array.length>0) {
         new_domain = model.design.createDomain();
         domain_name = "Unassigned_domain_" + domain_index;
        new_domain.setName(domain_name);
        app_view.logMessage("--- Created domain " + new_domain.getName());
        constraint_enumeration = new_domain.createConstraintEnumeration();
        for (i=0; i<member_list_array.length; i++) {
            member = member_list_array[i];
            member_code_des = member.split(" | "); // member = "code | name: description"
            if (member_code_des.length>1) {
                member_code = member_code_des[0];
                member_name = member_code_des[1];
            } else {
                member_code = "Unassigned_" + domain_member_index;
                member_name = member;
            }
            constraint_enumeration.add(member_code, member_name);
            domain_member_index += 1;
        }
        new_domain.setValueList(constraint_enumeration);
        // Set Logical data type to String
        lt_string = model.design.getLogicalDatatypeSet().getByName("String");
        new_domain.setLogicalDatatype(lt_string);
        new_domain.setDirty(true);
    }
    return new_domain;
}]]>
		</script>
	</scr>
	<scr id="524501ED-42C6-A893-2611-F34505BAC5AF" name="Test settings on entities" object="logical" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Test settings on entities
 *  PURPOSE: Settings that should be checked:
 *  				Create surrogate pk
 *  				attribute: default and constraint: use domain constraint = true
 *  				relationship: delete rule = no action
 *  OBJECT: applied on logical model
 *  REQUIREMENTS: 
 *  DYNAMIC: 
 *  SHORT DESCRIPTION: 
*/


// ---- INPUT PARAMETERS ----
script_name = "Test settings on entities";
create_surrogate_key = new java.util.ArrayList([
                       "Abstract employee role",
                       "Building Abstract employee role assignment",
                       "Office material"
]);
// check all other so that they have primary attributes only
all_attributes_inheritance = new java.util.ArrayList([
                       "Product",
                       "Book"
]);

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");
log_num_entities_incorrect = 0;
log_num_attributes_incorrect = 0;
// check all entities
entities = model.getEntitySet().toArray();
for (var i=0; i<entities.length; i++) {
	entity = entities[i];
	entity_name = entity.getName();
	is_create_sur_key = entity.isCreateSurrogateKey();
	if (is_create_sur_key && !create_surrogate_key.contains(entity_name)) {
		log_num_entities_incorrect += 1;
		app_view.logMessage("- Entity " + entity_name + " has incorrect setting");
		app_view.logMessage("--- Has create surrogate key = true, should be false");
	}
	if (!is_create_sur_key && create_surrogate_key.contains(entity_name)) {
		log_num_entities_incorrect += 1;
		app_view.logMessage("- Entity " + entity_name + " has incorrect setting");
		app_view.logMessage("--- Has create surrogate key = false, should be true");
	}
	is_all_attributes_inheritance = entity.getAttributeInherType()=="All atributes";
	if (is_all_attributes_inheritance && !all_attributes_inheritance.contains(entity_name)) {
		log_num_entities_incorrect += 1;
		app_view.logMessage("- Entity " + entity_name + " has incorrect setting");
		app_view.logMessage("--- Has create attributes inheritance = All attributes, should be Primary attributes only ");
	}
	if (!is_all_attributes_inheritance && all_attributes_inheritance.contains(entity_name)) {
		log_num_entities_incorrect += 1;
		app_view.logMessage("- Entity " + entity_name + " has incorrect setting");
		app_view.logMessage("--- Has create attributes inheritance = Primary attributes only, should be All attributes");
	}
	attributes = entity.getAttributes();
	relationships = entity.getRelations();
	for (var j=0; j<attributes.length; j++) {
		attribute = attributes[j];
		attribute_name = attribute.getName();
		is_use_domain_constraint = attribute.getUseDomainConstraints(); // needs to be true for every attribute
		if (!is_use_domain_constraint) {
			log_num_entities_incorrect += 1;
			log_num_attributes_incorrect += 1;
			app_view.logMessage("- Entity " + entity_name + " has incorrect setting of attributes");
			app_view.logMessage("--- Attribute " + attribute_name + " has incorrect setting");
			app_view.logMessage("----- Has Use domain constraint = false, should be true");
		}
	}
	for (var j=0; j<relationships.length; j++) {
		relationship = relationships[j];
		is_no_action_delete_rule = relationship.getDeleteRule()=="NO ACTION";
		if (!is_no_action_delete_rule) {
			source = relationship.getSourceEntity();
			log_num_entities_incorrect += 1;
			app_view.logMessage("- Entity " + entity_name + " has incorrect setting");
		app_view.logMessage("--- Has relationship with " + source + " not set to NO ACTION");
		}
	}
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_num_entities_incorrect + " wrong settings");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="43EDE71F-CB19-43A2-35AD-50D0278989F2" name="Amend settings on entities" object="logical" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME: Amend settings on entities
 *  PURPOSE: Settings that should be checked:
 *  				Create surrogate pk
 *  				attribute: default and constraint: use domain constraint = true
 *  				relationship: delete rule = no action
 *  OBJECT: applied on logical model
 *  REQUIREMENTS: 
 *  DYNAMIC: 
 *  SHORT DESCRIPTION: 
*/


// ---- INPUT PARAMETERS ----
script_name = "Amend settings on entities";
create_surrogate_key = new java.util.ArrayList([
                       "Abstract employee role",
                       "Building Abstract employee role assignment",
                       "Office material"
]);
// check all other so that they have primary attributes only
all_attributes_inheritance = new java.util.ArrayList([
                       "Product",
                       "Book"
]);

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");
log_num_entities_incorrect = 0;
log_num_attributes_incorrect = 0;
// check all entities
entities = model.getEntitySet().toArray();
for (var i=0; i<entities.length; i++) {
	log_is_amended = false;
	entity = entities[i];
	entity_name = entity.getName();
	is_create_sur_key = entity.isCreateSurrogateKey();
	if (is_create_sur_key && !create_surrogate_key.contains(entity_name)) {
		log_num_entities_incorrect += 1;
		log_is_amended = true;
		entity.setCreateSurrogateKey(false);
		entity.setDirty(true);
		app_view.logMessage("- Entity " + entity_name + " amended");
		app_view.logMessage("--- Create surrogate key = false");
	}
	if (!is_create_sur_key && create_surrogate_key.contains(entity_name)) {
		log_num_entities_incorrect += 1;
		log_is_amended = true;
		entity.setCreateSurrogateKey(true);
		entity.setDirty(true);
		app_view.logMessage("- Entity " + entity_name + " amended");
		app_view.logMessage("--- Create surrogate key = true");
	}
	is_all_attributes_inheritance = entity.getAttributeInherType()=="All atributes";
	if (is_all_attributes_inheritance && !all_attributes_inheritance.contains(entity_name)) {
		log_num_entities_incorrect += 1;
		log_is_amended = true;
		entity.setAttributeInherType("Primary attributes only");
		entity.setDirty(true);
		app_view.logMessage("- Entity " + entity_name + " amended");
		app_view.logMessage("--- Create attributes inheritance = Primary attributes only");
	}
	if (!is_all_attributes_inheritance && all_attributes_inheritance.contains(entity_name)) {
		log_num_entities_incorrect += 1;
		log_is_amended = true;
		entity.setAttributeInherType("All atributes");
		entity.setDirty(true);
		app_view.logMessage("- Entity " + entity_name + " amended");
		app_view.logMessage("--- Create attributes inheritance = All attributes");
	}
	attributes = entity.getAttributes();
	relationships = entity.getRelations();
	for (var j=0; j<attributes.length; j++) {
		attribute = attributes[j];
		attribute_name = attribute.getName();
		is_use_domain_constraint = attribute.getUseDomainConstraints(); // needs to be true for every attribute
		if (!is_use_domain_constraint) {
			log_num_entities_incorrect += 1;
			log_num_attributes_incorrect += 1;
			log_is_amended = true;
			attribute.setUseDomainConstraints(true);
			entity.setDirty(true);
			app_view.logMessage("- Entity " + entity_name + " amended");
			app_view.logMessage("--- Attribute " + attribute_name + " amended");
			app_view.logMessage("----- Use domain constraint = true");
		}
	}
	for (var j=0; j<relationships.length; j++) {
		relationship = relationships[j];
		is_no_action_delete_rule = relationship.getDeleteRule()=="NO ACTION";
		if (!is_no_action_delete_rule) {
			source = relationship.getSourceEntity();
			log_num_attributes_incorrect += 1;
			log_is_amended = true;
			relationship.getDeleteRule("NO ACTION");
			entity.setDirty(true);
			app_view.logMessage("- Entity " + entity_name + " has incorrect setting");
			app_view.logMessage("--- Has relationship with " + source + " not set to NO ACTION");
		}
	}
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_num_entities_incorrect + " settings amended");
app_view.logMessage("- " + log_num_attributes_incorrect + " settings on attributes amended");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="9D3ADD5D-1408-0957-F7A0-DEBCB96128BE" name="Replace foreign key on folded columns" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME: Replace foreign key on folded columns
 *  PURPOSE: All main Entities from each of the classification types are related to the Context Entity. 
 *           In case of assignments between Entities from different classification types, we get two columns from the Context Entity (Party Refernce date and Instrument reference date).
 *           These two should be merged into one and this is the reason we use feature of folding the overlapping attributes, meaning after forward engineering into a relational model,
 *           We end up with only one column (either Party Refernce date or Instrument reference date).
 *           When we change foreign key index in Entity role and Abstract instrument role script, we do not take into account that some columns are not existing anymore, because they were folded.
 *           This script amends the foreign key constraint to replace the missing columns with the columns we folded in. 
 *  OBJECT: applied on relational data model
 *  REQUIREMENTS: run after Generalisation
 *  DYNAMIC: 
 *  SHORT DESCRIPTION: Goes through the tables and checks if all foreign key constraints are complete.
 *                     If not, finds attributes which were folded and puts the respective columns into the foreign key index.
 *                     Changes the name of the column to reflet the originating attribute.
*/

// ---- INPUT PARAMETERS ----
script_name = "Replace foreign key on folded columns";
is_preferred_abbreviation = false;

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");
log_tables_affected = 0;
log_fks_amended = 0;
log_connected_cols = new java.util.ArrayList();

tables = model.getTableSet().toArray();
for (var t=0; t<tables.length; t++) {
    table = tables[t];
    table_name = table.getName();
    ent = table.getEngEntity();
    app_view.logMessage("- Analyzing entity hierarchy " + ent.getName());
    log_table_is_affected = false;
    fks = table.getFKAssociationsList();
    columns = table.getElements();
    // Find all overlapping attributes of the entitie's hierarchy
    folded_attrs_list = getOverlappingAttributesOfHierarchy(ent);
    attributes_to_replace = folded_attrs_list[0];
    attr_fold_map = folded_attrs_list[1];
    for (var i=0; i<fks.length; i++) {
        fk = fks[i];
        fk_cols = fk.getColumns();
        ref_index = fk.getRemoteIndex();
        ref_table_cols = ref_index.getColumns();
        // Check if foreign key constraint is not complete anymore (because of overlapping attributes)
        if (fk_cols.length != ref_table_cols.length) {
            fake_index = table.createIndex();
            app_view.logMessage("- Table " + table_name + " amended");
            app_view.logMessage("--- Foreign key constraint is not complete");        
            log_fks_amended += 1;
            log_table_is_affected = true;
            // Here we need to find the target attribute into which we fold another attribute 
            // Find overlapping attributes of this table's entity
            
            app_view.logMessage("----- Folded originating attributes: " + attributes_to_replace);
            // Go over referenced columns to find which are to be replaced
            for (var j=0; j<ref_table_cols.length; j++) {
                ref_col = ref_table_cols[j];
                ref_col_name = ref_col.getName();
                ref_col_attr = ref_col.getEngAttribute();
                ref_col_orign_attr = ref_col_attr.getOriginatingAttribute();
                compatible_cols = fk.getCompatibleColumns(ref_col);
                // If it is not a foreign key attribute, it is not overlapping
                if (ref_col_orign_attr != null) {
                    ref_col_orign_attr_name = ref_col_orign_attr.getName();
                    if (attributes_to_replace.contains(ref_col_orign_attr_name)) {
                        app_view.logMessage("----- Folded column name: " + ref_col_name);
                        // From compatible columns we need to select the one that has the same originating attribute
                        for (var k=0; k<compatible_cols.length; k++) {
                            compatible_col = compatible_cols[k];
                            comp_attr = compatible_col.getEngAttribute();
                            if (comp_attr != null) {
                            	   orig_comp_attr = comp_attr.getOriginatingAttribute();
                            	   if (orig_comp_attr) {
	                                if (attr_fold_map.get(ref_col_orign_attr_name) == orig_comp_attr.getName()) {
	                                    app_view.logMessage("------- Folded into: " + compatible_col);
	                                    fake_index.add(compatible_col);
	                                    log_connected_cols.add(compatible_col.getName());
	                                    break;
	                                }
	                            }
                            }
                        }
                    } else {
                    	ref_col_name_repl = ref_col_name.replaceAll("[0-9]", "");
	                    for (var k=0; k<compatible_cols.length; k++) {
	                       compatible_col = compatible_cols[k];
	                       compatible_col_name_repl = compatible_col.getName().replaceAll("[0-9]", "");
	                       if (ref_col_name_repl.contains(compatible_col_name_repl) || compatible_col_name_repl.contains(ref_col_name_repl) || ((ref_col_name_repl.contains("RL_TYP") || ref_col_name_repl.contains("role_type")) && (compatible_col_name_repl.contains("RL_TYP") || compatible_col_name_repl.contains("role_type")))) {
	                          fake_index.add(compatible_col);
	                          log_connected_cols.add(ref_col_name);
	                          break;
	                      }
	                   }
                    }
                } else {
                	ref_col_name_repl = ref_col_name.replaceAll("[0-9]", "");
                    for (var k=0; k<compatible_cols.length; k++) {
                       compatible_col = compatible_cols[k];
                       compatible_col_name_repl = compatible_col.getName().replaceAll("[0-9]", "");
                       if (ref_col_name_repl.contains(compatible_col_name_repl) || compatible_col_name_repl.contains(ref_col_name_repl) || ((ref_col_name_repl.contains("RL_TYP") || ref_col_name_repl.contains("role_type")) && (compatible_col_name_repl.contains("RL_TYP") || compatible_col_name_repl.contains("role_type")))) {
                          fake_index.add(compatible_col);
                          log_connected_cols.add(ref_col_name);
                          break;
                      }
                   }
                }
            }
            fake_index_cols = fake_index.getColumns();
            fake_index.remove();
            fk.changeKeyObject(ref_index, fake_index_cols);
            app_view.logMessage("----- New foreign key: " + fake_index_cols + " on " + log_connected_cols);
        }
        table.setDirty(true);
    }
    if (log_table_is_affected) {
        log_tables_affected += 1;
    }
    // Rename columns into originating column names 
    for (var i=0; i<columns.length; i++) {
        column = columns[i];
        attr = column.getEngAttribute();
        if (attr != null) {
        	   attr_orig = attr.getOriginatingAttribute();
        	   if (attr_orig != null) {
        	   	  attr_orig_name = attr_orig.getName();
	            col_orign_name = getFEName(attr_orig, is_preferred_abbreviation);
	             // Check if column was an overlapping attribute
	            if (attributes_to_replace.contains(attr_orig_name)) {
	                column.setName(col_orign_name);
	                app_view.logMessage("Renaming column " + attr_orig_name + " into " + col_orign_name);
	            }
	        }
        }
    }
    table.setDirty(true);
}

// FUNCTIONS
function getHierarchicalTree(entity) {
	leaves = entity.getHierarchicalLeaves();
	hierarchy_tree = new java.util.HashSet();
	hierarchy_tree.add(entity);
	if (entity.isHierarchicalEntityType()) {
		for (var i=0; i<leaves.length; i++) {
			leaf = leaves[i];
			hierarchy_tree.add(leaf);
			parent = leaf.getHierarchicalParent();
			is_downwrapped = parent.getAttributeInherType()=='All atributes';
			// Igore the ones that are downwrapped
			if (!is_downwrapped) {
				while (parent.getName() != entity.getName()) {
					hierarchy_tree.add(parent);
					parent = parent.getHierarchicalParent();
				}
			}
		}
	}
	return hierarchy_tree;
}

function getOverlappingAttributesOfHierarchy(entity) {
    hierarchy_tree = getHierarchicalTree(entity).toArray();
    attributes_to_replace = new java.util.ArrayList();
    attr_fold_map = new java.util.HashMap();
    for (var i=0; i<hierarchy_tree.length; i++) {
    	    ent1 = hierarchy_tree[i];
    	    folded_attrs = ent1.getFoldedAttributesMap();
	    keys = folded_attrs.keySet().toArray();
	    for (var j=0; j<keys.length; j++) {
		    attr1_id = keys[j];
		    attr2_id = folded_attrs.get(attr1_id);
		    attr1 = ent1.getElementByID(attr1_id);
		    orig_attr1 = attr1.getOriginatingAttribute();
		    attr2 = ent1.getElementByID(attr2_id);
		    orig_attr2 = attr2.getOriginatingAttribute();
		    attributes_to_replace.add(orig_attr1.getName());
		    attr_fold_map.put(orig_attr2.getName(), orig_attr1.getName());
	    }
    }
    return [attributes_to_replace, attr_fold_map]
}

function getFEName(attribute, is_preferred_abbreviation) {
    /*
    Input: Attribute, Bool
    Output: String
    Description: Returns preffered abbreviation of attribute in case of using preferred abbreviation for fe, 
                 othervise returns attribute names with underscores instead of spaces.
    */
    if (is_preferred_abbreviation==true) {
        fe_name = attribute.getPreferredAbbreviation();
    } else {
        attr_name = attribute.getName();
        fe_name = attr_name.replaceAll(" ", "_"); 
    }
    return fe_name
}


app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_fks_amended + " foreign keys amended");
app_view.logMessage("- " + log_tables_affected + "/" + tables.length + " tables affected");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="E5ACE1E2-133A-97AB-360E-646EAD3291F0" name="Test: compare mappings" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME: Test: compare mappings
 *  PURPOSE: Integration test for testing mapping information between two relational models.
 *  OBJECT: applied on relational data model
 *  REQUIREMENTS: 
 *  DYNAMIC: 
 *  SHORT DESCRIPTION: 
*/
// Last part of integration test, where we compare mapping information between columns and entities
// ---- INPUT PARAMETERS ----
script_name = "Test: compare mappings";
compare_model_name = "Name of relational model base";

// SETUP
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

rel_model = model;
rel_model2 = model.design.getRelationalDesigns().getByName(compare_model_name);
// Build generated mapping hashmap
created_extended_map = rel_model.getRMExtendedMap().getContainerMappings();
created_map = new java.util.HashMap();
for (var i=0; i<created_extended_map.length; i++) {
	c = created_extended_map[i].getContainedMappings();
	for (var k=0; k<c.length; k++) {
		cm = c[k];
		//app_view.logMessage(cm.getXtdMapping().getTargetID());
		owner_id = cm.getXtdMapping().getOwnerID();
		target_id = cm.getXtdMapping().getTargetID();
		created_map.put([owner_id, target_id], []);
	}
}
// Build the base mapping hashmap
base_extended_map = rel_model2.getRMExtendedMap().getContainerMappings();
base_map = new java.util.HashMap();
for (var i=0; i<base_extended_map.length; i++) {
	c = base_extended_map[i].getContainedMappings();
	for (var k=0; k<c.length; k++) {
		cm = c[k];
		//app_view.logMessage(cm.getXtdMapping().getTargetID());
		owner_id = cm.getXtdMapping().getOwnerID();
		target_id = cm.getXtdMapping().getTargetID();
		base_map.put([owner_id, target_id], []);
	}
}

// TEST
app_view.logMessage("Comparing mappings between base relational model " + compare_model_name + " and " + rel_model.getName() + "...");
if (base_map == created_map) {
	app_view.logMessage("--- Test passed");
} else {
    base_keys = base_map.keySet().toArray();
    app_view.logMessage("--- Test failed");
    for (var i = 0; i < base_map.size(); i++) {
        map = base_keys[i];
        contained_in_created = created_map.containsKey(map);
        if (contained_in_created == false) {
        	   app_view.logMessage("----- Missing mappings in created model: ");
        	   app_view.logMessage(map);
        }
    }
    compare_keys = created_map.keySet().toArray();
    for (var i = 0; i < created_map.size(); i++) {
        map = compare_keys[i];
        contained_in_base = base_map.containsKey(base_map);
        if (contained_in_base == false) {
        	   app_view.logMessage("----- Additional mappings in created model: ");
        	   app_view.logMessage(map);
        }
    }
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="79608FB8-BB97-9642-E3E1-FDEAB8AE03D0" name="Subtree generation" object="logical" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME: Subtree generation
 *  PURPOSE: Forward engineering is a process of denormalisation of LDM. In every hierarchy, we usually want only one remaining 
 *           Table after FE.
 *  OBJECT: applied on logical data model
 *  REQUIREMENTS: run first
 *  DYNAMIC: - Change name of relational model for your purpose [rel_model_name]
 *           - If Entity's name is changed, it needs to be changed in the list
 *  SHORT DESCRIPTION: Select supertypes, into which all subtypes are wrapped in
*/

// ---- INPUT PARAMETERS ----
script_name = "Subtree generation";
rel_model_name = "Relational_3";

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

rel_model = model.design.getRelationalDesigns().getByName(rel_model_name);
id = rel_model.getObjectID();
entities = model.getEntitySet().toArray();

// List of all entities in hierarchiers, which we want to keep in relational model
include = new java.util.ArrayList([
 // Party related
 'Country',
 'Party',
 'Entity role',
 // Rating system related
 'Rating system',
 'Rating grade',
 // Group related
 'Group',
 'Internal group role',
 // Assignments
 'Instrument Entity role assignment',
 'Credit facility Entity role assignment',
 'Security Entity role assignment',
 'Security position',
 'Long security position Prudential portfolio assignment',
 'Long security position Prudential Portfolio assignment Accounting classification for financial assets assignment',
 'Long debt security position Prudential portfolio assignment encumbrance data',
 'Long equity or fund security position Prudential portfolio assignment encumbrance data',
 'Long security position Prudential portfolio assignment risk data',
 'Prudential portolio',
 'Prudential portfolio',
 'Accounting classification',
 'Master agreement Entity role assignment',
 'Exchange tradable derivative position', 
 'Exchange tradable derivative position role',
 'Subsidiary, joint venture and associate Other organisation role assignment',
 // Instrument related
 'Instrument',
 'Repurchase agreement component',
 'Security borrowing and lending transaction including cash as collateral component',
 'Security Security repurchase agreement component assignment',
 // uncomment if verison wo role concept
 //'Over the counter (OTC) Derivative role',
 'Master agreement',
 'Protection arrangement',
 'Collateral',
 'Security and exchange tradable derivative',
 'Asset pool (subject to a Securitisation and other credit transfer)',
 // Securitisation
 'Covered bond program',
 'Traditional securitisation', 
 'Synthetic securitisation',
 'Credit transfer other than securitisation and covered bond program',
 'Tranche in a synthetic securitisation without SSPE',
 // BSI
 'Non-financial asset',
 'Cash on hand',
 'Financial asset in the form of a debt security position',
 'Financial asset in the form of an equity or fund security position',
 'Financial asset in the form of an instrument',
 'Financial asset in the form of an instrument or security position',
 // Disjoint subtypes 
 'Financial asset according to International Financial Reporting Standard (IFRS)',
 'Financial asset according to national general accepted accounting principles (nGAAP)',
 'Non-financial liability',
 'Financial liability in the form of a debt security issued','Financial liability in the form of an instrument',
 'Off-balance sheet item given in the form of an Off-balance sheet instrument',
 'Off-balance sheet item given in the form of a Credit facility',
 'Off-balance sheet item received in the form of an instrument',
 'Off-balance sheet item received in the form of a credit facility',

 // Credit facility related
 'Credit facility role',

 // Additonal from second option draft 
 'Abstract instrument role', 
 'Financial asset instrument Collateral received instrument assignment',
 'Financial asset instrument role',
 'Financial liability instrument role',
 'Instrument hedged by Over the counter (OTC) Derivative',

 // Additional master types
 'Default status',
 'Forbearance measure',
 'Model Context',
 'Accounting classification',
 'Subordinated debt type',

 // Address
 'Postal code',
 'Address (used for reporting)',
 'Financial contract'
   
 ]);

total_entities = entities.length;
enities_affected = new java.util.ArrayList();
for (var i=0; i<entities.length; i++) {
    entity = entities[i];
    e_name = entity.getName();
    // Include entity in fe only if it is in INCLUDE list and it is a hierarchical type
    is_hier = entity.isHierarchicalEntityType();
    if (is_hier) {
        if (include.contains(e_name)==false) {
            entity.setEngineerTo(id, false);
            entity.setDirty(true);
            enities_affected.add(e_name);
        }
    }
}
num_enities_affected = enities_affected.length;
app_view.logMessage("- Entities not forward engineered: " + enities_affected);
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + num_enities_affected + "/" + total_entities + " entites affected (not forward engineered)");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="8FD84EC4-BA33-E507-E4C7-0FC7B3E2C3CA" name="Amend columns domain and remove duplicated columns" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Amend columns domain and remove duplicated columns
 *  PURPOSE: When we wrap up, there is duplication of columns when the same attribute in present in two or more subtypes.
 *           In this case, we need to remove duplicated columns and amend its domain:
 *           - it should be a union of members of these columns
 *           - it should contain member Not applicable if column was not present in all subtypes on one level of hierarchy
 *          Even when column is not duplicated its domain should be extended with member Not applicable in described case.
 *  OBJECT: Applied on relational model
 *  REQUIREMENTS: - Run before merging bsi assignments in case of IL draft 1, 
 *                - Role concept LDM: run after reduce discriminators 
 *  DYNAMIC: 
 *  SHORT DESCRIPTION: Checks every table for duplicated columns and removes them if they don't have a primary or foreign key constraint.
 *                     Uniqueness constraint is changed, if a duplicated column is part of this constraint.
 *                     Adds member Not applicable with defined function.
 *                     If a domain of a foreign key column is supposed to be amended, domain of source column is amended.
 *  
*/

// ---- INPUT PARAMETERS ----
script_name = "Amend columns domain and remove duplicated columns";

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

rel_model = model;
tables = model.getTableSet().toArray();
log_tables_affected = 0;
log_total_num_cols_affected = 0;
log_num_cols = 0;
for (var t=0; t<tables.length; t++){
    log_table_affected = false;
    table = tables[t];
    table_name = table.getName();
    app_view.logMessage("- Table " + table_name + " amended");
    columns = table.getElements();
    indexes = table.getKeys();
    log_num_cols += columns.length;
    cols_removed = new java.util.ArrayList();
    for (var i=0; i<columns.length; i++) {
        log_col_amended = false;
        log_merged_with = new java.util.ArrayList();
        column = columns[i];
        column_name = column.getName();
        attr =  column.getEngAttribute();
        is_pk = column.isPKElement();
        is_fk = column.isFKColumn();
        is_discriminator = column_name.contains("_TYP") || column_name.contains("_type");
        if (attr!=null && !is_discriminator && !cols_removed.contains(column_name)) {
            attr_name = attr.getName();
            if (attr.isFKAttribute()) {
                attr_name = attr.getOriginatingAttribute().getName();
            }
            column_domain = column.getDomain();
            column_domain_name = column_domain.getName();
            column_list_of_values = column_domain.getValueList();
            if (column_list_of_values) {
                not_applicable = true;
                // Amend the domain for enumerated columns
                column_member_names = addNotApplicable(column);
                // Create a list of members if not created through function
                app_view.logMessage("--- Column " + column_name + " considered");
                if (column_member_names.isEmpty()) {
                    not_applicable = false;
                    column_member_map = column_list_of_values.getValuesDescriptionMap();
                    m = column_member_map.keySet().toArray();
                    column_member_names = new java.util.HashSet();
                    for (var k=0; k<m.length; k++) {
                        member_code = m[k];
                        description = column_member_map.get(member_code);
                        // Each member is identified by its code and description
                        member_code_desc = member_code + ": " + description;
                        column_member_names.add(member_code_desc);
                    }
                } else {
                    app_view.logMessage("----- Added Not applicable");
                    log_col_amended = true;
                    log_table_affected = true;
                }
            }
            duplicates = false; 
            // Go through left columns to find the duplicates
            for (var j=i+1; j<columns.length; j++){
                col = columns[j];
                attr2 =  col.getEngAttribute();
                if (attr2!=null) {
                    attr2_name = attr2.getName();
                    // If attribute is a foreign key, find name of originating attribute
                    if (attr2.isFKAttribute()) {
                        attr2_name = attr2.getOriginatingAttribute().getName();
                    }
                    // Remove column if columns had the same attribute name or
                    // attribute was a foreign key and column is not and origination attribute is already present in the table
                    if (attr2_name==attr_name && col.isFKColumn()==false && col.isPKElement()==false){
                        duplicates = true;
                        log_merged_with.add(col.getName());
                        // Before removal, change unique constraint
                        for (var k = 0; k < indexes.length; k++) {
                            index = indexes[k];
                            if (index.isUnique()) {
                                is_in = index.getElementByName(col.getName());
                                if (is_in) {
                                    index.remove(col);
                                    index.add(column);
                                    app_view.logMessage("----- Amended constraints on column from " + col.getName() + "  to " + column_name);
                                    table.setDirty(true);                  
                                }
                            }
                        }
                        if (column_list_of_values) {
                            // Expand column's domain's value list with members from col 
                            col_domain = col.getDomain();
                            col_domain_name = col_domain.getName();
                            col_list_of_values = col_domain.getValueList();
                            col_member_map = col_list_of_values.getValuesDescriptionMap();
                            m = col_member_map.keySet().toArray();
                            for (var k=0; k<m.length; k++) {
                                member_code = m[k];
                                description = col_member_map.get(member_code);
                                member_code_desc = member_code + ": " + description;
                                column_member_names.add(member_code_desc);
                            }
                        }
                        app_view.logMessage("-----  Column " + col.getName() + " removed (values from domain added to " + column_name + ")");
                        log_table_affected = true;
                        cols_removed.add(col.getName());
                        log_total_num_cols_affected +=1;
                        app_view.logMessage("Trying to create map from " + attr2.getName());
                        rel_model.getRMExtendedMap().createMapping(attr2, column);
			         app_view.logMessage("------- Created mapping from attribute " + attr2.getName() + " to column " + column.getName());
                        col.remove();
                        col.setDirty(true);
                        column.setDirty(true);
                        table.setDirty(true);
                    }
                }
            }
            table.setDirty(true);
            // Now that all columns are removed and domain member list expanded with it's members,
            // we can go through all domains and do a comparison with existing domains
            // Check if a domain with these members exists
            domains = model.design.getDomainSet().toArray();
            if (column_list_of_values && (duplicates || not_applicable)) {
                log_total_num_cols_affected +=1;
                matching_domain_found = false;
                log_table_affected = true;
                for (var j=0; j<domains.length; j++) {
                    domain = domains[j];
                    domain_name = domain.getName();
                    list_of_values = domain.getValueList();
                    // Check only enumerated ones
                    if (list_of_values!=null) {
                        members_map = list_of_values.getValuesDescriptionMap(); 
                        m = members_map.keySet().toArray();
                        domain_member_names = new java.util.HashSet();
                        for (var k=0; k<m.length; k++) {
                            member_code = m[k];
                            if (member_code==0) {
                                description = "Not applicable"; 
                            } else {
                                description = members_map.get(member_code);
                            }
                            member_code_desc = member_code + ": " + description;
                            domain_member_names.add(member_code_desc);
                        }
                        // Check if this domain has the same members as expected domain
                        if (domain_member_names.equals(column_member_names)) {
                            matching_domain_found = true;
                            if (is_fk) {
                                   // If columns is a foreign key, we cannot change its domain
                                  // In this case, we should change the domain of originating column
                                   originating_col = column.getReferencedColumn();
                                   originating_col.setDomain(domain);
                            } else {
                                   column.setDomain(domain);
                            }
                            break;
                        }
                    }
                }
                app_view.logMessage("----- Match for Domain: " + matching_domain_found);
                if (is_fk) {
                    originating_col = column.getReferencedColumn();
                    app_view.logMessage("------- Column is a foreign key. Domain of originating column " + originating_col.getName() + " changed instead.");
                }
                // Now we check if we found a matching domain, otherwise it needs to be created
                if (!matching_domain_found) {
                    new_domain = createDomain(column_member_names);
                     if (is_fk) {
                        originating_col = column.getReferencedColumn();
                        originating_col.setDomain(new_domain);
                        originating_col.setDirty(true);
                   } else {
                        column.setDomain(new_domain);
                        column.setDirty(true);
                   }
                    app_view.logMessage("------- New domain list of values: " + column_member_names);
                } else {
                    app_view.logMessage("------- New Domain: " + domain_name);
                }
            }
        }
        table.setDirty(true); 
    }
    if (log_table_affected) {
        log_tables_affected += 1;
    }
}
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_total_num_cols_affected + "/" + log_num_cols + " columns amended");
app_view.logMessage("- " + log_tables_affected + "/" + tables.length + " tables affected");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");


// ---- FUNCTIONS ----
function addNotApplicable(column){
    /* 
    Input: Column
    Output: HashSet
    Description: Returns a set of members of the column, when Not applicable member is added, and empty set when domain should not be changed.
                 Add member Not applicable to a domain of column according to forward egineering strategy.
                 Only for column from subtypes of table's entity: we do not want to include columns which were "wrapped down".
    */
    attr = column.getEngAttribute();
    is_mandatory = true;
    member_names = new java.util.HashSet();
    if (attr) {
        attr_name = attr.getName();
        entity = attr.getEntity();
        is_hier = entity.isHierarchicalEntityType();
        parent = entity.getHierarchicalParent();
        // Typo in the class definition
        is_ignored = entity.getAttributeInherType()=="All atributes";
        relations = entity.getRelations();
        if (relations.length==1) {
            // Optional relationships need to have added member Not applicable for enumerated domains
            is_optional_relation = relations[0].isOptionalSource();
            is_identifying = relations[0].isIdentifying();
            is_one_to_one = relations[0].isOneToOne();
            source_entity = relations[0].getSourceEntity();
            source_is_hier_type = source_entity.isHierarchicalEntityType();
            is_subtype = false;
            if (source_is_hier_type) {
                is_subtype = !source_entity.isHierarchicalRoot();
            }
            if (is_identifying && is_one_to_one && !is_ignored && (is_optional_relation || is_subtype)) {
                is_mandatory = false;
            }    
        }
        if (is_hier && !is_ignored) {
            // Go through the hierarchy, on every level check if it is present also in all siblings
            // If it is missing in at least one, we add Not applicable
            while (parent!=null) {
                children = parent.getHierarchicalChildren().toArray();
                for (var i=0; i<children.length; i++) {
                    child = children[i];
                    attr_match = child.getElementByName(attr_name);
                    if (!attr_match) {
                        is_mandatory = false;
                        parent = null;
                        break;
                    }
                }
                if (parent) {
                    parent = parent.getHierarchicalParent();
                }
            }
        }
        if (!is_mandatory) {
            domain = column.getDomain();
            list_of_values = domain.getValueList();
            member_map = list_of_values.getValuesDescriptionMap();
            m = member_map.keySet().toArray();
            for (var k=0; k<m.length; k++) {
                member_code = m[k];
                description = member_map.get(member_code);
                // Each member is identified by its code and description
                member_code_desc = member_code + ": " + description;
                member_names.add(member_code_desc);
            }
            member_names.add("0: Not applicable");
        }
    }
    return member_names;
}


function getUnassignedDomainMemberIndex() {
    /* 
    Input: None
    Output: ArrayList
    Description: Returns a list [domain index, member index] of last unassigned member or domain.
    */
    domains = model.design.getDomainSet().toArray();
    domain_index = 0;
    member_index = 0;
    starting_indexes = new java.util.ArrayList();
    for (i=0; i<domains.length; i++) {
        temp_domain = domains[i];
        domain_name = temp_domain.getName();
        if (domain_name.contains("Unassigned")) {
            candidate_index = parseInt(domain_name.split("_")[2]); // List [Unassigned, domain, index]
            if (candidate_index>domain_index) {
                domain_index = candidate_index;
            }
        }
        domain_value_list = temp_domain.getValueList();
        if (domain_value_list) {
            domain_values = domain_value_list.getValues().toArray();
            for (var j=0; j<domain_values.length; j++) {
                value = domain_values[j];
                if (value.contains("Unassigned")) {
                    code_index = parseInt(value.split("_")[1]);
                    if (code_index>member_index) {
                        member_index = code_index;
                    }
                }
            }
        }
    }
    starting_indexes.add(domain_index);
    starting_indexes.add(member_index);
    return starting_indexes;
}


function createDomain(member_list) {
    /*
    Input: HashSet
    Output: Domain
    Description: Creates a Domain named "Unassigned_domain_<number>" in defaultdomains with constraint enumeration from member_list. 
                 If enumerations (sdd members) are newly created they have a value "Unassigned_<number>". 
    */
    new_domain = null;
    starting_indexes = getUnassignedDomainMemberIndex();
    domain_index = starting_indexes[0] + 1;
    domain_member_index = starting_indexes[1] + 1;
    member_list_array = member_list.toArray();
    if (member_list_array.length>0) {
         new_domain = model.design.createDomain();
         domain_name = "Unassigned_domain_" + domain_index;
        new_domain.setName(domain_name);
        app_view.logMessage("--- Created domain " + new_domain.getName());
        constraint_enumeration = new_domain.createConstraintEnumeration();
        for (var s=0; s<member_list_array.length; s++) {
            member = member_list_array[s];
            member_code_des = member.split(": "); // member = "code: name: description"
            if (member_code_des.length>1) {
                member_code = member_code_des[0];
                member_name = member_code_des[1];
            } else {
                member_code = "Unassigned_" + domain_member_index;
                member_name = member;
            }
            constraint_enumeration.add(member_code, member_name);
            domain_member_index += 1;
        }
        new_domain.setValueList(constraint_enumeration);
        // Set Logical data type to String
        lt_string = model.design.getLogicalDatatypeSet().getByName("String");
        new_domain.setLogicalDatatype(lt_string);
        new_domain.setDirty(true);
    }
    return new_domain;
}]]>
		</script>
	</scr>
	<scr id="CA33D31E-9B43-83F6-57CA-A6FA6D177A6C" name="Create mapping" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[var app_view = model.getAppView();
rel_model1 = model.design.getRelationalDesigns().getByName("Relational_2_Entity_role");
rel_model2 = model.design.getRelationalDesigns().getByName("Relational_3_Generalisation");
//rel_model = model.design.getRelationalDesign();
table_name = "BLDNG_ABSTRCT_EMPLY_RL_ASSGNMNT";
table = model.getTableSet().getByName(table_name);
col = table.getElementByName("LST_NM");
//col2 = table.getElementByName("NMBR_EMPLY");
attr = col.getEngAttribute();

rel_model3 = model.getRMExtendedMap();
app_view.logMessage(model.getName());
ent = table.getEngEntity();
attrb = ent.getAttributeSet().getObjectByID("5A78025D-3811-2A80-3D88-29AC4081C511");
//app_view.logMessage(attrb.getName());
//rel_model.getRMExtendedMap().createMapping(entity, table);
//app_view.logMessage(attr.getName());
//extended_map = rel_model1.getRMExtendedMap().getContainerMappings();
//extended_map2 = rel_model2.getRMExtendedMap();
//for (var i=0; i<extended_map.length; i++) {
	
//		c = extended_map[i].getContainedMappings();
//		for (var k=0; k<c.length; k++) {
//			cm = c[k];
//			app_view.logMessage(cm.getXtdMapping().getTargetID());
//		}
	
	
//}
//app_view.logMessage(extended_map);
//rel_model.getRMExtendedMap().createMapping(attr, col2);]]>
		</script>
	</scr>
	<scr id="0BAA564F-AB5F-D776-2E4F-31FDB3047F69" name="Tables to lower case - Rhino" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[tables = model.getTableSet().toArray();
for (var t = 0; t<tables.length;t++){
 table = tables[t];
 name = table.getName().toLowerCase();
 table.setName(name);
 columns = table.getElements();
 size = table.getElementsCollection().size();
 for (var i = 0; i < size; i++) {
	column = columns[i];
	cname = column.getName().toLowerCase();
	column.setName(cname);
 }
 table.setDirty(true);
 keys = table.getKeys();
 for (var i = 0; i < keys.length; i++) {
  key = keys[i];
    if(!key.isFK()){
     kname = key.getName().toLowerCase();
     key.setName(kname);
   }else{
     kname = key.getFKAssociation().getName().toLowerCase();
     key.getFKAssociation().setName(kname);
     key.getFKAssociation().setDirty(true);
   }
 }
}]]>
		</script>
	</scr>
	<scr id="E60A5A28-BB9B-3787-10E7-259DF900B9E6" name="Table abbreviation to column" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[tables = model.getTableSet().toArray();
for (var t = 0; t<tables.length;t++){
 table = tables[t];
 abbr = table.getAbbreviation()+"_";
 if(!"_".equals(abbr)){
     columns = table.getElements();
     for (var i = 0; i < columns.length; i++) {
        column = columns[i];
        cname = column.getName();
        if(!cname.startsWith(abbr)){
         column.setName(abbr+cname);
        }
     }
 }
}]]>
		</script>
	</scr>
	<scr id="9BE4E26C-36D8-A92C-ADEA-F183327DC239" name="Remove Table abbr from column" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[tables = model.getTableSet().toArray();
for (var t = 0; t<tables.length;t++){
 table = tables[t];
 abbr = table.getAbbreviation()+"_";
 count = table.getAbbreviation().length()+1;
 if(!"_".equals(abbr)){
     columns = table.getElements();
     for (var i = 0; i < columns.length; i++) {
        column = columns[i];
        cname = column.getName();
        if(cname.startsWith(abbr)){
         column.setName(cname.substring(count));
         table.setDirty(true);
        }
     }
 }
}]]>
		</script>
	</scr>
	<scr id="5A8A151A-13FD-4B0A-E233-E3C5126BA02C" name="Tables to upper case - Rhino" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[tables = model.getTableSet().toArray();
for (var t = 0; t<tables.length;t++){
 table = tables[t];
 name = table.getName().toUpperCase();
 table.setName(name);
 columns = table.getElements();
 size = table.getElementsCollection().size();
 for (var i = 0; i < size; i++) {
	column = columns[i];
	cname = column.getName().toUpperCase();
	column.setName(cname);
 }
 table.setDirty(true);
 keys = table.getKeys();
 for (var i = 0; i < keys.length; i++) {
  key = keys[i];
    if(!key.isFK()){
     kname = key.getName().toUpperCase();
     key.setName(kname);
   }else{
     kname = key.getFKAssociation().getName().toUpperCase();
     key.getFKAssociation().setName(kname);
     key.getFKAssociation().setDirty(true);
   }
 }
}]]>
		</script>
	</scr>
	<scr id="0528C35C-F29B-E7BB-57AC-37BA2780A98D" name="Table template - uses column name" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[// columns are found by column name
// allowing reuse of already existing columns
// dynamic property ctemplateID is set afterwards - will keep connection to template
// column even if the name of column is changed
var t_name = "table_template";
var p_name = "ctemplateID";
template = model.getTableSet().getByName(t_name);
if(template!=null){
    tcolumns = template.getElements();
    tables = model.getTableSet().toArray();
    for (var t = 0; t<tables.length;t++){
     table = tables[t];
    // compare name ignoring the case
     if(!table.getName().equalsIgnoreCase(t_name)){
         for (var i = 0; i < tcolumns.length; i++) {
            column = tcolumns[i];
            col = table.getElementByName(column.getName());
            if(col==null){
             col = table.getColumnByProperty(p_name,column.getObjectID());
            }
            if(col==null){
             col = table.createColumn();
            }
            column.copy(col);
            //set property after copy otherwise it'll be cleared by copy
            col.setProperty(p_name,column.getObjectID());
            table.setDirty(true);
         }
     }
    }
}]]>
		</script>
	</scr>
	<scr id="6279C414-90DD-A52B-4CEB-8D49AB31DC10" name="Copy Comments to Comments in RDBMS" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[max_length = 4000;
function copyComments(object){
 if(object.getCommentInRDBMS().equals("")){
   if(!object.getComment().equals("")){
     if(object.getComment().length()>max_length){
       object.setCommentInRDBMS(object.getComment().substring(0, max_length));
     }else{
       object.setCommentInRDBMS(object.getComment());
     }
     object.setDirty(true);
   }
 }
}

tables = model.getTableSet().toArray();
for (var t = 0; t<tables.length;t++){
 table = tables[t]
 copyComments(table);
 columns = table.getElements();
 size = table.getElementsCollection().size();
 for (var i = 0; i < columns.length; i++) {
	column = columns[i];
	copyComments(column);
 }
 keys = table.getKeys();
 for (var i = 0; i < keys.length; i++) {
   key = keys[i];
   if(!key.isFK()){
     copyComments(key);
   }else{
     copyComments(key.getFKAssociation());
   }
 }
}]]>
		</script>
	</scr>
	<scr id="7C4EDFC0-26EA-859C-DBD9-AC9345DEAF98" name="Create index on FK" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[function getIndex(tab,cols){
 keys = tab.getKeys();
 for (var i = 0; i < keys.length; i++) {
  index = keys[i];
  if(!(index.isPK() || index.isUnique()) && !index.isFK() && index.isIndexForColumns(cols)){
     return index
   }
 }
 return null;
}

tables = model.getTableSet().toArray();
for (var t = 0; t<tables.length;t++){
 table = tables[t];
 indexes = table.getKeys();
 for (var i = 0; i < indexes.length; i++) {
    index = indexes[i];
    if(index.isFK()){
     columns = index.getColumns();
     if(columns.length>0){
       newIndex = getIndex(table,columns);
       if(newIndex==null){
         newIndex = table.createIndex()
         table.setDirty(true);
         for (var k = 0; k < columns.length; k++){
           newIndex.add(columns[k]);
         }
       }
     }
   }
 }
}]]>
		</script>
	</scr>
	<scr id="F54B1A9C-F951-EB88-E905-5599533569B1" name="Create subview from tables in serch result " object="relational" engine="Oracle Nashorn" var="model" library="Jruby lib" method="tables_up" purpose="transformation" >
		<script>
			<![CDATA[def tables_up(model)
tables = model.getTableSet().toArray()
for t in 0..tables.length-1
 table = tables[t]
 name = table.getName().upcase
 table.setName(name)
 columns = table.getElements()
 size = table.getElementsCollection().size()-1
 for i in 0..size
	column = columns[i]
	cname = column.getName().upcase
	column.setName(cname)
 end
 keys = table.getKeys()
 for i in 0..keys.length-1
  key = keys[i]
  kname = key.getName().upcase
  key.setName(kname)
 end
end
return true
end]]>
		</script>
	</scr>
	<scr id="EF64BEDD-B648-C41B-60C7-B9EA938E0A3C" name="Remove template columns and related attributes" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/* removes the columns created with "Table template..." script, also removes related attributes
*  from logical model
*  more details here http://www.thatjeffsmith.com/archive/2015/03/adding-common-columns-to-tables-via-templates-and-transformation-scripts/
*/
var t_name = "table_template";
var p_name = "ctemplateID";
template = model.getTableSet().getByName(t_name);
if(template!=null){
    tcolumns = template.getElements();
    tables = model.getTableSet().toArray();
    for (var t = 0; t<tables.length;t++){
     table = tables[t];
    // compare name ignoring the case
     if(!table.getName().equalsIgnoreCase(t_name)){
         for (var i = 0; i < tcolumns.length; i++) {
            column = tcolumns[i];
            col = table.getColumnByProperty(p_name,column.getObjectID());
            if(col!=null){
            	attr = col.getEngAttribute();
            	if(attr!=null){
            		ent = attr.getEntity();
            		attr.remove();
            		if(ent!=null){
            			ent.setDirty(true);
            		}
            	}
             col.remove();
             table.setDirty(true);
            }
         }
     }
    }
}]]>
		</script>
	</scr>
	<scr id="19D9E485-18DA-03D1-C334-D575FD7AAAAA" name="Test" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[var app_view = model.getAppView();
table_name = "DPRTMNT";
table = model.getTableSet().getByName(table_name);
cols = table.getElements();
ent = table.getEngEntity();
for (var i=0; i<cols.length; i++) {
	col = cols[i];
	rel_mep = col.getMappingsFor(ent);
	rel_mep = col.getDeletedMappingsFor(ent);
	app_view.logMessage(col.getName());
	app_view.logMessage(rel_mep);
}]]>
		</script>
	</scr>
</custom_transformation_scripts>