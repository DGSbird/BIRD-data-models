<?xml version="1.0" encoding="UTF-8" ?>
<!-- File contains Custom Transformation scripts -->
<custom_transformation_scripts>
	<scr id="1726EC74-A64B-0C0F-83DB-2A4BEF0D3DCA" name="15. Columns order" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[// NOTE: This script was created by SQL Data Modeler developers

// sorts table columns as asked here https://forums.oracle.com/forums/thread.jspa?threadID=2508315&tstart=0
// "...first the pks columns, after them fk columns and after the not null columns"

/** 
 *  SCRIPT NAME: Columns order
 *  PURPOSE: Order columns by type: first primary keys, then foreign keys, madatory column and last optional
 *  OBJECT: applied on relational data model
 *  REQUIREMENTS: 
 *  DYNAMIC: 
 *  SHORT DESCRIPTION: 
*/

// ---- INPUT PARAMETERS ----
script_name = "Columns order";

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");


function addPKcolumns(list,table){
	pk = table.getPK();
	if(pk!=null){
		pcols = pk.getColumns();
		for(var i = 0;i<pcols.length;i++){
			col = pcols[i];
			//in fact don't need this check, because PK columns are processed first
			if(!list.contains(col)){
				list.add(col);
			}
		}
	}
}

function addFKcolumns(list,fkeys){
	for(var k=0;k<fkeys.length;k++){
		fcols = fkeys[k].getColumns();
		for(var i = 0;i<fcols.length;i++){
		  col = fcols[i];
		  if(!list.contains(col)){
			list.add(col);
		  }
		}
	}
}
//adds mandatory or optional columns to list depending on mand parameter
function addMandatoryOptColumns(list,cols, mand){
	for(var i = 0;i<cols.length;i++){
		col = cols[i];
		if(col.isMandatory() == mand && !list.contains(col)){
			list.add(col);
		}
	}
}

tables = model.getTableSet().toArray();
list = new java.util.ArrayList();
log_tables_amended = new java.util.ArrayList();
for (var t=0; t<tables.length; t++){
	list.clear();
	table = tables[t];
	cols = table.getElements();
	// add PK columns to list
	addPKcolumns(list,table);
	// add FK columns to list
	addFKcolumns(list,table.getFKAssociations());
	// add mandatory columns
	addMandatoryOptColumns(list,cols,true);
	// add optional columns
	addMandatoryOptColumns(list,cols,false);
	// use list to reorder columns
	ord_cols = list.toArray();
	for (var n=0; n<ord_cols.length; n++){
		table.moveToIndex(ord_cols[n], n);
	}
	//prevent reordering from enginnering, can be changed with UI
	table.setAllowColumnReorder(false);
	log_tables_amended.add(table.getName());
	table.setDirty(true);
}

app_view.logMessage("- Tables amended: " + log_tables_amended);
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_tables_amended.length + "/" + tables.length + " tables amended");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="00F69B42-A768-0523-C5CA-B6955B698866" name="12. Set enumerated Column to mandatory" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Set enumerated columns to mandatory
 *  PURPOSE: when wrapping up, all columns from subtypes become optional  
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run last
 *  DYNAMIC: 
 *  SHORT DESCRIPTION: 
*/

// ---- INPUT PARAMETERS ----
script_name = "Set enumerated columns to mandatory";

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

tables = model.getTableSet().toArray();
log_num_cols_affected = 0;
log_tables_affected = 0;
for (var t=0; t<tables.length; t++){
    table = tables[t];
    table_name = table.getName();
    columns = table.getElements();
    log_is_amended = false;
    log_columns_affected = new java.util.ArrayList();
    for (var i=0; i<columns.length; i++) {
        column = columns[i];
        attr =  column.getEngAttribute();
        if (attr!=null) {
            domain_enumerated = attr.getDomain().getValueList();
            if (column.isMandatory()==false && domain_enumerated!=null) {
                log_is_amended = true;
                column.setMandatory(true);
                log_columns_affected.add(column);
                log_num_cols_affected += 1;   
            }
        }
    }
    if (log_is_amended) {
        app_view.logMessage("- Table " + table_name + " amended");
        app_view.logMessage("--- " + log_columns_affected.length + "/" + columns.length + " columns set to mandatory");
        app_view.logMessage("--- Columns set to mandatory: " + log_columns_affected);
        table.setDirty(true);
        log_tables_affected += 1;
    } 
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_num_cols_affected + " columns amended (set to mandatory)");
app_view.logMessage("- " + log_tables_affected + "/" + tables.length + " tables affected");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="930015FE-7A97-CE66-ED49-C3B5973D6329" name="7. Optional one-to-one relationships" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Optional one-to-one relationships
 *  PURPOSE: during FE, all optional relationships become mandatory foreign keys  
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run before merging one-to-one relationships
 *  DYNAMIC: merge_derived_entities = false, if we want ot keep derived data in a separate entity
 *           In this case, we leave the columns mandatory
 *  SHORT DESCRIPTION: sets Columns of Tables, where Entities had optional one-to-one relationship and only one relationship, to optional
 *                     same for madatory one-to-one relationships on subtypes
*/

// ---- INPUT PARAMETERS ----
var merge_derived_entities = true;
script_name = "Optional one-to-one relationships";

// ----SCRIPT----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

tables = model.getTableSet().toArray();
log_total_tables = tables.length;
log_tables_affected = 0;
log_num_cols = 0;
log_total_num_cols_affected = 0;
for (var t=0; t<tables.length; t++){
    table = tables[t];
    tname = table.getName();
    is_derived = tname.contains("DRVD") || tname.contains("derived") || tname.contains("Derived");
    if (merge_derived_entities==true || (merge_derived_entities==false && is_derived==false)) {
        entity = table.getEngEntity();
        num_of_relations = table.getFKAssociations().length;
        relations = entity.getRelations();
        if (relations.length==1) {
            is_optional_relation = relations[0].isOptionalSource();
            is_identifying = relations[0].isIdentifying();
            is_one_to_one = relations[0].isOneToOne();
            source_entity = relations[0].getSourceEntity();
            source_is_hier_type = source_entity.isHierarchicalEntityType();
            is_subtype = false;
            if (source_is_hier_type) {
                is_subtype = !source_entity.isHierarchicalRoot();
            }
            if (num_of_relations==1 && is_one_to_one && ((is_optional_relation && is_identifying) || (is_subtype))) {
                app_view.logMessage("- Table " + tname + " amended");
                columns = table.getElements();
                log_num_cols += columns.length;
                log_columns_affected = new java.util.ArrayList();
                for (var i = 0; i < columns.length; i++) {
                    column = columns[i];
                    column_name = column.getName();
                    if (column.isFKColumn()==false && column.isPKElement()==false) {
                        column.setMandatory(false);
                        log_columns_affected.add(column_name);
                        log_total_num_cols_affected += 1;
                    }
                    table.setDirty(true);
                }
                app_view.logMessage("--- " + log_columns_affected.length + "/" + columns.length + " columns set to optional");
                app_view.logMessage("--- Columns set to optional: " + log_columns_affected);
                log_tables_affected += 1;  
            }
        }   
    }  
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_total_num_cols_affected + "/" + log_num_cols + " columns amended (set to optional)");
app_view.logMessage("- " + log_tables_affected + "/" + log_total_tables + " tables affected");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="5B9E23C1-3697-AC2E-74AF-A021A235D5D9" name="3. Entity role and Abstract instrument role" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME: Entity role and Abstract instrument role
 *  PURPOSE: Entity role is a generalisation without primary key, which is related to other generalisations, so it needs to be handled first.   
 *           Abstract instrument role has similar properties as Entity role, it is a generalisation where attributes from 
 *           primary key have the same primary concept (Instrument role type, OTC derivative role type) and have to be merged into one column.
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run before Generalisation
 *  DYNAMIC: input of generalisation tables which need to be handled first
 *           is_preferred_abbreviation=true, if relational model is generated with preferred abbreviations
 *  SHORT DESCRIPTION: During fe, the Table gets a surrogate primary key, which needs to be changed to primary key defined on subtypes. 
 *                     Primary keys on subtypes are: 
 *                     - foreign key columns, which come from the same source column: these are merged.    
 *                     - column, which have the same primary concept: need to be merged into one column (primary concept column) and domain
 *                       need to be amended to a union of members of these columns 
 *                         -- If a table has more than two levels of subtyping (abstract and one other), we exclude this primary column from domain being amended.
 *                         -- This is handled by reduce discriminators script
 *                     After changing its primary key, foreign keys related to this Table need to change index to the new primary key.    
 *                     These foreign keys (primary key columns) need to be set to mandatory.
 *                     
*/

// ---- INPUT PARAMETERS ----
var is_preferred_abbreviation = true;
script_name = "Entity role and Abstract instrument role";
// We exclude amneding the domain of Instrumemnt role type column, since we would need to consider disjoint subtyping
// This is included in Reduce discriminators script
// If the primary concept is also a part of reducing the discriminators, we should not amend its domain here
excluded_to_amend_domains = new java.util.ArrayList([
                                           "INSTRMNT_RL_TYP",
                                           "Instrument_role_type"
                                           ]);

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

var table_name_party = "ENTTY_RL";
var table_name_instrument = "ABSTRCT_INSTRMNT_RL";
// The columns in replacibles have the same primary concept
var replacibles_party = new java.util.ArrayList([
                                       "PRTY_RL_TYP",
                                       "Party_role_type",  
                                       "ORGNSTN_RL_TYP",
                                       "Organisation_role_type", 
                                       "LGL_PRSN_RL_TYP",
                                       "Legal_person_role_type",
                                       "Central_bank_and_private_sector_company_role_type",
                                       "OTHR_ORGNSTN_RL_TYP",
                                       "Entity_group_role_type",
                                       "ENTTY_GRP_RL_TYP",
                                       "Entity_transaction_role_type",
                                       "ENTTY_TRNSCTN_RL_TYP"
                                       ]);

var replacibles_instrument = new java.util.ArrayList([
                                "OTC_DRVTV_RL_TYP",
                                "Over_the_counter_(OTC)_derivative_role_type",
                                "INSTRMNT_RL_TYP",
                                "Instrument_role_type"
                                ]);
var primary_concept_party = "PRTY_RL_TYP";
var primary_concept_instrument = "INSTRMNT_RL_TYP";

if (is_preferred_abbreviation==false) {
    table_name_instrument = "Abstract_instrument_role";
    table_name_party = "Entity_role";
    primary_concept_party = "Party_role_type";
    primary_concept_instrument = "Instrument_role_type";
}

updateGeneralisation(table_name_party, primary_concept_party, replacibles_party);
updateGeneralisation(table_name_instrument, primary_concept_instrument, replacibles_instrument);


app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

// ---- FUNCTIONS ----
function getFEName(attribute, is_preferred_abbreviation) {
    /*
    Input: Attribute, Bool
    Output: String
    Description: Returns preffered abbreviation of attribute in case of using preferred abbreviation for fe, 
                 othervise returns attribute names with underscores instead of spaces.
    */
    if (is_preferred_abbreviation==true) {
        fe_name = attribute.getPreferredAbbreviation();
    } else {
        attr_name = attribute.getName();
        fe_name = attr_name.replaceAll(" ", "_"); 
    }
    return fe_name
}


function removeNumbersfromColumns(column) {
    /*
    Input: Column
    Output: Bool
    Description: Removes numbers from column names and returns a boolean whether or not the name was changed.
    */
    table =  column.getTable();
    col_name = column.getName();
    attr = column.getEngAttribute();
    skip = false;
    if (attr) {
        fe_name = attr.getPreferredAbbreviation();
        skip = fe_name.matches(".*\\d.*");
    }
    if (skip==false) {
        new_name = col_name.replaceAll("[0-9]", "");
        column.setName(new_name);
        table.setDirty(true);
    }
    if (col_name != column.getName()) {
        change = true;
    } else {
        change = false;
    }
    return change;
}


function getMatchingDomain(granular_discriminator, leaves_member_list) {
    /*
    Input: Column, HashSet
    Output: Bool
    Description: Goes through all domains and checks if there exists one with matching values (sdd members) from leaves_member_list.
                 If found, assined to granular_discriminator.
                 Returns bool, mathcing domain found or not.
    */ 
    domains = model.design.getDomainSet().toArray();
    matching_domain_found = false;
    table = granular_discriminator.getTable();
    for (var j=0; j<domains.length; j++) {
        domain = domains[j];
        domain_name = domain.getName();
        list_of_values = domain.getValueList();
        // Check only enumerated domains
        if (list_of_values!=null) {
            domain_member_names = new java.util.HashSet();
            member_map = list_of_values.getValuesDescriptionMap();
            m = member_map.keySet().toArray();
            for (var k=0; k<m.length; k++) {
                member_code = m[k];
                description = member_map.get(member_code);
                member = member_code + " | " + description;
                domain_member_names.add(member);
            }
            // Check if this domain has the same members as leaves of the hierarchy
            if (domain_member_names.equals(leaves_member_list)) {
                app_view.logMessage("----- Matching domain found: " + domain_name);
                matching_domain_found = true;
                granular_discriminator.setDomain(domain);
                break;
            }
        }
    }
    table.setDirty(true);
    return matching_domain_found
}


function getColumnMemberList(column) {
    /*
    Input: Column
    Output: HashSet
    Description: Returns a set of values (sdd members) of domain of a column
    */
    domain = column.getDomain();
    value_list = domain.getValueList();
    column_member_names = new java.util.HashSet();
    if (value_list) {
        column_member_map = value_list.getValuesDescriptionMap();    
        m = column_member_map.keySet().toArray();
        for (var k=0; k<m.length; k++) {
            member_code = m[k];
            description = column_member_map.get(member_code);
            member_name = description.split(":")[0];
            member_code_desc = member_code + " | " + description;
            // Each member is identified by its code and description
            column_member_names.add(member_code_desc);
        }
    }
    return column_member_names
}


function getUnassignedDomainMemberIndex() {
    /*
    Input: None
    Output: ArrayList
    Description:  Returns a list [domain index, member index] of last unassigned member or domain
    */
    domains = model.design.getDomainSet().toArray();
    domain_index = 0;
    member_index = 0;
    starting_indexes = new java.util.ArrayList();
    for (i=0; i<domains.length; i++) {
        temp_domain = domains[i];
        domain_name = temp_domain.getName();
        if (domain_name.contains("Unassigned")) {
            candidate_index = parseInt(domain_name.split("_")[2]); // List [Unassigned, domain, index]
            if (candidate_index>domain_index) {
                domain_index = candidate_index;
            }
        }
        domain_value_list = temp_domain.getValueList();
        if (domain_value_list) {
            domain_values = domain_value_list.getValues().toArray();
            for (var j=0; j<domain_values.length; j++) {
                value = domain_values[j];
                if (value.contains("Unassigned")) {
                    code_index = parseInt(value.split("_")[1]);
                    if (code_index>member_index) {
                        member_index = code_index;
                    }
                }
            }
        }
    }
    starting_indexes.add(domain_index);
    starting_indexes.add(member_index);
    return starting_indexes;
}


function createDomain(member_list) {
     /*
    Input: HashSet
    Output: Domain
    Description: Creates a Domain named "Unassigned_domain_<number>" in defaultdomains with constraint enumeration from member_list. 
                 If enumerations (sdd members) are newly created they have a value "Unassigned_<number>". 
    */
    new_domain = null;
    starting_indexes = getUnassignedDomainMemberIndex();
    domain_index = starting_indexes[0] + 1;
    domain_member_index = starting_indexes[1] + 1;
    member_list_array = member_list.toArray();
    if (member_list_array.length>0) {
         new_domain = model.design.createDomain();
         domain_name = "Unassigned_domain_" + domain_index;
        new_domain.setName(domain_name);
        app_view.logMessage("--- Created domain " + new_domain.getName());
        constraint_enumeration = new_domain.createConstraintEnumeration();
        for (i=0; i<member_list_array.length; i++) {
            member = member_list_array[i];
            member_code_des = member.split(" | "); // member = "code | name: description"
            if (member_code_des.length>1) {
                member_code = member_code_des[0];
                member_name = member_code_des[1];
            } else {
                member_code = "Unassigned_" + domain_member_index;
                member_name = member;
            }
            constraint_enumeration.add(member_code, member_name);
            domain_member_index += 1;
        }
        new_domain.setValueList(constraint_enumeration);
        // Set Logical data type to String
        lt_string = model.design.getLogicalDatatypeSet().getByName("String");
        new_domain.setLogicalDatatype(lt_string);
        new_domain.setDirty(true);
    }
    return new_domain;
}


function getHierarchicalTree(entity) {
	leaves = entity.getHierarchicalLeaves();
	hierarchy_tree = new java.util.HashSet();
	hierarchy_tree.add(entity);
	//app_view.logMessage("Entity: " + entity);
	if (entity.isHierarchicalEntityType()) {
		for (var i=0; i<leaves.length; i++) {
			leaf = leaves[i];
			hierarchy_tree.add(leaf);
			parent = leaf.getHierarchicalParent();
			//app_view.logMessage("Parent: " + parent);
			is_downwrapped = parent.getAttributeInherType()=='All atributes';
			// Igore the ones that are downwrapped
			if (!is_downwrapped) {
				while (parent.getName() != entity.getName()) {
					hierarchy_tree.add(parent);
					parent = parent.getHierarchicalParent();
				}
			}
		}
	}
	return hierarchy_tree;
}


function getOverlappingAttributesOfHierarchy(entity) {
    hierarchy_tree = getHierarchicalTree(entity).toArray();
    attributes_to_replace = new java.util.ArrayList();
    attr_fold_map = new java.util.HashMap();
    for (var i=0; i<hierarchy_tree.length; i++) {
    	    ent1 = hierarchy_tree[i];
    	    attrs = ent1.getAttributeSet();
    	    folded_attrs = ent1.getFoldedAttributesMap();
	    keys = folded_attrs.keySet().toArray();
	    for (var j=0; j<keys.length; j++) {
		    attr1_id = keys[j];
		    attr2_id = folded_attrs.get(attr1_id);
		    attr1 = attrs.getObjectByID(attr1_id);
		    attr2 = attrs.getObjectByID(attr2_id);
		    if (attr1 != null && attr2 != null) {
		    	   orig_attr1 = attr1.getOriginatingAttribute();
		        orig_attr2 = attr2.getOriginatingAttribute();
		        attributes_to_replace.add(orig_attr1.getName());
		        attr_fold_map.put(attr1, attr2);
		    } else {
		    	//app_view.logMessage("---- WARNING: Entity " + entity.getName() + " can't use the mapping, the attribute doesn't exist");
		    }
		    
	    }
    }
    return [attributes_to_replace, attr_fold_map]
}


function createMappingForAttrAndOverlapping(relational_model, attr_fold_map, attribute, column) {
	f_attr_name = attribute.getName();
	folded = attr_fold_map.get(attribute);
	relational_model.getRMExtendedMap().createMapping(attribute, column);
	//if (column.getTable().getName()=="Entity_role") {
	//	app_view.logMessage("------- Created mapping from attribute " + attribute.getName() + " to column " + column.getName());
	//}
	
	if (folded != null) {
	    relational_model.getRMExtendedMap().createMapping(folded, column);
	    //if (column.getTable().getName()=="Entity_role") {
	    //	app_view.logMessage("------- Created mapping from attribute " + folded.getName() + " to column " + column.getName());
	    //}
	}
	relational_model.setDirty(true);
}


function addMappingsFromRemovedColumn(relational_model, table, column_to_be_removed, target_column) {
    /*
    Input: RelationalModel, Table, Column, Column
    Output: None
    Description: finds existing mappings from column_to_be_removed and copies them to target_column
    */
    maps = table.getMappingsToEntities();
    for (var j=0; j<maps.length; j++) {
        map = maps[j];
		// find source entity
		source_ent = model.design.getLogicalDesign().getEntitySet().getByName(map.getName());
		// find source attributes
		maps_col = column_to_be_removed.getMappingsFor(source_ent);
        if (maps_col.length > 0) {
			for (var m=0; m<maps_col.length; m++) {
				source_attr_name = maps_col[m].getName();
				//app_view.logMessage("-- Source entity: " + map.getName() + ", attribute: " + source_attr_name);
				source_attribute = source_ent.getElementByName(source_attr_name);
                // Add mapping from this attribute to target column
                relational_model.getRMExtendedMap().createMapping(source_attribute, target_column);
				relational_model.setDirty(true);
			}
		}
    }
}

function updateGeneralisation(table_name, primary_concept, replacibles) {
    /*
    Input: String, String, ArrayList
    Output: None
    Description: Updates generalisation tables and their related tables
    */
    rel_model = model;
    tables = model.getTableSet().toArray();
    table = model.getTableSet().getByName(table_name);
    primary_concept_column = table.getElementByName(primary_concept);
    columns_to_remove = new java.util.ArrayList();
    entity = table.getEngEntity();
    // Overlapping attributes of the hierarchy
    folded_attrs_list = getOverlappingAttributesOfHierarchy(entity);
    attributes_to_replace = folded_attrs_list[0];
    attr_fold_map = folded_attrs_list[1];
    pks = new java.util.HashMap();
    fpks = new java.util.ArrayList();
    columns = table.getElements();
    // Prepare set of members seperately for primary concept 
    primary_concept_domain = new java.util.HashSet();
    log_cols_replaced_by_primary_concept = new java.util.ArrayList();
    app_view.logMessage("- Table " + table_name + " amended");
    // Fix Table 
    for (var i=0; i<columns.length; i++) {
        column = columns[i];
        // Remove surrogate pk
        if (column.isSurrogateColumn()==true) {
            columns_to_remove.add(column);
            col_name = column.getName();
            app_view.logMessage("--- Surrogate key " + col_name + " removed");
        } else {
            app_view.logMessage("--- Checking column " + col_name);
            attribute = column.getEngAttribute();
            // Check if attribute was a primary key (and not foreign key):
            // in this case, check if it is one of the replacibles and replace it with its primary concept
            attr_name = getFEName(attribute, is_preferred_abbreviation); 
            if (attribute.isPKElement()==true && attribute.isFKAttribute()==false) {
                app_view.logMessage("----- Column is PK and not FK");
                if (replacibles.contains(attr_name)) {
                    app_view.logMessage("----- Column is in replacibles");
                    log_cols_replaced_by_primary_concept.add(attr_name);
                    attr_name = primary_concept;
                    if (pks.containsKey(primary_concept)==true) {
                        columns_to_remove.add(column);
                        // add mappings from column to remove to primary concept column
                        addMappingsFromRemovedColumn(rel_model, table, column, primary_concept_column);
                        createMappingForAttrAndOverlapping(rel_model, attr_fold_map, attribute, primary_concept_column);
                    } else {
                        column.setName(attr_name);
                    }
                    col_domain = getColumnMemberList(column);
                    primary_concept_domain.addAll(col_domain);
                }
                if (pks.containsKey(attr_name)==false) {
                    pks.put(attr_name, column);    
                } else {
                	mapped_to_col = pks.get(attr_name);
                    columns_to_remove.add(column);
                    addMappingsFromRemovedColumn(rel_model, table, column, mapped_to_col);
                    createMappingForAttrAndOverlapping(rel_model, attr_fold_map, attribute, mapped_to_col);
                }
            }
            if (attribute.isFKAttribute()==true && attribute.isPKElement()==true) {
                app_view.logMessage("----- Column is PK and FK");
                // If foreign keys come from the same entity, (same name of attribute), rename the column and keep only one
                attr_name = getFEName(attribute.getOriginatingAttribute(), is_preferred_abbreviation);
                if (replacibles.contains(attr_name)) {
                    log_cols_replaced_by_primary_concept.add(attr_name);
                    attr_name = primary_concept;
                    if (pks.containsKey(primary_concept)==true) {
                        columns_to_remove.add(column);
                    } else {
                        column.setName(attr_name);    
                    }
                    col_domain = getColumnMemberList(column);
                    primary_concept_domain.addAll(col_domain);
                } else {
                    column.setName(attr_name);    
                }
                if (pks.containsKey(attr_name)==false) {
                    pks.put(attr_name, column); 
                } else {
                	mapped_to_col = pks.get(attr_name);
                    columns_to_remove.add(column);
                    addMappingsFromRemovedColumn(rel_model, table, column, mapped_to_col);
                    createMappingForAttrAndOverlapping(rel_model, attr_fold_map, attribute, mapped_to_col);
                }
            }
        }
        table.setDirty(true);
    }
    
    // Set new primary key to ENTTY_RL
    var new_index = table.createIndex();
    keys = pks.keySet().toArray();
    log_pk_col_names = new java.util.ArrayList();
    for (var i = 0; i < pks.size(); i++) {
        col = pks.get(keys[i]);
        new_index.add(col);
        log_pk_col_names.add(col.getName());
    }
    new_index.setPK(true);
    app_view.logMessage("--- Primary key constraint amended");
    app_view.logMessage("----- New primary key: " + log_pk_col_names);
    table.setDirty(true);
    
    // Change foreign key associations with ENTTY_RL
    log_related_tables_amended = 0;
    log_related_tables = 0;
    for (var s=0; s<tables.length; s++) {
        related_table = tables[s];
        related_entity = related_table.getEngEntity();
        // Overlapping attributes of the hierarchy
        folded_attrs_list = getOverlappingAttributesOfHierarchy(related_entity);
        attributes_to_replace = folded_attrs_list[0];
        attr_fold_map = folded_attrs_list[1];
        fks = related_table.getFKIndexAssociationsWith(table);
        related_table_name = related_table.getName();
        related_table_columns = related_table.getElements();
        if (related_table_name != table.getName()) {
            log_related_tables += fks.length;
            for (var j=0; j<fks.length; j++) {
                fk = fks[j];
                table_pk_cols_base = fk.getColumns();
                ref_table = fk.getRemoteTable(); // entity role or abstract instrument role
                ref_index = fk.getRemoteIndex();
                ref_table_pk = ref_table.getPK();
                ref_table_cols = ref_table_pk.getColumns();
                app_view.logMessage("--- Related table " + related_table_name + " amended");
                log_related_tables_amended += 1;
                if (ref_index.isPK()==false) {
                    // If it's not a generalisation, add columns from primary key
                    is_generalisation = related_entity.isCreateSurrogateKey();
                    log_new_fk_cols = new java.util.ArrayList();
                    log_connected_cols = new java.util.ArrayList();
                    if (is_generalisation==false) {
                        table_pk_cols_base = fk.getColumns(); // existing columns in related table
                        // Prepare names of pk columns, so that we connect correct columns
                        ref_table_cols_names = new java.util.ArrayList();
                        table_pk_cols_names = new java.util.ArrayList();
                        table_pk_cols_names_sorted = new java.util.ArrayList();
                        fake_index = related_table.createIndex();
                        for (var k=0; k<ref_table_cols.length; k++) {
                            ref_c = ref_table_cols[k];
                            log_new_fk_cols.add(ref_c.getName());
                            c = table_pk_cols_base[k];
                            ref_table_cols_names.add(ref_c.getName());
                            table_pk_cols_names.add(c.getName());
                        }
                        for (var k=0; k<ref_table_cols_names.length; k++) {
                            col_name = ref_table_cols_names[k];
                            for (var l=0; l<table_pk_cols_names.length; l++) {
                                col_pk = table_pk_cols_names[l];
                                name1 = col_name.replaceAll("[0-9]", "");
                                name2 = col_pk.replaceAll("[0-9]", "");
                                if (name1.contains(name2) || name2.contains(name1) || ((name1.contains("RL_TYP") || name1.contains("role_type")) && (name2.contains("RL_TYP") || name2.contains("role_type")))) {
                                    fake_index.add(table_pk_cols_base[l]);
                                    log_connected_cols.add(table_pk_cols_base[l].getName());
                                    table_pk_cols_names_sorted.add(col_pk);
                                }
                            }
                        }
                        table_pk_cols = fake_index.getColumns();
                        for (var m=0; m<table_pk_cols.length; m++) {
	                   	   attr_from = related_table.getElementByName(table_pk_cols_names_sorted[m]).getEngAttribute();
	                   	   col_to = table_pk_cols[m];
                              addMappingsFromRemovedColumn(rel_model, related_table, attr_from.getEngColumn(rel_model, related_table), col_to);
	                   	   createMappingForAttrAndOverlapping(rel_model, attr_fold_map, attr_from, col_to);
	                   }
                        fake_index.remove();
                    } else {
                        table_pk_cols_names = new java.util.ArrayList();
                        table_pk_cols = new_index.getColumns();
                        fake_index = related_table.createIndex();
                        for (var k=0; k<table_pk_cols.length; k++) {
                            c = table_pk_cols[k];
                            c_name  = c.getName();
                            original_c = table.getElementByName(c_name);
                            log_new_fk_cols.add(c_name);
                            
                            if (related_table.getElementByName(c_name) == null) {
                            	created_c = related_table.createColumn();
                                original_c.copy(created_c);
                                created_c.setDirty(true);
                            }
                            created_c = related_table.getElementByName(c_name);
                            fake_index.add(created_c);
                            // Find previous column that resembles this one
                            for (var n=0; n<related_table_columns.length; n++) {
                                rel_t_col = related_table_columns[n];
                                rel_t_attr = rel_t_col.getEngAttribute();
                                name1 = rel_t_col.getName().replaceAll("[0-9]", "");
                                name2 = c_name.replaceAll("[0-9]", "");
                                if (name1.contains(name2) || name2.contains(name1) || ((name1.contains("RL_TYP") || name1.contains("role_type")) && (name2.contains("RL_TYP") || name2.contains("role_type")))) {
                                    // Add mappings
                                    addMappingsFromRemovedColumn(rel_model, related_table, rel_t_col, created_c);
                                    createMappingForAttrAndOverlapping(rel_model, attr_fold_map, rel_t_attr, created_c);
                                    app_view.logMessage("------ Added mapping from attribute " + rel_t_attr.getName() + " to column " + created_c.getName());
                                    log_connected_cols.add(rel_t_col.getName());
                                }
                            }
                        }
                        table_pk_cols = fake_index.getColumns();
                        fake_index.remove();
                    }
                    related_table.setDirty(true);
                    // Change fk constraint
                    fk.changeKeyObject(ref_table_pk, table_pk_cols);
                    app_view.logMessage("----- New foreign key: " + log_new_fk_cols + " on " + log_connected_cols);
                    
                    fk.setMandatory(true);
                    app_view.logMessage("----- Foreign key set to mandatory");
                }
            }
            related_table.setDirty(true);
        }
    }

    // Remove columns
    for (var i = 0; i < columns_to_remove.length; i++) {
        col = columns_to_remove[i];
        col.remove();
    }
    app_view.logMessage("--- " + columns_to_remove.length + "/" + columns.length + " columns removed");
    app_view.logMessage("--- Columns removed: " + columns_to_remove);
    table.setDirty(true);
    
    // Remove empty constraints
    keys = table.getKeys();
    log_empty_constraints_removed = 0;
    for (var i = 0; i < keys.length; i++) {
        index = keys[i];
        index_c = index.getColumns();
        if (index_c.length==0) {
            log_empty_constraints_removed += 1;
            index.remove();
        }
        table.setDirty(true);
    }
    app_view.logMessage("--- " + log_empty_constraints_removed + "/" + keys.length + " keys removed");
    
    // Set relationships to mandatory in entty_rl
    fks = table.getFKAssociationsList();
    log_fks_to_mandatory = 0;
    for (var j=0; j<fks.length; j++) {
        fk = fks[j];
        cols = fk.getColumns();
        for (var i=0; i<cols.length; i++) {
            col = cols[i];
            if (col.isPKElement()) {
                fk.setMandatory(true);
            }
        }
        log_fks_to_mandatory += 1;
        fk.setMandatory(true);
        table.setDirty(true);
    }
    app_view.logMessage("--- " + log_fks_to_mandatory + "/" + fks.length + " foreign keys set to mandatory");
    table.setDirty(true);

    // Updated columns: now we should have no repetition in columns so we can remove numbers from names
    updated_cols = table.getElements();
    for (var i = 0; i < updated_cols.length; i++) {
        col = updated_cols[i];
        removeNumbersfromColumns(col);
    }
    table.setDirty(true);

    // Amend domain of primary concept:
    // Check if domain with these members already exist, otherwise set it to Unknown and print expected members
    
    if (excluded_to_amend_domains.contains(primary_concept)) {
           app_view.logMessage("--- Primary concept column " + primary_concept + " will not be amended (included in other script)");
    } else {
           primary_concept_column = table.getElementByName(primary_concept);
           matching_domain = getMatchingDomain(primary_concept_column, primary_concept_domain);
        app_view.logMessage("--- Primary concept column " + primary_concept + " amended");
        app_view.logMessage("----- New domain allowed values: " + primary_concept_domain);
        if (!matching_domain) {
               app_view.logMessage("------- No match");
               new_domain = createDomain(primary_concept_domain);
               primary_concept_column.setDomain(new_domain);
        }
    }
    table.setDirty(true);
    app_view.logMessage("--- " + log_cols_replaced_by_primary_concept.length + "/" + columns.length + " columns replaced by a primary concept");
    app_view.logMessage("----- Columns replaced by primary concept: " + log_cols_replaced_by_primary_concept);
    app_view.logMessage("--- " + log_related_tables_amended + "/" + log_related_tables + " related tables amended");
}]]>
		</script>
	</scr>
	<scr id="206237BE-D0FA-B7F9-79F0-83D6DDCC2195" name="10. Merge one-to-one relationships" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME: Merge one-to-one relationships
 *  PURPOSE:   
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run after optional one-to-one relationships
 *  DYNAMIC: merge_derived_entities
 *  SHORT DESCRIPTION: copies columns from Tables with one one-to-one relationship to target table and removes source Table
*/

// ---- INPUT PARAMETERS ----
merge_derived_entities = true;
is_preferred_abbreviation = true;
script_name = "Merge one-to-one relationships";

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

rel_model = model;
tables = model.getTableSet().toArray();
log_tables_deleted = new java.util.ArrayList();
log_cols_moved = 0;
for (var t = 0; t < tables.length; t++){
    table = tables[t];
    tname = table.getName();
    is_derived = tname.contains("DRVD") || tname.contains("derived") || tname.contains("Derived");
    if (merge_derived_entities==true || (merge_derived_entities==false && is_derived==false)) {
        entity = table.getEngEntity();
        num_of_relations = table.getFKAssociations().length;
        relations = entity.getRelations();
        if (relations.length==1 || is_derived) {
            //is_identifying = relations[0].isIdentifying();
            is_identifying = true;
            is_one_to_one = false;
            // If exactly one relationship is one to one, we merge it
            is_hier_entity = entity.isHierarchicalEntityType();
            is_one_to_one = relations[0].isOneToOne();
            
            if (num_of_relations==1 && is_identifying && is_one_to_one && !is_hier_entity) {
            	attr_fold_map = new java.util.HashMap();
                fk = table.getFKAssociations()[0];
                target_table = fk.getRemoteTable();
                columns = table.getElements();
                app_view.logMessage("- Table " + tname + " merged into table " + target_table.getName());
                // Copy columns from table to target and remove table
                log_merged_columns = new java.util.ArrayList();
                for (var i = 0; i < columns.length; i++) {
                    column = columns[i];
                    if (column.isFKColumn()==false) {
                    	attr = column.getEngAttribute();
	                    log_merged_columns.add(column.getName());
	                    col = target_table.createColumn();
	                    column.copy(col);
	                    createMappingForAttrAndOverlapping(rel_model, attr_fold_map, attr, col);
	                    
	                    //if (is_derived){
	                    //	if (is_preferred_abbreviation) {
	                    //		new_name = "DRVD_" + col.getName();
	                    //	} else {
	                    //		new_name = "Derived_" + col.getName();
	                    //	}
	                    //	
	                    //	col.setName(new_name)        
	                    //}
	                    target_table.setDirty(true);
                    } else {
                        
                        attr = column.getEngAttribute();
                        orig_col = column.	getReferencedColumn();
                        app_view.logMessage("Merging fk " + attr.getName() + " into " + orig_col);
                        createMappingForAttrAndOverlapping(rel_model, attr_fold_map, attr, orig_col);
                    } 
                }
                log_cols_moved += columns.length;
                app_view.logMessage("--- " + log_merged_columns.length + "/" + columns.length + " columns moved");
                app_view.logMessage("--- Columns moved: " + log_merged_columns);
                target_table.setDirty(true);
                log_tables_deleted.add(tname);
                rel_model.getRMExtendedMap().createMapping(entity, target_table);
			 app_view.logMessage("------- Created mapping from entity " + entity.getName() + " to table " + target_table.getName());
                table.remove();
            }
        }
    }
}
rel_model.setDirty(true);
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_tables_deleted.length + "/" + tables.length + " tables deleted");
app_view.logMessage("- " + log_cols_moved + " columns moved");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");


function createMappingForAttrAndOverlapping(relational_model, attr_fold_map, attribute, column) {
    f_attr_name = attribute.getName();
    folded = attr_fold_map.get(attribute);
    relational_model.getRMExtendedMap().createMapping(attribute, column);
    app_view.logMessage("------- Created mapping from attribute " + attribute + " to column " + column);
    if (folded != null) {
        relational_model.getRMExtendedMap().createMapping(folded, column);
        app_view.logMessage("------- Created mapping from attribute " + folded.getName() + " to column " + column.getName());
    }
}]]>
		</script>
	</scr>
	<scr id="AB58D57D-DE40-A3BB-AE77-2DC54A6674C5" name="6. Remove unique constraints" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME: Remove unique constraints
 *  PURPOSE: when wrapping up, primary keys of subtypes are converted into unique constraints which do not hold anymore
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run after entity role, before generalisation
 *  DYNAMIC: 
 *  SHORT DESCRIPTION: removes unique constraints on Tables and indexes, which are not used by any constraint
*/

// ---- INPUT PARAMETERS ----
script_name = "Remove unique constraints";

// ---- SCRIPT ----
var app_view = model.getAppView();
tables = model.getTableSet().toArray();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");
log_tables_amended = 0;
log_total_const_removed = 0;
for (var g=0; g<tables.length; g++) {
    table = tables[g];
    table_name = table.getName();
    keys = table.getKeys();
    log_is_amended = false;
    log_const_removed = 0;
    for (var i=0; i<keys.length; i++) {
        index = keys[i];
        // Indexes, by default if not changed, have state Unique Plain Index
        state = index.getIndexState();
        if (state=="Unique Plain Index" || (index.isPK()==false && index.isUnique()==true && index.isFK()==false)) {
            log_is_amended = true;
            index.remove();
            table.setDirty(true);
            log_const_removed += 1;
            log_total_const_removed += 1;
        }
    }
    if (log_is_amended) {
        log_tables_amended += 1;
        app_view.logMessage("- Table " + table_name + " amended");
        app_view.logMessage("--- " + log_const_removed + "/" + keys.length + " unique constraints removed");
    }
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_tables_amended + "/" + tables.length + " tables amended");
app_view.logMessage("- " + log_total_const_removed + " unique constraints deleted");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="D29378AF-543A-AD4B-4EBF-75CE9E61FAA3" name="9. Reduce discriminators" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Reduce discriminators
 *  PURPOSE: In subtyping, disciminators are present for every level of hierarchy. 
 *           This script is run in case we don't want all discriminitors present
 *           in the target wrap up Entity but only one, which contains hierarchical leaves as members of its domain. 
 *           In case of disjoint subtyping, additional discriminator remains present.
 *           When we wrap down to the leaf of the hierarchy, creation of new discriminator is ignored, we only need to remove all
 *           discriminators which were passed down.
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run last
 *  DYNAMIC: Its use is optional.
 *           Provided is a list of discriminators which we do not want to merge (from disjoint subtypes).    
 *           Manually added maps of members to Entities. 
 *           Entity role and Abstract instrument role tables are excluded.
 *  SHORT DESCRIPTION: Removes lower level discriminators and creates a new one with TYP_<table_name> code. 
 *                     When a discriminator is a primary key, the new discriminator needs to be set to primary key.    
 *                     If the table with changed primary has relationships, they need to be changed to a new column.
 *                     Foreign key discriminators need to be ignored.
 *                    
 *                     In Logging page messages are seen, there are two types for every supertype:    
 *                     1. """No matching domain for discriminator of table table_name found.
 *                    Expected members: leaves_names_list
 *                      Expected sdd domain: table_name + type"""
 *                    2.  """Matching domain for discriminator of table table_name found:
 *                         domain_name""" 
 *                    In the case of first message, new sdd subdomain needs to be created. 
 *                     
*/

// ----INPUT PARAMETERS----
var is_preferred_abbreviation = true;
script_name = "Reduce discriminators";

// ----SCRIPT----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

// Discriminators which belong to disjoint subtype
discriminators_not_merged = new java.util.ArrayList(["ORGNSTN_TYP_BY_PRCDNG_STTS",
                                           "Organisation_type_by_legal_proceeding_status",    
                                           "INSTRMNT_TYP_ORGN",
                                           "Instrument_type_by_origin",
                                           "SCRTY_TYP_BY_IDNTFR",
                                           "Security_type_by_identifier",
                                           "SCRTY_BRRWNG_LNDNG_TRNSCTN_CMPNNT_TYP_BY_DRCTN",
                                           "Security_borrowing_and_lending_transaction_component_type_by_direction",
                                           "RTNG_SYSTM_TYP_BY_NTR",
                                           "Rating_system_type_by_nature_(Grade_vs._Numeric)",
                                           // Financial asset instrument
                                           "Financial_asset_instrument_type_by_CRR,_Article_123_(Retail_exposure)",
                                           "FNNCL_ASST_INSTRMNT_TYP_CRR_123",
                                           "Financial_asset_instrument_type_by_interest_rate_only",
                                           "FNNCL_ASST_INSTRMNT_TYP_INTRST_RT_ONL",
                                           "Financial_asset_instrument_type_by_fixed_interest_rate",
                                           "FNNCL_ASST_INSTRMNT_TYP_FXD_INTRST_RT",
                                           "Financial_asset_instrument_type_by_renegotiation_status",
                                           "FNNCL_ASST_INSTRMNT_TYP_RNGTTN_STTS",
                                           "Abstract_instrument_role_type",
                                           "ABSTRCT_INSTRMNT_RL_TYP",
                                           "PRTY_TYP_ADDRS",
                                           "Party_type_by_address"
                                           ]);

                                           
excluded_tables = new java.util.ArrayList(["ENTTY_RL",
                                           "Entity_role",
                                           ]);
excluded_columns = new java.util.ArrayList(["ABSTRCT_INSTRMNT_RL_TYP",
                                           "Abstract_instrument_role_type",
                                           "ACCNTNG_CLSSFCTN_TYP",
                                           "Accounting_classification_type",
                                           "FRBRNC_MSR_TYP",
                                           "Forbearance_measure_type",
                                           "IDNTFR_TYP",
                                           "Identifier_type",
                                           "PRDNTL_PRTFL_TYP",
                                           "Prudential_portfolio_type"
                                           ]);
columns_to_remove = new java.util.ArrayList(["OTC_DRVTV_RL_TYP",
                                            "Over_the_counter_(OTC)_derivative_role_type",
                                            "Collateral_received_Instrument_role_type",
                                            "CLLTRL_RCVD_INSTRMNT_RL_TYP"
                                            ]);

log_num_discriminators_not_merged = discriminators_not_merged.length/2;
log_num_excluded_tables = excluded_tables.length/2;
app_view.logMessage("-" + log_num_discriminators_not_merged + " discriminators not merged");
app_view.logMessage("-" + log_num_excluded_tables + " tables excluded");                                       

// Prepare Entity Member map
rel_model = model;
entity_member_map = mapEntitiesToMembers();
entity_member_map_keys = entity_member_map.keySet().toArray();
tables = model.getTableSet().toArray();
var entity_name_entity_map = getEntityNameEntityMap();
log_tables_affected = 0;
log_total_disc_removed = 0;
log_total_disc = 0;
for (var t=0; t<tables.length; t++) { 
    table = tables[t];
    table_name = table.getName();
    dicriminator_pk = null;
    if (!excluded_tables.contains(table_name)) {
        disjoint_domain_member_names_all = new java.util.ArrayList();
        main_entity = table.getEngEntity();
        //app_view.logMessage("Ent: " + main_entity.getName());
        is_hier = main_entity.isHierarchicalEntityType();
        is_root = main_entity.isHierarchicalRoot();
        is_leaf = main_entity.getHierarchicalChildrenCount()==0;
       
        // Get all current discriminator columns: they have _TYP in the name
        num_levels = 1;
        columns = table.getElements();
        discriminators_to_remove = new java.util.ArrayList();
        new_discriminators = new java.util.ArrayList();
        app_view.logMessage("- Table " + table_name + " considered");
        //app_view.logMessage(main_entity.getHierarchicalChildren());
        //app_view.logMessage("Hier: " + is_hier + " Root:" + is_root + " Leaf: " + is_leaf); 
        attrs_to_map = new java.util.HashMap();
        disjoint__all_children_discriminators = new java.util.ArrayList(); // all but leaves
        for (var i=0; i<columns.length; i++) {
            col = columns[i];
            col_name = col.getName();
            is_fk = col.isFKColumn();
            if ((col_name.contains("_TYP") || col_name.contains("_type")) && !discriminators_not_merged.contains(col_name) && !is_fk && !excluded_columns.contains(col_name)) {
                discriminators_to_remove.add(col);
                num_levels += 1;
                if (col_name.contains("_TYP") || col_name.contains("_type")) {
                    log_total_disc += 1;
                }
            }
            if (is_hier && num_levels==3) {
                log_tables_affected += 1;
            }

            // If Table has disjoint subtyping, create a list of members of the domain of all disjoint discriminators 
            if (discriminators_not_merged.contains(col_name) && !excluded_columns.contains(col_name)) {
                 disjoint_domain_member_names = new java.util.ArrayList();
                app_view.logMessage("--- Column " + col_name + " is a disjoint discriminator");
                new_discriminators.add(col);
                // Get the domain of disjoint discriminator. Get members
                disjoint_domain = col.getDomain();
                domain_name = disjoint_domain.getName();
                disjoint_list_of_values = disjoint_domain.getValueList();
                member_map = disjoint_list_of_values.getValuesDescriptionMap();
                m = member_map.keySet().toArray();
                for (var k=0; k<m.length; k++) {
                    member_code = m[k];
                    description = member_map.get(member_code);
                    member_name = description.split(":")[0];
                    member = member_code + ": " + member_name;
                    disjoint_domain_member_names.add(member);
                }
                // Find Entities that are mapped to these members
                disjoint_child_entities = new java.util.ArrayList();
                for (var k=0; k<disjoint_domain_member_names.length; k++) {
                    member_name = disjoint_domain_member_names[k]; // code: member name
                    // Get entities from member names
                    for (var l=0; l<entity_member_map_keys.length; l++) {
                        candidate_ent_key = entity_member_map_keys[l]; // Entity name
                        candidate_ent = entity_member_map[candidate_ent_key]; // code: member name
                        memb = entity_member_map[candidate_ent_key].split(" | ")[1];
                        if (memb==member_name) {
                            disjoint_child_entities.add(candidate_ent_key);
                            break;
                        }
                    }
                }
                // Get leaves of these members (children). Merge lists of leaves
                // Now we have a list of child entity names. From them, we need to get their leaf entities
                disjoint_child_entities_leaves = new java.util.ArrayList();
                
                // Merge leaves from all dijoint children
                target_cols = new java.util.ArrayList();
                for (var k=0; k<disjoint_child_entities.length; k++) {
                    child_name = disjoint_child_entities[k]; // Entity name
                    // If child has no children it is a leaf
                    child = entity_name_entity_map.get(child_name);
                    num_grandchildren = child.getHierarchicalChildrenCount();
                    if (num_grandchildren==0) {
                        disjoint_child_entities_leaves.add(child);
                    } else {
                        disj_leaves = child.getHierarchicalLeaves();                        
                        disjoint_child_entities_leaves.addAll(disj_leaves);
                        //disjoint__all_children_entities.add(child);
                        // find driminators to be merged into disjoint column
                        disjoint_cols = child.getElements();
                        for (var c=0; c<disjoint_cols.length; c++) {
                            col2 = disjoint_cols[c];
                            app_view.logMessage(col2);
                            
                            is_fk2 = col2.isFKAttribute();
                            target_col2 = col2.getEngColumn(rel_model, table);
                            col2_name = target_col2.getName();
                            if ((col2_name.contains("_TYP") || col2_name.contains("_type")) && !discriminators_not_merged.contains(col2_name) && !is_fk2 && !excluded_columns.contains(col2_name)) {
                                disjoint__all_children_discriminators.add(col2_name);
                                target_cols.add(col2)
                            }
                        }
                    }

                }
                attrs_to_map.put(col, target_cols);
                // Map leaf entites to members. Check against existing domains.
                // Find expected members of the domain
                disj_leaves_member_list = new java.util.HashSet();
                for (var j=0; j<disjoint_child_entities_leaves.length; j++) {
                    leaf = disjoint_child_entities_leaves[j];
                    leaf_entity_name = leaf.getName();
                    // remove domain name, we compare actual members 
                    if (entity_member_map.containsKey(leaf_entity_name)) {
                    	mapped_entity = entity_member_map.get(leaf_entity_name);
                        // Remove domain name, we compare actual members 
                       mapped_entity_member = mapped_entity.split(" | ")[1];
                       if (!disj_leaves_member_list.contains(mapped_entity_member)) {
                           disj_leaves_member_list.add(mapped_entity_member);
                       }
                    } else {
                    	app_view.logMessage("ERROR: Map entity " + leaf_entity_name);
                    }

                }
                // Maybe add Not applicable
                add_not_applicable = addNotApplicable(col);
                if (add_not_applicable) {
                    disj_leaves_member_list.add("0: Not applicable");
                }
                disjoint_domain_member_names_all.addAll(disj_leaves_member_list);
                // Find matching domain
                matching_domain_found = getMatchingDomain(col, disj_leaves_member_list);
                if (!matching_domain_found) {
                    app_view.logMessage("----- Allowed values: " + disj_leaves_member_list);
                    app_view.logMessage("----- No matching domain found.");
                    new_domain = createDomain(disj_leaves_member_list);
                    col.setDomain(new_domain);
                }
            }
        } // Status: updated disjoint discriminators domains, list disjoint_domain_member_names_all contains all members from these discriminators
        
        // If table is not a leaf of the hierarhy, change descriminator columns
        if (is_hier && num_levels>2) {
            is_pk = false;
            // Remove lower level discriminators
            // Mark if one of them is a primary key
            target_cols = new java.util.ArrayList();
            for (var i=0; i<discriminators_to_remove.length; i++) {
                col = discriminators_to_remove[i];
                col_is_pk =  col.isPKElement();
                if (col_is_pk) {
                    is_pk = true;
                    // Find foreign indexes which include this column
                    fk_index = col.getFKIndexAssociation();
                }
                if (!disjoint__all_children_discriminators.contains(col.getName())){
                    // disjoint discriminator
                    // needs to be mapped to the merged disjoint discriminator
                    target_cols.add(col.getEngAttribute());
                }
                col.remove();
            }
            attrs_to_map.put("new_discriminator", target_cols);
            log_total_disc_removed += discriminators_to_remove.length;
            app_view.logMessage("--- " + discriminators_to_remove.length + " discriminators removed");
            app_view.logMessage("--- Discriminators removed: " + discriminators_to_remove);
            // Create new column with leaves of the hierarchy, if it does not exist yet and table is not entity leaf
            dicriminator_pk = null;
            if (!is_leaf) {
                discriminator_name = "TYP_" + table_name;
                if (is_preferred_abbreviation==false) {
                    discriminator_name = "Type_of_" + table_name; 
                }
                if (table.getElementByName(discriminator_name)==null) {
                    granular_discriminator = table.createColumn();
                    granular_discriminator.setName(discriminator_name);
                    granular_discriminator.setMandatory(true);
                    app_view.logMessage("--- Discriminator added: " + discriminator_name);
                    if (is_pk) {
                        pk = table.getPKorUnique();
                        pk.add(granular_discriminator);
                        dicriminator_pk = granular_discriminator;
                        app_view.logMessage("----- Added to primary key constraint");
                        
                    }
                } else {
                    app_view.logMessage("--- Discriminator found: " + discriminator_name);
                    granular_discriminator = table.getElementByName(discriminator_name);
                    if (is_pk) {
                        pk = table.getPKorUnique();
                        pk.add(granular_discriminator);
                        dicriminator_pk = granular_discriminator;
                        app_view.logMessage("----- Added to primary key constraint");
                    }
                }
                new_discriminators.add(granular_discriminator);
                app_view.logMessage("--- New discriminators: " + new_discriminators);

                // Add Mapping information from deleted discriminators to created discriminator
                app_view.logMessage(attrs_to_map);
                target_cols = attrs_to_map.keySet().toArray();
                for (var j=0; j<target_cols.length; j++) {
                	target_col = target_cols[j];
                    source_attrs = attrs_to_map[target_col];
                	for (var t=0; t<source_attrs.length; t++) {
                        if (target_col=="new_discriminator") {
                            rel_model.getRMExtendedMap().createMapping(source_attrs[t], granular_discriminator);
                            addMappingsFromRemovedColumn(rel_model, table, source_attrs[t].getEngColumn(rel_model, table), granular_discriminator);
                            app_view.logMessage("------- Created mapping from attribute " + source_attrs[t].getName() + " to column " + granular_discriminator.getName());
                        } else {
                            rel_model.getRMExtendedMap().createMapping(source_attrs[t], target_col);
                            addMappingsFromRemovedColumn(rel_model, table, source_attrs[t].getEngColumn(rel_model, table), target_col);
                            app_view.logMessage("------- Created mapping from attribute " + source_attrs[t].getName() + " to column " + target_col.getName());
                        
                        }
                    }    
			 	}
			 
                
                // Find leaves of the hierarchy for granular discriminator
                leaves = main_entity.getHierarchicalLeaves();
                app_view.logMessage("Levaes: " + leaves);
                // If we have disjoint subtyping, split leaves into which type of subtyping they belong
                num_of_discriminators = new_discriminators.length
                granular_discriminator_attr = granular_discriminator.getEngAttribute();
                // Find expected members of the domain
                leaves_member_list = new java.util.HashSet();
                for (var j=0; j<leaves.length; j++) {
                    leaf = leaves[j];
                    leaf_entity_name = leaf.getName();
                    if (entity_member_map.containsKey(leaf_entity_name)) {
                    	mapped_entity = entity_member_map.get(leaf_entity_name);
                        // Remove domain name, we compare actual members 
                       mapped_entity_member = mapped_entity.split(" | ")[1];
                       if (!disjoint_domain_member_names_all.contains(mapped_entity_member)) {
                           leaves_member_list.add(mapped_entity_member);
                       }
                    } else {
                    	app_view.logMessage("ERROR: Map entity " + leaf_entity_name);
                    }
                    
                }
                app_view.logMessage("--- Leaves of the discriminator: " + leaves_member_list);
                // Check if a domain with these members exists
                matching_domain_found = getMatchingDomain(granular_discriminator, leaves_member_list); 
                if (!matching_domain_found) { 
                    app_view.logMessage("----- No matching domain found.");
                    new_domain = createDomain(leaves_member_list);
                    granular_discriminator.setDomain(new_domain);
                }
            }
            
        }
    }
    table.setDirty(true);
    // Fix related tables 
    // Delete the removed discriminator and set new foreign key column (granular discriminator) to primary key
    log_related_tables_amended = 0;
    log_related_tables = 0;
    // If discriminator is part of pk
    
    if (dicriminator_pk != null) {
        app_view.logMessage("Disc pk: " + dicriminator_pk.getName());
        for (var s=0; s<tables.length; s++) {
            related_table = tables[s];
            related_entity = related_table.getEngEntity();
            fks = related_table.getFKIndexAssociationsWith(table);
            related_table_name = related_table.getName();
            related_table_columns = related_table.getElements();
            col_to_remove = null;
            new_pk_col = null;
            if (fks.length > 0) {
                app_view.logMessage("------------ Table changed PK. Related table: " + related_table_name);
                // There is a fk between the tables
                // get list of names of discriminators to remove
                discriminators_to_remove_names = new java.util.ArrayList();
                for (var c=0; c<discriminators_to_remove.length; c++) {
                    col = discriminators_to_remove[c];
                    discriminators_to_remove_names.add(col.getName());
                }
                for (var c=0; c<related_table_columns.length; c++) {
                    col = related_table_columns[c];
                    col_n = related_table_columns[c].getName();
                    // Delete removed discriminator
                    if ((discriminators_to_remove_names.contains(col_n) && !excluded_columns.contains(col_n)) || columns_to_remove.contains(col_n)) {
                        app_view.logMessage("------------ Removed: " + col_n);
                        //col.remove();
                        col_to_remove = col;
                    }
                    // Set new discriminator column to pk
                    if (dicriminator_pk.getName() == col_n && !excluded_columns.contains(col_n)) {
                        pk = related_table.getPKorUnique();
                        app_view.logMessage("------------ Put in pk : " + col_n);
                        pk.add(col);
                        new_pk_col = col;
                    }
                }
                addMappingsFromRemovedColumn(rel_model, related_table, col_to_remove, new_pk_col);
                col_to_remove.remove();
                related_table.setDirty(true);
            }
        }
    }
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_total_disc_removed + "/" + log_total_disc + " discriminators removed");
app_view.logMessage("- " + log_tables_affected + "/" + tables.length + " tables affected");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

// ---- FUNCTIONS ----
function mapEntitiesToMembers(){
    /*
    Input: None
    Output: HashMap<String, String>
    Description: Map with key: "entity name", value: "domain name | sdd member code: member name" 
    */ 
    tables = model.getTableSet().toArray();
    entites = model.design.getLogicalDesign().getEntitySet().toArray();
    entity_member_map = new java.util.HashMap();
    no_match = 0;
    // For every entity, find it's parent and check if the entity name is present in members list of discriminator
    for (var i=0; i<entites.length; i++) {
        entity = entites[i];
        entity_name = entity.getName();
        is_hier = entity.isHierarchicalEntityType();
        is_root = entity.isHierarchicalRoot();
        // exclude entities, which are not hierarchial type, and roots
        if (is_hier && !is_root) {
            match = false;
            // Find it's parent and check if the entity name is present in members list of parent
            parent = entity.getHierarchicalParent();
            parent_attrs = parent.getAttributes();
            discriminators = new java.util.ArrayList();
            members = new java.util.ArrayList();
            for (var j=0; j<parent_attrs.length; j++) {
                attr = parent_attrs[j];
                is_discriminator = attr.getName().contains(" type");
                if (is_discriminator) {
                    discriminators.add(attr);
                    domain = attr.getDomain();
                    domain_name = domain.getName();
                    list_of_values = domain.getValueList();
                    if (list_of_values) {
                        member_map = list_of_values.getValuesDescriptionMap();
                        m = member_map.keySet().toArray();
                        for (var k=0; k<m.length; k++) {
                            member_code = m[k];
                            description = member_map.get(member_code);
                            if (domain_name != "Forbearance measure type") {
                                member_name = description.split(":")[0];
                            } else {
                                member_name = description;
                            }
                            member = domain_name + " | " + member_code + ": " + member_name;
                            if (member_name==entity_name || member_name==entity_name + "s") {
                                entity_member_map.put(entity_name, member);
                                match = true;
                                break;
                            }
                            members.add(member);
                        }
                    }
                }
            }
            if (!match) {
                no_match += 1;
                // No member had a matching name
            }
        }
    }
    
    // Members, which need to be mapped manually
    entity_member_map.put("Non-financial asset", "Non-financial asset and non-financial liability type | 1302: Non-financial liabilites");
    entity_member_map.put("Non-financial liability", "Non-financial asset and non-financial liability type | 400: Non-financial assets");
    entity_member_map.put("Asset", "Balance sheet item type | 499: All assets");
    entity_member_map.put("Banking book", "Prudential portfolio | 2: Non-trading book");
    entity_member_map.put("Central counterparty client", "Party role type | 26: Centralcounterpartyclient");
    entity_member_map.put("Credit risk mitigation arragement", "Protection arrangement type | 6: Credit risk mitigation arrangement");
    entity_member_map.put("Currency collateral", "Financial collateral type | 77: Currency");
    entity_member_map.put("Current tax liability", "Tax liability type | 710: Current tax liabilities");
    entity_member_map.put("Deferred tax liability", "Tax liability type | 720: Deferred tax liabilities");
    entity_member_map.put("Deposit collateral", "Financial collateral type | 78: Deposit");
    entity_member_map.put("Deposit taking corporation", "Party role type | 27: Deposittakingcorporation");
    entity_member_map.put("Deposit with agreed maturity", "Other deposit type | 522: Deposits with agreed maturity - other than counterpart liability to non-derecognised loans");
    entity_member_map.put("Financial asset", "Asset type | 40: Financial instruments. Creditor");
    entity_member_map.put("Financial guarantee instrument covering a Debt security", "Financial guarantee instrument type | 13: Financial guarantee instrument for a Debt security");
    entity_member_map.put("Financial guarantee instrument not covering a Debt security", "Financial guarantee instrument type | 14: Financial guarantee instrument not for a Debt security");
    entity_member_map.put("Financial guarantee protection item", "Protection item type | 74: Financial guarantee");
    entity_member_map.put("Financial lease", "Loan type | 80: Finance leases");
    entity_member_map.put("Financial liability", "Liability type | 1100: Financial instruments. Debtor");
    entity_member_map.put("Funds for general banking risk", "Provision type | 701: Provisions. Funds for general banking risks");
    entity_member_map.put("Gold collateral", "Commodity collateral type | 13: Gold");
    entity_member_map.put("Goodwill", "Type of non-financial asset | 420: Intangible assets. Goodwill");
    entity_member_map.put("Graded rating system", "Rating system type by nature (Grade vs. Numeric) type | 5: Graded Rating System");
    entity_member_map.put("International organisation or General government", "Organisation type | 24: International organisation or general government");
    entity_member_map.put("Investment property", "Type of non-financial asset | 413: Tangible assets. Investment property");
    entity_member_map.put("Liability", "Balance sheet item type | 749: All liabilities");
    entity_member_map.put("Loan collateral", "Financial collateral type | 16: Loans");
    entity_member_map.put("Machinery and equipment collateral", "Non-registered collateral type | 85: Machinery and equiptment collateral");
    entity_member_map.put("Non-central government rating system", "Issuer based rating system type | 4: Non-Central government rating system");
    entity_member_map.put("Non-financial liabilty", "Liability type | 1302: Non-financial liabilites");
    entity_member_map.put("Off-balance instrument", "Instrument type by product | 948: Off balance sheet instruments"); 
    entity_member_map.put("Original lender", "Party role type | 21: Originallender");
    entity_member_map.put("Other deposit", "Deposit type | 551: Other deposits not part of minimum reserve system (IMF purposes)");
    entity_member_map.put("Other employee benefit", "Employee benefit type | 702: Provisions. Employee benefits. Other than pension and other post-employment defined benefit obligations");
    entity_member_map.put("Other financial collateral", "Financial collateral type | 72: Other financial protection");
    entity_member_map.put("Other intangible asset", "Type of non-financial asset | 430: Intangible assets other than Goodwill");
    entity_member_map.put("Other non-financial asset", "Type of non-financial asset | 1300: Non-financial assets other than Goodwill, Tax asset, Investment property, Other intangible asset or Property, plant and equipment");
    entity_member_map.put("Other non-financial liability", "Type of non-financial liability or provision | 1301: Non-financial liabilites other than Tax liability, Share capital repayable on demand or Provision");
    entity_member_map.put("Other over the counter (OTC) Derivative instrument", "Over the counter (OTC) Derivative instrument type | 5: Other OTC Derivative instrument");
    entity_member_map.put("Other over the counter (OTC) Swap", "OTC Swap type | 8: Other OTC Swap");
    entity_member_map.put("Other provision", "Provision type | 707: Provisions. Other than Employee benefits, Restructuring, Pending legal issues and tax litigation, Off-balance sheet exposures subject to credit risk");
    entity_member_map.put("Other loans", "Loan type | 1022: Other loans");
    entity_member_map.put("Over the counter (OTC) Credit default swap", "OTC Swap type | 7: OTC Credit default swap");
    entity_member_map.put("Over the counter (OTC) Credit spread option", "OTC Option type | 9: OTC Credit spread option");
    entity_member_map.put("Over the counter (OTC) Forward", "Over the counter (OTC) Derivative instrument type | 380: Forward");
    entity_member_map.put("Over the counter (OTC) Option", "Over the counter (OTC) Derivative instrument type | 390: Option");
    entity_member_map.put("Over the counter (OTC) Option other than Over the counter (OTC) Credit spread option", "OTC Option type | 10: OTC Option other than OTC Credit spread option");
    entity_member_map.put("Over the counter (OTC) Swap", "Over the counter (OTC) Derivative instrument type | 370: Swap");
    entity_member_map.put("Over the counter (OTC) Total return swap", "OTC Swap type | 6: OTC Total return swap");
    entity_member_map.put("Pending legal issues and tax litigation", "Provision type | 705: Provisions. Pending legal issues and tax litigation");
    entity_member_map.put("Pension and other post-employment defined benefit obligation", "Employee benefit type | 703: Provisions. Employee benefits. Pension and other post-employment defined benefit obligations");
    entity_member_map.put("Property, plant and equipment", "Type of non-financial asset | 416: Tangible assets. Property, plant and equipment");
    entity_member_map.put("Protection provider", "Party role type | 24: Protectionprovider");
    entity_member_map.put("Rating grade for issuer based rating system for central government", "Rating grade for issuer based rating systems type | 4: Rating grade for issuer based rating systems for Central government");
    entity_member_map.put("Rating grade for issuer based rating system for non-central government", "Rating grade for issuer based rating systems type | 3: Rating grade for issuer based rating systems for non-Central government");
    entity_member_map.put("Reporting agent internal group role", "Group role type | 1: Reporting agent (group)");
    entity_member_map.put("Restructuring", "Provision type | 704: Provisions. Restructuring");
    entity_member_map.put("Security collateral", "Financial collateral type | 12: Securities");
    entity_member_map.put("Suspense item", "Advance type | 130: Suspence items");
    entity_member_map.put("Swap provider", "Party role type | 23: Swapprovider");
    entity_member_map.put("Tax liability", "Type of non-financial liability or provision | 721: Tax liabilities");
    entity_member_map.put("Traditional securitisation", "Securitisation type | 1: Traditional securititsation");
    entity_member_map.put("Transferable deposit", "Overnight deposit type | 511: Tranferable deposit");
    entity_member_map.put("Other overnight deposit", "Overnight deposit type | 512: Other overnight deposits");
    entity_member_map.put("Subsidiary (of the reporting agent)", "Other organisation role type | 30: Subsidiary");
    entity_member_map.put("Joint venture (of the reporting agent)", "Other organisation role type | 31: Joint venture");
    entity_member_map.put("Associate (of the reporting agent)", "Other organisation role type | 32: Associate");
    entity_member_map.put("Trade receivable collateral", "Financial collateral type | 17: Trade receivables");
    entity_member_map.put("Life insurance policy pledged collateral", "Financial collateral type | 2: Life insurance policies pledged");
    
    
    //app_view.logMessage("No match: " + no_match);
    return entity_member_map
}

function getMatchingDomain(granular_discriminator, leaves_member_list) {
     /*
    Input: Column, HashSet
    Output: Bool
    Description: Goes through all domains and checks if there exists one with matching values (sdd members) from leaves_member_list.
                 If found, assined to granular_discriminator.
                 Returns bool, mathcing domain found or not.
    */
    domains = model.design.getDomainSet().toArray();
    matching_domain_found = false;
    table = granular_discriminator.getTable();
    for (var j=0; j<domains.length; j++) {
        domain = domains[j];
        domain_name = domain.getName();
        list_of_values = domain.getValueList();
        // Check only enumerated domains
        if (list_of_values!=null) {
            domain_member_names = new java.util.HashSet();
            member_map = list_of_values.getValuesDescriptionMap();
            m = member_map.keySet().toArray();
            for (var k=0; k<m.length; k++) {
                member_code = m[k];
                description = member_map.get(member_code);
                member_name = description.split(":")[0];
                member = member_code + ": " + member_name;
                domain_member_names.add(member);
            }
            // Check if this domain has the same members as leaves of the hierarchy
            if (domain_member_names.equals(leaves_member_list)) {
                app_view.logMessage("----- Matching domain found: " + domain_name);
                matching_domain_found = true;
                granular_discriminator.setDomain(domain);
                break;
            }
        }
    }
    table.setDirty(true);
    return matching_domain_found
}


function getUnassignedDomainMemberIndex() {
    /*
    Input: None
    Output: ArrayList
    Description:  Returns a list [domain index, member index] of last unassigned member or domain
    */
    domains = model.design.getDomainSet().toArray();
    domain_index = 0;
    member_index = 0;
    starting_indexes = new java.util.ArrayList();
    for (i=0; i<domains.length; i++) {
        temp_domain = domains[i];
        domain_name = temp_domain.getName();
        if (domain_name.contains("Unassigned")) {
            candidate_index = parseInt(domain_name.split("_")[2]); // List [Unassigned, domain, index]
            if (candidate_index>domain_index) {
                domain_index = candidate_index;
            }
        }
        domain_value_list = temp_domain.getValueList();
        if (domain_value_list) {
            domain_values = domain_value_list.getValues().toArray();
            for (var j=0; j<domain_values.length; j++) {
                value = domain_values[j];
                if (value.contains("Unassigned")) {
                    code_index = parseInt(value.split("_")[1]);
                    if (code_index>member_index) {
                        member_index = code_index;
                    }
                }
            }
        }
    }
    starting_indexes.add(domain_index);
    starting_indexes.add(member_index);
    return starting_indexes;
}


function createDomain(member_list) {
    /*
    Input: HashSet
    Output: Domain
    Description: Creates a Domain named "Unassigned_domain_<number>" in defaultdomains with constraint enumeration from member_list. 
                 If enumerations (sdd members) are newly created they have a value "Unassigned_<number>". 
    */
    new_domain = null;
    starting_indexes = getUnassignedDomainMemberIndex();
    domain_index = starting_indexes[0] + 1;
    domain_member_index = starting_indexes[1] + 1;
    member_list_array = member_list.toArray();
    if (member_list_array.length>0) {
         new_domain = model.design.createDomain();
         domain_name = "Unassigned_domain_" + domain_index;
        new_domain.setName(domain_name);
        app_view.logMessage("--- Created domain " + new_domain.getName());
        constraint_enumeration = new_domain.createConstraintEnumeration();
        for (i=0; i<member_list_array.length; i++) {
            member = member_list_array[i];
            member_code_des = member.split(": "); // member = "code: name: description"
            if (member_code_des.length>1) {
                member_code = member_code_des[0];
                member_name = member_code_des[1];
            } else {
                member_code = "Unassigned_" + domain_member_index;
                member_name = member;
            }
            constraint_enumeration.add(member_code, member_name);
            domain_member_index += 1;
        }
        new_domain.setValueList(constraint_enumeration);
        // Set Logical data type to String
        lt_string = model.design.getLogicalDatatypeSet().getByName("String");
        new_domain.setLogicalDatatype(lt_string);
        new_domain.setDirty(true);
    }
    return new_domain;
}


function getEntityNameEntityMap() {
    /*
    Input: None
    Output: HashMap<String, Entity>
    Description: Map from entity name to entity object
    */
    enitites = model.design.getLogicalDesign().getEntitySet().toArray();
    entityNameEntityMap = new java.util.HashMap();
    for (var i=0; i<enitites.length; i++) {
        entity = enitites[i];
        entity_name = entity.getName();
        entityNameEntityMap.put(entity_name, entity);
    }
    //app_view.logMessage(entityNameEntityMap);
    return entityNameEntityMap    
}


function addNotApplicable(column){
    /* 
    Input: Column
    Output: HashSet
    Description: Returns a set of members of the column, when Not applicable member is added, and empty set when domain should not be changed.
                 Add member Not applicable to a domain of column according to forward egineering strategy.
                 Only for column from subtypes of table's entity: we do not want to include columns which were "wrapped down".
    */
    attr = column.getEngAttribute();
    is_mandatory = true;
    member_names = new java.util.HashSet();
    if (attr) {
        attr_name = attr.getName();
        entity = attr.getEntity();
        is_hier = entity.isHierarchicalEntityType();
        parent = entity.getHierarchicalParent();
        // Typo in the class definition
        is_ignored = entity.getAttributeInherType()=="All atributes";
        relations = entity.getRelations();
        if (relations.length==1) {
            // Optional relationships need to have added member Not applicable for enumerated domains
            is_optional_relation = relations[0].isOptionalSource();
            is_identifying = relations[0].isIdentifying();
            is_one_to_one = relations[0].isOneToOne();
            if (is_optional_relation && is_identifying && is_one_to_one && !is_ignored) {
                is_mandatory = false;
            }
        }
        if (is_hier && !is_ignored) {
            // Go through the hierarchy, on every level check if it is present also in all siblings
            // If it is missing in at least one, we add Not applicable
            while (parent!=null) {
                children = parent.getHierarchicalChildren().toArray();
                for (var i=0; i<children.length; i++) {
                    child = children[i];
                    attr_match = child.getElementByName(attr_name);
                    if (!attr_match) {
                        is_mandatory = false;
                        parent = null;
                        break;
                    }
                }
                if (parent) {
                    parent = parent.getHierarchicalParent();
                }
            }
        }
    }
    return !is_mandatory;
}

function addMappingsFromRemovedColumn(relational_model, table, column_to_be_removed, target_column) {
    /*
    Input: RelationalModel, Table, Column, Column
    Output: None
    Description: finds existing mappings from column_to_be_removed and copies them to target_column
    */
    maps = table.getMappingsToEntities();
    for (var j=0; j<maps.length; j++) {
        map = maps[j];
		// find source entity
		source_ent = model.design.getLogicalDesign().getEntitySet().getByName(map.getName());
		// find source attributes
		maps_col = column_to_be_removed.getMappingsFor(source_ent);
        if (maps_col.length > 0) {
			for (var m=0; m<maps_col.length; m++) {
				source_attr_name = maps_col[m].getName();
				//app_view.logMessage("-- Source entity: " + map.getName() + ", attribute: " + source_attr_name);
				source_attribute = source_ent.getElementByName(source_attr_name);
                // Add mapping from this attribute to target column
                relational_model.getRMExtendedMap().createMapping(source_attribute, target_column);
				relational_model.setDirty(true);
			}
		}
    }
}]]>
		</script>
	</scr>
	<scr id="B91863B8-0AB9-FE2B-3B95-1AAA4A16D024" name="14. Order columns alphabetically" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Order columns alphabetically
 *  PURPOSE: 
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run previous to last, before Columns order
 *  DYNAMIC: 
 *  SHORT DESCRIPTION: 
*/

// ---- INPUT PARAMETERS ----
script_name = "Order columns alphabetically";

// ---- SCRIPT ----
app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");
tables = model.getTableSet().toArray();
name_list = new java.util.ArrayList();
log_num_tables_amended = 0;
log_tables_amended = new java.util.ArrayList();
for (var t=0; t<tables.length; t++){
    name_list.clear();
    table = tables[t];
    table_name = table.getName();
    cols = table.getElements();
    // Create list with columns
    for (var i=0; i<cols.length; i++) {
        col = cols[i];
        name_list.add(col);
    }
    name_list.sort(ascending_sort);
    ord_cols = name_list.toArray();
    
    for (var n=0; n<ord_cols.length; n++){
        table.moveToIndex(ord_cols[n],n);
    }
    // Prevent reordering from enginnering, can be changed with UI
    table.setAllowColumnReorder(false);
    log_num_tables_amended += 1;
    log_tables_amended.add(table_name);
    table.setDirty(true);
}

app_view.logMessage("- Tables amended: " + log_tables_amended);
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_num_tables_amended + "/" + tables.length + " tables amended");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");


// ---- FUNCTIONS ----
function ascending_sort(a, b){
    var name_a = a.getName().toLowerCase(); 
    var name_b = b.getName().toLowerCase();
    if (name_a < name_b) {
        return -1;
    }
    if (name_a > name_b) {
        return 1;
    }
    return 0;
}]]>
		</script>
	</scr>
	<scr id="A04CF535-A284-D14C-7184-4F5B9747382E" name="15. Remove numbers from column names" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Remove numbers from column names
 *  PURPOSE: When we remove duplicated columns, we did not necessearly choose the one without numbers.
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run last
 *  DYNAMIC: 
 *  SHORT DESCRIPTION: 
*/

// ---- INPUT PARAMETERS ----
script_name = "Remove numbers from column names";

// ---- SCRIPT ----
excluded = new java.util.ArrayList(["FNNCL_ASST_INSTRMNT_TYP_CRR_123", "RTL_EXPSR_ACCRDNG_CRR_INDCTR", "ASST_CLSS_CRR_129"]);
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");
log_tables_amended = 0;
log_num_cols_amended = 0;
log_total_cols = 0;

tables = model.getTableSet().toArray();
for (var i=0; i<tables.length; i++) {
    table = tables[i];
    table_name = table.getName();
    cols = table.getElements();
    log_is_amended = false;
    log_columns_amended = new java.util.ArrayList();
    log_total_cols += cols.length;
    for (var j=0; j<cols.length; j++) {
        col = cols[j];
        attr = col.getEngAttribute();
        if (attr != null && !excluded.contains(attr.getPreferredAbbreviation())) {
	        change = removeNumbersfromColumns(col);
	        if (change == true) {
	            log_columns_amended.add(col.getName());
	            log_is_amended = true;
	            log_num_cols_amended += 1;
	        }
        }
    }
    if (log_is_amended) {
        app_view.logMessage("- Table " + table_name + " amended");
        app_view.logMessage("--- " + log_columns_amended.length + "/" + cols.length + " column names changed");
        app_view.logMessage("--- Columns amended: " + log_columns_amended);
        log_tables_amended += 1;
    }
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_tables_amended + "/" + tables.length + " tables amended");
app_view.logMessage("- " + log_num_cols_amended + "/" + log_total_cols + " columns amended");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");


// ---- FUNCTIONS ----
function removeNumbersfromColumns(column) {
    /*
    Input: Column
    Output: Bool
    Description: Removes numbers from column names and returns a boolean whether or not the name was changed.
    */
    table =  column.getTable();
    col_name = column.getName();
    attr = column.getEngAttribute();
    skip = false;
    if (attr) {
        fe_name = attr.getPreferredAbbreviation();
        skip = fe_name.matches(".*\\d.*");
    }
    if (skip==false) {
        new_name = col_name.replaceAll("[0-9]", "");
        column.setName(new_name);
        table.setDirty(true);
    }
    if (col_name != column.getName()) {
        change = true;
    } else {
        change = false;
    }
    return change;
}]]>
		</script>
	</scr>
	<scr id="D7141595-4CFD-02D0-64E8-4D9F53FB70A7" name="8. Remove duplicated relationships" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Remove duplicated relationships
 *  PURPOSE: when wrapping up, relationships which were defined on subtypes are now moved to the supertype and can be duplicated  
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run after Generalisation
 *  DYNAMIC: EXCLUDED list
 *  SHORT DESCRIPTION: removes duplicated relationships and their associated columns
*/

// TODO: excluded -> check if entity had duplicated relationship, in that case keep the relationship

// ---- INPUT PARAMETERS ----
script_name = "Remove duplicated relationships";

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");
log_num_tables_amended = 0;
log_total_num_fks_removed = 0;
log_total_num_fks = 0;
tables = model.getTableSet().toArray();
// Exclude Entitites, which have duplicated relationships
excluded = new java.util.ArrayList(["FNNCL_ASST_INSTRMNT_RL", 
							 "Financial_asset_instrument_role",
                                    "LNKD_ENTRPRS", 
                                    "Linked_enterprise",
                                    "PRTNR_ENTRPRS",
                                    "Partner_enterprise", 
                                    "JNT_CNTRPRTY_LGL_PRSN_ASSGNMNT",
                                    "Joint_counterparty_Legal_person_assignment", 
                                    "EXCHNG_TRDBL_DRVTV_PSTN",
                                    "Exchange_tradable_derivative_position",
                                    "FNNCL_ASST_INSTRMNT_CLLTRL_RCVD_INSTRMNT_ASSGNMNT",
                                    "Financial_asset_instrument_Collateral_received_instrument_assignment",
                                    "IMMDT_PRNT",
                                    "Immediate_parent",
                                    "Party",
                                    "PRTY"
                                    ]);

for (var t=0; t<tables.length; t++){
    table = tables[t];
    tname = table.getName();
    entity = table.getEngEntity();
    log_is_amended = false;
    log_fks_removed_tables = new java.util.HashSet();
    log_num_fks_removed = 0;
    // Check if table is supposed to have duplicated relationship
    // TODO: Either the entity had duplicated relationship, or it is a relationship between two subtypes
    if (excluded.contains(tname)==false) {
        // Find all foreign keys
        table_relations = table.getFKAssociationsList();
        // Find relationships with same target table
        log_total_num_fks += table_relations.length;
        for (var i=0; i<table_relations.length; i++) {
            rel  = table_relations[i];
            source_table = rel.getRemoteTable();
            for (var j=i+1; j<table_relations.length; j++) {
                rel2 = table_relations[j];
                source_table2 = rel2.getRemoteTable();
                if (source_table.getName()==source_table2.getName()) {
                    cols = rel2.getColumns();
                    // Remove others
                    entity = table.getEngEntity();
                    is_hierarchy = entity.isHierarchicalEntityType();
                    is_root = entity.isHierarchicalRoot();
                    no_pk = entity.isCreateSurrogateKey();
                    log_is_amended = true;
                    log_fks_removed_tables.add(source_table.getName());
                    log_num_fks_removed += 1;
                    if (!is_hierarchy && !is_root && !no_pk) {
                        for (var k=0; k<cols.length; k++) {
                            col = cols[k];
                            col.remove();
                            table.setDirty(true);
                            source_table2.setDirty(true);
                        }
                    }
                    // !! Idea: remove empty foreign keys!!
                    log_total_num_fks_removed += 1;
                    rel2.remove();
                    table.setDirty(true);
                    source_table2.setDirty(true);
                }
            }
            table.setDirty(true);
        }
        if (log_is_amended) {
            log_num_tables_amended += 1;
            app_view.logMessage("- Table " + tname + " amended");
            app_view.logMessage("--- " + log_num_fks_removed + "/" + table_relations.length + " foreign keys removed");
            app_view.logMessage("--- Removed foreign keys with: " + log_fks_removed_tables);
       }
    }
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_num_tables_amended + "/" + tables.length + " tables amended");
app_view.logMessage("- " + log_total_num_fks_removed + "/" + log_total_num_fks + " foreign keys removed");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="9D3ADD5D-1408-0957-F7A0-DEBCB96128BE" name="2. Replace foreign key on folded columns" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME: Replace foreign key on folded columns
 *  PURPOSE: All main Entities from each of the classification types are related to the Context Entity. 
 *           In case of assignments between Entities from different classification types, we get two columns from the Context Entity 
 *           (Party Refernce date and Instrument reference date).
 *           These two should be merged into one and this is the reason we use feature of folding the overlapping attributes, 
 *           meaning after forward engineering into a relational model,
 *           We end up with only one column (either Party Refernce date or Instrument reference date).
 *           When we change foreign key index in Entity role and Abstract instrument role script, 
 *           we do not take into account that some columns are not existing anymore, because they were folded.
 *           This script amends the foreign key constraint to replace the missing columns with the columns we folded in. 
 *  OBJECT: applied on relational data model
 *  REQUIREMENTS: run after Generalisation
 *  DYNAMIC: 
 *  SHORT DESCRIPTION: Goes through the tables and checks if all foreign key constraints are complete.
 *                     If not, finds attributes which were folded and puts the respective columns into the foreign key index.
 *                     Changes the name of the column to reflet the originating attribute.
*/

// ---- INPUT PARAMETERS ----
script_name = "Replace foreign key on folded columns";
is_preferred_abbreviation = true;

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");
log_tables_affected = 0;
log_fks_amended = 0;

relational_model = model;
tables = model.getTableSet().toArray();
for (var t=0; t<tables.length; t++) {
    table = tables[t];
    table_name = table.getName();
    ent = table.getEngEntity();
    app_view.logMessage("- Analyzing entity hierarchy " + ent.getName());
    log_table_is_affected = false;
    fks = table.getFKAssociationsList();
    columns = table.getElements();
    // Find all overlapping attributes of the entitie's hierarchy
    folded_attrs_list = getOverlappingAttributesOfHierarchy(ent);
    attributes_to_replace = folded_attrs_list[0];
    attr_fold_map = folded_attrs_list[1]; // {attr taget: attr to replace}
    for (var i=0; i<fks.length; i++) {
        log_connected_cols = new java.util.ArrayList();
        fk = fks[i];
        fk_cols_names = new java.util.ArrayList();
        fk_cols_map = new java.util.HashMap();
        fk_cols = fk.getColumns();
        for (var f=0; f<fk_cols.length; f++) {
            fk_cols_names.add(fk_cols[f].getName());
            fk_cols_map.put(fk_cols[f].getName(), fk_cols[f])
        }
        //app_view.logMessage(fk_cols);
        ref_index = fk.getRemoteIndex();
        ref_table_cols = ref_index.getColumns();
        // Check if foreign key constraint is not complete anymore (because of overlapping attributes)
        if (fk_cols.length != ref_table_cols.length) {
            fake_index = table.createIndex();
            app_view.logMessage("- Table " + table_name + " amended");
            app_view.logMessage("--- Foreign key constraint is not complete");        
            log_fks_amended += 1;
            log_table_is_affected = true;
            // Here we need to find the target attribute into which we fold another attribute 
            // Find overlapping attributes of this table's entity
            
            app_view.logMessage("----- Folded originating attributes: " + attributes_to_replace);
            // Go over referenced columns to find which are to be replaced
            for (var j=0; j<ref_table_cols.length; j++) {
                ref_col = ref_table_cols[j];
                ref_col_name = ref_col.getName();
                ref_col_attr = ref_col.getEngAttribute();
                ref_col_orign_attr = ref_col_attr.getOriginatingAttribute();
                compatible_cols = fk.getCompatibleColumns(ref_col);
                compatible_cols_names = new java.util.ArrayList();
                for (var f=0; f<compatible_cols.length; f++) {
                    compatible_cols_names.add(compatible_cols[f].getName());
                }

                ref_attr_name = ref_col.getEngAttribute();
                ref_col_name_repl = ref_col_name.replaceAll("[0-9]", "");
                
                intersect = 0;
                col_match = null;
                app_view.logMessage("Ref col: " + ref_col_name);
                for (var c=0; c<fk_cols.length; c++) {
                    fk_col = fk_cols[c];
                    //compatible_col_name_repl = fk_col.getName().replaceAll("[0-9]", "");
                    originating_col = fk_col.getOriginatingColumn().getName();
                    ref_originating_col = ref_col.getOriginatingColumn();
                    if (ref_originating_col != null) {
                    	ref_originating_col = ref_originating_col.getName();          
                    }
                    if (originating_col == ref_col_name || originating_col == ref_originating_col) {   
                        // Column was already a part of the foreign key
                        // just connect this one
                        col_match = fk_col;
                        app_view.logMessage("Match found withing fks: " + col_match.getName());
                        fake_index.add(col_match);
                        log_connected_cols.add(col_match);
                        createMappingForAttrAndOverlapping(relational_model, attr_fold_map, col_match.getEngAttribute(), col_match)
                    }
                }
                if (col_match == null) {
                    for (var k=0; k<compatible_cols.length; k++) {
                        compatible_col = compatible_cols[k];
                        compatible_col_name_repl = compatible_col.getName().replaceAll("[0-9]", "");
    
                        if ((ref_col_name_repl.contains(compatible_col_name_repl) || compatible_col_name_repl.contains(ref_col_name_repl) || (ref_col_name_repl.contains("company_Party_identifier") && table_name.contains("enterprise_assignment") && compatible_col_name_repl.contains("Party_identifier"))) && !(compatible_col.getName().contains("CNTR_BNK_PRVT_SCTR_CMPNY_PRTY_ID") || compatible_col.getName().contains("Central_bank_and_private_sector_company_Party_identifier") || compatible_col.getName().contains("IMMDT_PRNT_CNTRL_BNK_PRVT_SCTR_CMPNY_PRTY_ID"))) {
                            col_match = compatible_col;
                            break;
                        }
                        compatible_attr = compatible_col.getEngAttribute();
                        compatible_attr_list = compatible_attr.getPreferredAbbreviation().replaceAll("[0-9]", "").split("_");
                        ref_attr_list = ref_attr_name.getPreferredAbbreviation().replaceAll("[0-9]", "").split("_");
                        
                        new_intersect = 0;
                        for (var s=0; s<compatible_attr_list.length; s++) {
                            if (ref_attr_list.indexOf(compatible_attr_list[s]) !== -1) {
                                new_intersect = new_intersect + 1;
                            }
                        }
                        if (col_match == null && (new_intersect > intersect  && !(compatible_col.getName().contains("CNTR_BNK_PRVT_SCTR_CMPNY_PRTY_ID") || compatible_col.getName().contains("Central_bank_and_private_sector_company_Party_identifier") || compatible_col.getName().contains("IMMDT_PRNT_CNTRL_BNK_PRVT_SCTR_CMPNY_PRTY_ID") || compatible_col.getName().contains("Central_bank_and_private_sector_company_Party_identifier")))){                           
                                intersect = new_intersect;
                                col_match = compatible_col;
                            
                        }
                    }
                    app_view.logMessage("Match: " + col_match.getName());
                    fake_index.add(col_match);
                    log_connected_cols.add(ref_col_name);
                    createMappingForAttrAndOverlapping(relational_model, attr_fold_map, ref_col.getEngAttribute(), col_match)
                }
                
                
                

            }
            fake_index_cols = fake_index.getColumns();
            fk.changeKeyObject(ref_index, fake_index_cols);
            fake_index.remove();
            app_view.logMessage("----- New foreign key: " + fake_index_cols + " on " + log_connected_cols);
        }
        table.setDirty(true);
    }
    if (log_table_is_affected) {
        log_tables_affected += 1;
    }
    // Rename columns into originating column names 
    for (var i=0; i<columns.length; i++) {
        column = columns[i];
        attr = column.getEngAttribute();
        if (attr != null) {
        	   attr_orig = attr.getOriginatingAttribute();
        	   if (attr_orig != null) {
        	   	  attr_orig_name = attr_orig.getName();
	            col_orign_name = getFEName(attr_orig, is_preferred_abbreviation);
	             // Check if column was an overlapping attribute
	            if (attributes_to_replace.contains(attr_orig_name)) {
	                column.setName(col_orign_name);
	                //app_view.logMessage("Renaming column " + attr_orig_name + " into " + col_orign_name);
	            }
	        }
        }
    }
    table.setDirty(true);
}

// FUNCTIONS
function getHierarchicalTree(entity) {
	leaves = entity.getHierarchicalLeaves();
	hierarchy_tree = new java.util.HashSet();
	hierarchy_tree.add(entity);
	if (entity.isHierarchicalEntityType()) {
		for (var i=0; i<leaves.length; i++) {
			leaf = leaves[i];
			hierarchy_tree.add(leaf);
			parent = leaf.getHierarchicalParent();
			is_downwrapped = parent.getAttributeInherType()=='All atributes';
			// Igore the ones that are downwrapped
			if (!is_downwrapped) {
				while (parent.getName() != entity.getName()) {
					hierarchy_tree.add(parent);
					parent = parent.getHierarchicalParent();
				}
			}
		}
	}
	return hierarchy_tree;
}

function getOverlappingAttributesOfHierarchy(entity) {
    hierarchy_tree = getHierarchicalTree(entity).toArray();
    attributes_to_replace = new java.util.ArrayList();
    attr_fold_map = new java.util.HashMap();
    for (var i=0; i<hierarchy_tree.length; i++) {
        ent1 = hierarchy_tree[i];
        folded_attrs = ent1.getFoldedAttributesMap();
        keys = folded_attrs.keySet().toArray();
        for (var j=0; j<keys.length; j++) {
            attr1_id = keys[j];
            attr2_id = folded_attrs.get(attr1_id);
            attr1 = ent1.getElementByID(attr1_id);
            attr2 = ent1.getElementByID(attr2_id);
            if (attr1 != null && attr2 != null) {
                orig_attr1 = attr1.getOriginatingAttribute();
                orig_attr2 = attr2.getOriginatingAttribute();
                attributes_to_replace.add(orig_attr1.getName());
                attr_fold_map.put(orig_attr2.getName(), orig_attr1.getName());
            } else {
                app_view.logMessage("---- WARNING: Entity " + entity.getName() + " can't use the mapping, the attribute doesn't exist");
            }
        
        }
    }
    return [attributes_to_replace, attr_fold_map]
}

function getFEName(attribute, is_preferred_abbreviation) {
    /*
    Input: Attribute, Bool
    Output: String
    Description: Returns preffered abbreviation of attribute in case of using preferred abbreviation for fe, 
                 othervise returns attribute names with underscores instead of spaces.
    */
    if (is_preferred_abbreviation==true) {
        fe_name = attribute.getPreferredAbbreviation();
    } else {
        attr_name = attribute.getName();
        fe_name = attr_name.replaceAll(" ", "_"); 
    }
    return fe_name
}

function createMappingForAttrAndOverlapping(relational_model, attr_fold_map, attribute, column) {
	f_attr_name = attribute.getName();
	folded = attr_fold_map.get(attribute);
	relational_model.getRMExtendedMap().createMapping(attribute, column);
	if (column.getTable().getName()=="Master_agreement_Entity_role_assignment") {
		app_view.logMessage("------- Created mapping from attribute " + attribute.getEntity() + "." + attribute.getName() + " to column " + column.getName());
	}
	
	if (folded != null) {
	    relational_model.getRMExtendedMap().createMapping(folded, column);
	    if (column.getTable().getName()=="Master_agreement_Entity_role_assignment") {
	    	app_view.logMessage("------- Created mapping from attribute " + folded.getEntity() + "." + folded.getName() + " to column " + column.getName());
	    }
	}
	relational_model.setDirty(true);
}


app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_fks_amended + " foreign keys amended");
app_view.logMessage("- " + log_tables_affected + "/" + tables.length + " tables affected");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="79608FB8-BB97-9642-E3E1-FDEAB8AE03D0" name="1. Subtree generation" object="logical" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME: Subtree generation
 *  PURPOSE: Forward engineering is a process of denormalisation of LDM. In every hierarchy, we usually want only one remaining 
 *           Table after FE.
 *  OBJECT: applied on logical data model
 *  REQUIREMENTS: run first
 *  DYNAMIC: - Change name of relational model for your purpose [rel_model_name]
 *           - If Entity's name is changed, it needs to be changed in the list
 *  SHORT DESCRIPTION: Select supertypes, into which all subtypes are wrapped in
*/

// ---- INPUT PARAMETERS ----
script_name = "Subtree generation";
rel_model_name = "Relational_3";

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

rel_model = model.design.getRelationalDesigns().getByName(rel_model_name);
id = rel_model.getObjectID();
entities = model.getEntitySet().toArray();

// List of all entities in hierarchiers, which we want to keep in relational model
include = new java.util.ArrayList([
 // Party related
 'Country',
 'Party',
 'Entity role',
 // Rating system related
 'Rating system',
 'Rating grade',
 // Group related
 'Group',
 'Internal group role',
 // Assignments
 'Instrument Entity role assignment',
 'Credit facility Entity role assignment',
 'Security Entity role assignment',
 'Security position',
 'Long security position Prudential portfolio assignment',
 'Long security position Prudential Portfolio assignment Accounting classification for financial assets assignment',
 'Long debt security position Prudential portfolio assignment encumbrance data',
 'Long equity or fund security position Prudential portfolio assignment encumbrance data',
 'Long security position Prudential portfolio assignment risk data',
 'Prudential portolio',
 'Prudential portfolio',
 'Accounting classification',
 'Master agreement Entity role assignment',
 'Exchange tradable derivative position', 
 'Exchange tradable derivative position role',
 'Subsidiary, joint venture and associate Other organisation role assignment',
 'Instrument Collateral received instrument assignment',
 // Instrument related
 'Instrument',
 'Repurchase agreement component',
 'Security borrowing and lending transaction including cash as collateral component',
 'Security Security repurchase agreement component assignment',
 // uncomment if verison wo role concept
 //'Over the counter (OTC) Derivative role',
 'Master agreement',
 'Protection arrangement',
 'Collateral',
 'Security and exchange tradable derivative',
 'Asset pool (subject to a Securitisation and other credit transfer)',
 // Securitisation
 'Covered bond programme',
 'Traditional securitisation', 
 'Synthetic securitisation',
 'Credit transfer other than securitisation and covered bond program',
 'Tranche in a synthetic securitisation without SSPE',
 // BSI
 'Non-financial asset',
 'Cash on hand',
 'Financial asset in the form of a debt security position',
 'Financial asset in the form of an equity or fund security position',
 'Financial asset in the form of an instrument',
 'Financial asset in the form of an instrument or security position',
 // Disjoint subtypes 
 'Financial asset according to International Financial Reporting Standard (IFRS)',
 'Financial asset according to national general accepted accounting principles (nGAAP)',
 'Non-financial liability',
 'Financial liability in the form of a debt security issued','Financial liability in the form of an instrument',
 'Off-balance sheet item given in the form of an Off-balance sheet instrument',
 'Off-balance sheet item given in the form of a Credit facility',
 'Off-balance sheet item received in the form of an instrument',
 'Off-balance sheet item received in the form of a credit facility',

 // Credit facility related
 'Credit facility role',

 // Additonal from second option draft 
 'Abstract instrument role', 
 'Financial asset instrument Collateral received instrument assignment',
 'Financial asset instrument role',
 'Financial liability instrument role',
 'Instrument hedged by Over the counter (OTC) Derivative',

 // Additional master types
 'Default status',
 'Forbearance measure',
 'Model Context',
 'Accounting classification',
 'Subordinated debt type',

 // Address
 'Postal code',
 'Address (used for reporting)',
 'Financial contract',
 'Debt security issued (by the reporting agent)',
 'Security position hedged by Over the counter (OTC) derivative'
 ]);

total_entities = entities.length;
enities_affected = new java.util.ArrayList();
for (var i=0; i<entities.length; i++) {
    entity = entities[i];
    e_name = entity.getName();
    // Include entity in fe only if it is in INCLUDE list and it is a hierarchical type
    is_hier = entity.isHierarchicalEntityType();
    if (is_hier) {
        if (include.contains(e_name)==false) {
            entity.setEngineerTo(id, false);
            entity.setDirty(true);
            enities_affected.add(e_name);
        }
    } 
   if (entity.getClassificationType()=="Reference data") {
   	entity.setEngineerTo(id, false);
  entity.setDirty(true);
  enities_affected.add(e_name);
   }
    
}
num_enities_affected = enities_affected.length;
app_view.logMessage("- Entities not forward engineered: " + enities_affected);
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + num_enities_affected + "/" + total_entities + " entites affected (not forward engineered)");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");]]>
		</script>
	</scr>
	<scr id="8FD84EC4-BA33-E507-E4C7-0FC7B3E2C3CA" name="11. Amend columns domain and remove duplicated columns" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Amend columns domain and remove duplicated columns
 *  PURPOSE: When we wrap up, there is duplication of columns when the same attribute in present in two or more subtypes.
 *           In this case, we need to remove duplicated columns and amend its domain:
 *           - it should be a union of members of these columns
 *           - it should contain member Not applicable if column was not present in all subtypes on one level of hierarchy
 *          Even when column is not duplicated its domain should be extended with member Not applicable in described case.
 *  OBJECT: Applied on relational model
 *  REQUIREMENTS: - Run before merging bsi assignments in case of IL draft 1, 
 *                - Role concept LDM: run after reduce discriminators 
 *  DYNAMIC: 
 *  SHORT DESCRIPTION: Checks every table for duplicated columns and removes them if they don't have a primary or foreign key constraint.
 *                     Uniqueness constraint is changed, if a duplicated column is part of this constraint.
 *                     Adds member Not applicable with defined function.
 *                     If a domain of a foreign key column is supposed to be amended, domain of source column is amended.
 *  
*/

// ---- INPUT PARAMETERS ----
script_name = "Amend columns domain and remove duplicated columns";
excluded = new java.util.ArrayList(["Governed Country code", "GVRND_CNTRY_CD", "CNTRY_CD"]);

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");

rel_model = model;
tables = model.getTableSet().toArray();
log_tables_affected = 0;
log_total_num_cols_affected = 0;
log_num_cols = 0;
for (var t=0; t<tables.length; t++){
    log_table_affected = false;
    table = tables[t];
    table_name = table.getName();
    app_view.logMessage("- Table " + table_name + " amended");
    columns = table.getElements();
    indexes = table.getKeys();
    log_num_cols += columns.length;
    cols_removed = new java.util.ArrayList();
    col_length = columns.length;
    columns_removed = new java.util.ArrayList();
    for (var i=0; i<col_length; i++) {
        log_col_amended = false;
        log_merged_with = new java.util.ArrayList();
        column = columns[i];
        column_name = column.getName();
        column_name_repl = column_name.replaceAll("[0-9]", "")
        attr =  column.getEngAttribute();
        is_pk = column.isPKElement();
        is_fk = column.isFKColumn();
        is_discriminator = column_name.contains("_TYP") || column_name.contains("_type");
        if (attr!=null && !is_discriminator && !cols_removed.contains(column_name) && !excluded.contains(attr.getName())) {
            attr_name = attr.getName();
            orig_attr_name = "";
            if (attr.isFKAttribute()) {
                orig_attr_name = attr.getOriginatingAttribute().getName();
            }
            column_domain = column.getDomain();
            column_domain_name = column_domain.getName();
            column_list_of_values = column_domain.getValueList();
            if (column_list_of_values) {
                not_applicable = true;
                // Amend the domain for enumerated columns
                column_member_names = addNotApplicable(column);
                // Create a list of members if not created through function
                app_view.logMessage("--- Column " + column.getName() + " considered");
                if (column_member_names.isEmpty()) {
                    not_applicable = false;
                    column_member_map = column_list_of_values.getValuesDescriptionMap();
                    m = column_member_map.keySet().toArray();
                    column_member_names = new java.util.HashSet();
                    for (var k=0; k<m.length; k++) {
                        member_code = m[k];
                        description = column_member_map.get(member_code);
                        // Each member is identified by its code and description
                        member_code_desc = member_code + ": " + description;
                        column_member_names.add(member_code_desc);
                    }
                } else {
                    app_view.logMessage("----- Added Not applicable");
                    log_col_amended = true;
                    log_table_affected = true;
                }
            }
            duplicates = false; 
            // Go through left columns to find the duplicates
            for (var j=1; j<col_length; j++){
                col = columns[j];
                col_name = col.getName();
                col_name_repl = col_name.replaceAll("[0-9]", "");
                attr2 =  col.getEngAttribute();
                orig_attr2_name = "-";
                if (attr2!=null && col_name != column_name && !cols_removed.contains(col_name) && !excluded.contains(attr2.getName())) {
                    attr2_name = attr2.getName();
                    //If attribute is a foreign key, find name of originating attribute
                    if (attr2.isFKAttribute()) {
                        orig_attr2_name = attr2.getOriginatingAttribute().getName();
                    }
                    // Remove column if columns had the same attribute name or
                    // attribute was a foreign key and column is not and origination attribute is already present in the table
                    if ((attr2_name==attr_name || orig_attr2_name == orig_attr_name || column_name_repl == col_name_repl) && col.isFKColumn()==false && col.isPKElement()==false){
                        app_view.logMessage("--  Column " + col.getName() + " same as " + column.getName());
                        duplicates = true;
                        log_merged_with.add(col.getName());
                        // Before removal, change unique constraint
                        for (var k = 0; k < indexes.length; k++) {
                            index = indexes[k];
                            if (index.isUnique()) {
                                is_in = index.getElementByName(col.getName());
                                if (is_in) {
                                    index.remove(col);
                                    index.add(column);
                                    app_view.logMessage("----- Amended constraints on column from " + col.getName() + "  to " + column.getName());
                                    table.setDirty(true);                  
                                }
                            }
                        }
                        if (column_list_of_values) {
                            // Expand column's domain's value list with members from col 
                            col_domain = col.getDomain();
                            col_domain_name = col_domain.getName();
                            col_list_of_values = col_domain.getValueList();
                            col_member_map = col_list_of_values.getValuesDescriptionMap();
                            m = col_member_map.keySet().toArray();
                            for (var k=0; k<m.length; k++) {
                                member_code = m[k];
                                description = col_member_map.get(member_code);
                                member_code_desc = member_code + ": " + description;
                                column_member_names.add(member_code_desc);
                            }
                        }
                        app_view.logMessage("-----  Column " + col.getName() + " removed (values from domain added to " + column.getName() + ")");
                        log_table_affected = true;
                        cols_removed.add(col.getName());
                        log_total_num_cols_affected +=1;
                        app_view.logMessage("Trying to create map from " + attr2.getName());
                        rel_model.getRMExtendedMap().createMapping(attr2, column);
                        addMappingsFromRemovedColumn(rel_model, table, col, column);
			         app_view.logMessage("------- Created mapping from attribute " + attr2.getName() + " to column " + column.getName());
                     columns_removed.add(col);
                        //col.remove();
                        //col.setDirty(true);
                        //column.setDirty(true);
                        //table.setDirty(true);
                    }
                }
            }
            for (var r=0; r<columns_removed.length; r++) {
                col_to_remove = columns_removed[r];
                col_to_remove.remove();
            }
            table.setDirty(true);
            // Now that all columns are removed and domain member list expanded with it's members,
            // we can go through all domains and do a comparison with existing domains
            // Check if a domain with these members exists
            domains = model.design.getDomainSet().toArray();
            if (column_list_of_values && (duplicates || not_applicable)) {
                log_total_num_cols_affected +=1;
                matching_domain_found = false;
                log_table_affected = true;
                for (var j=0; j<domains.length; j++) {
                    domain = domains[j];
                    domain_name = domain.getName();
                    list_of_values = domain.getValueList();
                    // Check only enumerated ones
                    if (list_of_values!=null) {
                        members_map = list_of_values.getValuesDescriptionMap(); 
                        m = members_map.keySet().toArray();
                        domain_member_names = new java.util.HashSet();
                        for (var k=0; k<m.length; k++) {
                            member_code = m[k];
                            if (member_code==0) {
                                description = "Not applicable"; 
                            } else {
                                description = members_map.get(member_code);
                            }
                            member_code_desc = member_code + ": " + description;
                            domain_member_names.add(member_code_desc);
                        }
                        // Check if this domain has the same members as expected domain
                        if (domain_member_names.equals(column_member_names)) {
                            matching_domain_found = true;
                            if (is_fk) {
                                   // If columns is a foreign key, we cannot change its domain
                                  // In this case, we should change the domain of originating column
                                   originating_col = column.getReferencedColumn();
                                   originating_col.setDomain(domain);
                            } else {
                                   column.setDomain(domain);
                            }
                            break;
                        }
                    }
                }
                app_view.logMessage("----- Match for Domain: " + matching_domain_found);
                if (is_fk) {
                    originating_col = column.getReferencedColumn();
                    app_view.logMessage("------- Column is a foreign key. Domain of originating column " + originating_col.getName() + " changed instead.");
                }
                // Now we check if we found a matching domain, otherwise it needs to be created
                if (!matching_domain_found) {
                    new_domain = createDomain(column_member_names);
                     if (is_fk) {
                        originating_col = column.getReferencedColumn();
                        originating_col.setDomain(new_domain);
                        originating_col.setDirty(true);
                   } else {
                        column.setDomain(new_domain);
                        column.setDirty(true);
                   }
                    app_view.logMessage("------- New domain list of values: " + column_member_names);
                } else {
                    app_view.logMessage("------- New Domain: " + domain_name);
                }
            }
        }
        table.setDirty(true); 
    }
    if (log_table_affected) {
        log_tables_affected += 1;
    }
}
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_total_num_cols_affected + "/" + log_num_cols + " columns amended");
app_view.logMessage("- " + log_tables_affected + "/" + tables.length + " tables affected");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");


// ---- FUNCTIONS ----
function addMappingsFromRemovedColumn(relational_model, table, column_to_be_removed, target_column) {
    /*
    Input: RelationalModel, Table, Column, Column
    Output: None
    Description: finds existing mappings from column_to_be_removed and copies them to target_column
    */
    maps = table.getMappingsToEntities();
    for (var j=0; j<maps.length; j++) {
        map = maps[j];
		// find source entity
		source_ent = model.design.getLogicalDesign().getEntitySet().getByName(map.getName());
		// find source attributes
		maps_col = column_to_be_removed.getMappingsFor(source_ent);
        if (maps_col.length > 0) {
			for (var m=0; m<maps_col.length; m++) {
				source_attr_name = maps_col[m].getName();
				//app_view.logMessage("-- Source entity: " + map.getName() + ", attribute: " + source_attr_name);
				source_attribute = source_ent.getElementByName(source_attr_name);
                // Add mapping from this attribute to target column
                relational_model.getRMExtendedMap().createMapping(source_attribute, target_column);
				relational_model.setDirty(true);
			}
		}
    }
}


function addNotApplicable(column){
    /* 
    Input: Column
    Output: HashSet
    Description: Returns a set of members of the column, when Not applicable member is added, and empty set when domain should not be changed.
                 Add member Not applicable to a domain of column according to forward egineering strategy.
                 Only for column from subtypes of table's entity: we do not want to include columns which were "wrapped down".
    */
    attr = column.getEngAttribute();
    is_mandatory = true;
    member_names = new java.util.HashSet();
    if (attr) {
        attr_name = attr.getName();
        entity = attr.getEntity();
        is_hier = entity.isHierarchicalEntityType();
        parent = entity.getHierarchicalParent();
        // Typo in the class definition
        is_ignored = entity.getAttributeInherType()=="All atributes";
        relations = entity.getRelations();
        if (relations.length==1) {
            // Optional relationships need to have added member Not applicable for enumerated domains
            is_optional_relation = relations[0].isOptionalSource();
            is_identifying = relations[0].isIdentifying();
            is_one_to_one = relations[0].isOneToOne();
            source_entity = relations[0].getSourceEntity();
            source_is_hier_type = source_entity.isHierarchicalEntityType();
            is_subtype = false;
            if (source_is_hier_type) {
                is_subtype = !source_entity.isHierarchicalRoot();
            }
            if (is_identifying && is_one_to_one && !is_ignored && (is_optional_relation || is_subtype)) {
                is_mandatory = false;
            }    
        }
        if (is_hier && !is_ignored) {
            // Go through the hierarchy, on every level check if it is present also in all siblings
            // If it is missing in at least one, we add Not applicable
            while (parent!=null) {
                children = parent.getHierarchicalChildren().toArray();
                for (var c=0; c<children.length; c++) {
                    child = children[c];
                    attr_match = child.getElementByName(attr_name);
                    if (!attr_match) {
                        is_mandatory = false;
                        parent = null;
                        break;
                    }
                }
                if (parent) {
                    parent = parent.getHierarchicalParent();
                }
            }
        }
        if (!is_mandatory) {
            domain = column.getDomain();
            list_of_values = domain.getValueList();
            member_map = list_of_values.getValuesDescriptionMap();
            m = member_map.keySet().toArray();
            for (var k=0; k<m.length; k++) {
                member_code = m[k];
                description = member_map.get(member_code);
                // Each member is identified by its code and description
                member_code_desc = member_code + ": " + description;
                member_names.add(member_code_desc);
            }
            member_names.add("0: Not applicable");
        }
    }
    return member_names;
}


function getUnassignedDomainMemberIndex() {
    /* 
    Input: None
    Output: ArrayList
    Description: Returns a list [domain index, member index] of last unassigned member or domain.
    */
    domains = model.design.getDomainSet().toArray();
    domain_index = 0;
    member_index = 0;
    starting_indexes = new java.util.ArrayList();
    for (var d=0; d<domains.length; d++) {
        temp_domain = domains[d];
        domain_name = temp_domain.getName();
        if (domain_name.contains("Unassigned")) {
            candidate_index = parseInt(domain_name.split("_")[2]); // List [Unassigned, domain, index]
            if (candidate_index>domain_index) {
                domain_index = candidate_index;
            }
        }
        domain_value_list = temp_domain.getValueList();
        if (domain_value_list) {
            domain_values = domain_value_list.getValues().toArray();
            for (var j=0; j<domain_values.length; j++) {
                value = domain_values[j];
                if (value.contains("Unassigned")) {
                    code_index = parseInt(value.split("_")[1]);
                    if (code_index>member_index) {
                        member_index = code_index;
                    }
                }
            }
        }
    }
    starting_indexes.add(domain_index);
    starting_indexes.add(member_index);
    return starting_indexes;
}


function createDomain(member_list) {
    /*
    Input: HashSet
    Output: Domain
    Description: Creates a Domain named "Unassigned_domain_<number>" in defaultdomains with constraint enumeration from member_list. 
                 If enumerations (sdd members) are newly created they have a value "Unassigned_<number>". 
    */
    new_domain = null;
    starting_indexes = getUnassignedDomainMemberIndex();
    domain_index = starting_indexes[0] + 1;
    domain_member_index = starting_indexes[1] + 1;
    member_list_array = member_list.toArray();
    if (member_list_array.length>0) {
         new_domain = model.design.createDomain();
         domain_name = "Unassigned_domain_" + domain_index;
        new_domain.setName(domain_name);
        app_view.logMessage("--- Created domain " + new_domain.getName());
        constraint_enumeration = new_domain.createConstraintEnumeration();
        for (var s=0; s<member_list_array.length; s++) {
            member = member_list_array[s];
            member_code_des = member.split(": "); // member = "code: name: description"
            if (member_code_des.length>1) {
                member_code = member_code_des[0];
                member_name = member_code_des[1];
            } else {
                member_code = "Unassigned_" + domain_member_index;
                member_name = member;
            }
            constraint_enumeration.add(member_code, member_name);
            domain_member_index += 1;
        }
        new_domain.setValueList(constraint_enumeration);
        // Set Logical data type to String
        lt_string = model.design.getLogicalDatatypeSet().getByName("String");
        new_domain.setLogicalDatatype(lt_string);
        new_domain.setDirty(true);
    }
    return new_domain;
}]]>
		</script>
	</scr>
	<scr id="EA562B77-6014-2466-405C-D5B5A1FCB523" name="4. Generalisation" object="relational" engine="Oracle Nashorn" var="model" library="" method="" purpose="transformation" >
		<script>
			<![CDATA[/** 
 *  SCRIPT NAME : Generalisation
 *  PURPOSE: Generalisations have surrogate primary key created after fe. 
 *           When subtypes actually have the same primary keys, we want the generalisation to have that pk.   
 *           EXAMPLE: (INSTRMNT_ID, DBTR_PRTY_RL, DBTR_PRTY_RL_TYP), (INSTRMNT_ID, SRVCR_PRTY_RL, SRVCR_PRTY_RL_TYP) -> 
 *                    (INSTRMNT_ID, PRTY_RL, PRTY_RL_TYP)
 *  OBJECT: applied on relational model
 *  REQUIREMENTS: run after Entity role
 *  DYNAMIC: excluded list
 *           is_preferred_abbreviation
 *  SHORT DESCRIPTION: During fe, the Table gets a surrogate primary key, which needs to be changed to primary key defined on subtypes. 
 *                     Changes foreign key relationships, which are now part of the primary key, to mandatory.
*/

// ---- INPUT PARAMETERS ----
var is_preferred_abbreviation = true;
script_name = "Generalisation";

// ---- SCRIPT ----
var app_view = model.getAppView();
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("Start script: " + script_name);
app_view.logMessage("--------------------------------------------------------");
log_tables_affected = 0;

rel_model = model;
domains = model.design.getDomainSet().toArray();
tables = model.getTableSet().toArray();
primary_table_name = "ENTTY_RL";
// We exclude entities where we leave surrogate primary key or were hadled before
excluded = new java.util.ArrayList(["SCTRY_BRRWNG_LNDNG_TRNSCTN_INCLDNG_CSH_CLLTRL", 
                            "Security_borrowing_and_lending_transaction_including_cash_as_collateral_component",
                            "ENTTY_RL", 
                            "Entity_role",
                            "ABSTRCT_INSTRMNT_RL",
                            "Abstract_instrument_role"]);

replacibles = new java.util.ArrayList([
//"PRTY_RL_TYP", 
 //                                      "Party_role_type",    
 //                                      "ORGNSTN_RL_TYP",
 //                                      "Organisation_role_type", 
  //                                     "LGL_PRSN_RL_TYP", 
  //                                     "Legal_person_role_type",
 //                                      "DBTR_PRTY_RL_TYP", 
  //                                     "Debtor_Party_role_type",
  //                                     "SRVCR_PRTY_RL_TYP",
  //                                     "Servicer_Party_role_type",
  //                                     "ISSR_ORGNSTN_RL_TYP",
  //                                     "Other_organisation_role_type",
  //                                     "OTHR_ORGNSTN_RL_TYP",
  //                                     "PRTCTN_PRVD_ORGNSTN_RL_TYPE",
  //                                     "Protection_provider_Organisation_role_type"
  ]);
primary_concept = "PRTY_RL_TYP";
if (is_preferred_abbreviation==false) {
    primary_concept = "Party_role_type";
    primary_table_name = "Entity_role";
}


primary_table = model.getTableSet().getByName(primary_table_name);
primary_concept_column = primary_table.getElementByName(primary_concept);

for (var g=0; g<tables.length; g++) {
    table = tables[g];
    table_name = table.getName();
    // Check if it is a generalisation: Entity didn't have pk, is root of hierarchy, is in a hierarchy
    entity = table.getEngEntity();
    is_hierarchy = entity.isHierarchicalEntityType();
    is_root = entity.isHierarchicalRoot();
    no_pk = entity.isCreateSurrogateKey();
    if (is_hierarchy && is_root && no_pk && !excluded.contains(table.getName())) {
        // Overlapping attributes of the hierarchy
        folded_attrs_list = getOverlappingAttributesOfHierarchy(entity);
        attributes_to_replace = folded_attrs_list[0];
        attr_fold_map = folded_attrs_list[1];
        log_tables_affected += 1;
        app_view.logMessage("- Table " + table_name + " amended");
        //app_view.logMessage("- Fold " + attr_fold_map);
        columns_to_remove = new java.util.ArrayList();
        pks = new java.util.HashMap();
        mappers = new java.util.HashMap();
        columns = table.getElements();
        log_cols_replaced_by_primary_concept = new java.util.ArrayList();
        for (var i=0; i<columns.length; i++) {
            column = columns[i];
            col_name = column.getName();
            if (column.isSurrogateColumn()==true) {
                columns_to_remove.add(column);
                app_view.logMessage("--- Surrogate key " + col_name + " removed");
            } else {
                attribute = column.getEngAttribute();
                // check if attribute was a primary key (and not foreign key):
                // in this case, check if it is one of the replacibles and replace it with its head member
                attr_name = getFEName(attribute, is_preferred_abbreviation);
                if (attribute.isPKElement()==true && attribute.isFKAttribute()==false) {
                    if (attribute.getName() == "Master agreement identifier") {
                        app_view.logMessage("ERRRRRORRRR Attr name: " + attribute.getName());
                        app_view.logMessage("ERRRRORRRR FE name: " + attr_name);
                    }
                    exists = table.getElementByName(attr_name);
                    if (exists != null) {
                        //app_view.logMessage("----- Found matching column with name " + attr_name);
                    } else {
                        //app_view.logMessage("----- Set column name to " + attr_name);
                        column.setName(attr_name);
                    }
                    if (pks.containsKey(attr_name)==false) {
                        exists = table.getElementByName(attr_name);
                        if (exists != null) {
                            if (col_name == attr_name) {
                                pks.put(attr_name, exists);
                                //app_view.logMessage("----- Chose exsisting column and added to pk " + attr_name + ", col name is " + col_name);
                            } else {
                                // Pass and delete this one
                                mapped_to_col = exists;
                                addMappingsFromRemovedColumn(rel_model, table, column, mapped_to_col);
                                columns_to_remove.add(column);
                                //app_view.logMessage("----- Attr will be in pk " + attr_name);
                                mappers.put(attribute, mapped_to_col);
                            }
                            
                        } else {
                            pks.put(attr_name, column);
                            //app_view.logMessage("----- Chose renamed column and added to pk " + attr_name);
                        }
                    } else {
                        mapped_to_col = pks.get(attr_name);
                        columns_to_remove.add(column);
                        addMappingsFromRemovedColumn(rel_model, table, column, mapped_to_col);
                        //app_view.logMessage("----- Attr already in pk " + attr_name);
                        mappers.put(attribute, mapped_to_col);
                    }
                }
                if (attribute.isFKAttribute()==true && attribute.isPKElement()==true) {
                    // If foreign keys come from the same entity, (same name of attribute), rename the column and keep only one
                    attr_name = getFEName(attribute.getOriginatingAttribute(), is_preferred_abbreviation);
                    if (attribute.getOriginatingAttribute().getName() == "Master agreement identifier") {
                        app_view.logMessage("Attr name: " + attribute.getName());
                        app_view.logMessage("FE name: " + attr_name);
                    }
                    //app_view.logMessage("----- Originating column name " + attr_name);
                    exists = table.getElementByName(attr_name);
                    if (attribute.getOriginatingAttribute().getName() == "Master agreement identifier") {
                        app_view.logMessage("Exists: " + exists);
                    }
                    if (exists != null) {
                        //app_view.logMessage("----- Found matching column with name " + attr_name);
                    } else {
                        if (attribute.getOriginatingAttribute().getName() == "Master agreement identifier") {
                            app_view.logMessage("Set name to column " + column.getName() +  " to " + attr_name);
                        }
                        //app_view.logMessage("----- Set column name to " + attr_name);
                        column.setName(attr_name);
                        
                    }
                    if (pks.containsKey(attr_name)==false) {
                        exists = table.getElementByName(attr_name);
                        if (exists != null) {
                            pks.put(attr_name, exists);
                            if (attribute.getOriginatingAttribute().getName() == "Master agreement identifier") {
                                app_view.logMessage("Put exists to pks");
                            }
                            //app_view.logMessage("----- Chose exsisting column and added to pk " + attr_name);
                        } else {
                            pks.put(attr_name, column);
                            if (attribute.getOriginatingAttribute().getName() == "Master agreement identifier") {
                                app_view.logMessage("Put column to pks");
                            }
                            //app_view.logMessage("----- Chose renamed column and added to pk " + attr_name);
                        }
                        if (column.getName()!=attr_name) {
                            if (attribute.getOriginatingAttribute().getName() == "Master agreement identifier") {
                                app_view.logMessage("Will remove " + column.getName());
                            }
                            columns_to_remove.add(column);
                            addMappingsFromRemovedColumn(rel_model, table, column, exists);
                            mappers.put(attribute, exists);
                        }
                    } else {
                        if (column.getName()!=attr_name) {
                            if (attribute.getOriginatingAttribute().getName() == "Master agreement identifier") {
                                app_view.logMessage("Will remove " + column.getName());
                            }
                            mapped_to_col = pks.get(attr_name);
                            columns_to_remove.add(column);
                            addMappingsFromRemovedColumn(rel_model, table, column, mapped_to_col);
                            //app_view.logMessage("----- Already in pk " + attr_name);
                            mappers.put(attribute, mapped_to_col);
                        }
                    }
                }
            }
            table.setDirty(true);
        }
        
        // Set new primary key
        newIndex = table.createIndex();
        log_pk_col_names = new java.util.ArrayList();
        keys = pks.keySet().toArray();
        for (var i = 0; i < pks.size(); i++) {
            col = pks.get(keys[i]);
            col.setMandatory(true);
            log_pk_col_names.add(col.getName());
            newIndex.add(col);
        }
        newIndex.setPK(true);
        app_view.logMessage("--- Primary key constraint amended");
        app_view.logMessage("----- New primary key: " + log_pk_col_names);
        table.setDirty(true);

        // Change foreign key associations with ENTTY_RL
        log_related_tables_amended = 0;
        log_related_tables = 0;
        for (var s=0; s<tables.length; s++) {
            related_table = tables[s];
            related_entity = related_table.getEngEntity();
            fks = related_table.getFKIndexAssociationsWith(table);
            related_table_name = related_table.getName();
            related_table_columns = related_table.getElements();
            if (fks.length > 0 && related_table_name != table.getName() && !excluded.contains(related_table.getName())) {
                // Overlapping attributes of the hierarchy
                folded_attrs_list = getOverlappingAttributesOfHierarchy(related_entity);
                attributes_to_replace = folded_attrs_list[0];
                attr_fold_map = folded_attrs_list[1];
                log_related_tables += fks.length;
                for (var j=0; j<fks.length; j++) {
                    fk = fks[j];
                    ref_table = fk.getRemoteTable();
                    ref_index = fk.getRemoteIndex();
                    ref_table_pk = ref_table.getPK();
                    ref_table_cols = ref_table_pk.getColumns();
                    app_view.logMessage("--- Related table " + related_table_name + " amended");
                    log_related_tables_amended += 1;
                    if (ref_index.isPK()==false) {
                        // If it's not a generalisation, add columns from primary key
                        is_generalisation = related_entity.isCreateSurrogateKey();
                        log_new_fk_cols = new java.util.ArrayList();
                        log_connected_cols = new java.util.ArrayList();
                        if (is_generalisation==false) {
                            table_pk_cols_base = fk.getColumns(); // existing columns in related table
                            // Prepare names of pk columns, so that we connect correct columns
                            ref_table_cols_names = new java.util.ArrayList();
                            table_pk_cols_names = new java.util.ArrayList();
                            table_pk_cols_names_sorted = new java.util.ArrayList();
                            fake_index = related_table.createIndex();
                            for (var k=0; k<ref_table_cols.length; k++) {
                                ref_c = ref_table_cols[k];
                                log_new_fk_cols.add(ref_c.getName());
                                c = table_pk_cols_base[k];
                                ref_table_cols_names.add(ref_c.getName());
                                table_pk_cols_names.add(c.getName());
                            }
                            for (var k=0; k<ref_table_cols_names.length; k++) {
                                col_name = ref_table_cols_names[k];
                                for (l=0; l<table_pk_cols_names.length; l++) {
                                    col_pk = table_pk_cols_names[l];
                                    name1 = col_name.replaceAll("[0-9]", "");
                                    name2 = col_pk.replaceAll("[0-9]", "");
                                    if (name1.contains(name2) || name2.contains(name1) || ((name1.contains("RL_TYP") || name1.contains("role_type")) && (name2.contains("RL_TYP") || name2.contains("role_type")))) {
                                        fake_index.add(table_pk_cols_base[l]);
                                        log_connected_cols.add(table_pk_cols_base[l].getName());
                                        table_pk_cols_names_sorted.add(col_pk);
                                    }
                                }
                            }
                            table_pk_cols = fake_index.getColumns();
                            for (var m=0; m<table_pk_cols.length; m++) {
                                  attr_from = related_table.getElementByName(table_pk_cols_names_sorted[m]).getEngAttribute();
                                  col_to = table_pk_cols[m];
                                  addMappingsFromRemovedColumn(rel_model, related_table, attr_from.getEngColumn(rel_model, related_table), col_to);
                                  createMappingForAttrAndOverlapping(rel_model, attr_fold_map, attr_from, col_to);
                          }
                          fake_index.remove();
                        } else {
                            table_pk_cols = new_index.getColumns();
                            fake_index = related_table.createIndex();
                            for (var k=0; k<table_pk_cols.length; k++) {
                                c = table_pk_cols[k];
                                c_name = c.getName();
                                log_new_fk_cols.add(c.getName());
                                log_connected_cols.add(c.getName());
                                if (related_table.getElementByName(c_name) == null) {
	                            	   created_c = related_table.createColumn();
	                                 original_c.copy(created_c);
	                                 created_c.setDirty(true);
	                            }
	                            created_c = related_table.getElementByName(c_name);
	                            fake_index.add(created_c);
                                // Find previous column that resembles this one
                                for (var n=0; n<related_table_columns.length; n++) {
                                    rel_t_col = related_table_columns[n];
                                    rel_t_attr = rel_t_col.getEngAttribute();
                                    name1 = rel_t_col.getName().replaceAll("[0-9]", "");
                                    name2 = c_name.replaceAll("[0-9]", "");
                                    if (name1.contains(name2) || name2.contains(name1) || ((name1.contains("RL_TYP") || name1.contains("role_type")) && (name2.contains("RL_TYP") || name2.contains("role_type")))) {
                                        // Add mappings 
                                        addMappingsFromRemovedColumn(rel_model, related_table, rel_t_col, created_c);
                                        createMappingForAttrAndOverlapping(rel_model, attr_fold_map, rel_t_attr, created_c);
                                    }
                                }
                            }
                            table_pk_cols = fake_index.getColumns();
                            fake_index.remove();
                        }
                        fk.changeKeyObject(ref_table_pk, table_pk_cols);
                        app_view.logMessage("----- New foreign key: " + log_new_fk_cols + " on " + log_connected_cols);
                        fk.setMandatory(true);
                        app_view.logMessage("----- Foreign key set to mandatory");
                    }
                }
                related_table.setDirty(true);
            }
        }

        // Relations, which have fk columns as part of primary key, need to be mandatory
        fks = table.getFKAssociationsList();
        log_fks_to_mandatory = 0;
        log_fk = false;
        for (var j=0; j<fks.length; j++) {
            fk = fks[j];
            cols = fk.getColumns();
            for (var i=0; i<cols.length; i++) {
                col = cols[i];
                if (col.isPKElement()) {
                    log_fk = true;
                    col.setMandatory(true);
                    fk.setMandatory(true);
                }
            } 
            if (log_fk) {
                log_fks_to_mandatory += 1;
            }
        }
        app_view.logMessage("--- " + log_fks_to_mandatory + "/" + fks.length + " foreign keys set to mandatory");
        table.setDirty(true);

        m_keys = mappers.keySet().toArray();
        for (var i = 0; i < mappers.size(); i++) {
            col = mappers.get(m_keys[i]);
            createMappingForAttrAndOverlapping(rel_model, attr_fold_map, m_keys[i], col);
        }
        table.setDirty(true);
        
        // Remove columns in columns_to_remove
        for (var i = 0; i < columns_to_remove.length; i++) {
            col = columns_to_remove[i];
            col.remove();
        }
        app_view.logMessage("--- " + columns_to_remove.length + "/" + columns.length + " columns removed");
        app_view.logMessage("--- Columns removed: " + columns_to_remove);
        
        // Remove empty constraints
        keys = table.getKeys();
        log_empty_constraints_removed = 0;
        for (var i = 0; i < keys.length; i++) {
          index = keys[i];
          index_c = index.getColumns();
          if (index_c.length==0) {
              log_empty_constraints_removed += 1;
              index.remove();
           }
           table.setDirty(true);
        }
        app_view.logMessage("--- " + log_empty_constraints_removed + "/" + keys.length + " keys removed");
    }
    table.setDirty(true);
}

app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("- " + log_tables_affected + "/" + tables.length + " tables affected");
app_view.logMessage("--------------------------------------------------------");
app_view.logMessage("End script: " + script_name);
app_view.logMessage("--------------------------------------------------------");


// ---- FUNCTIONS ----
function getFEName(attribute, is_preferred_abbreviation) {
    /*
    Input: Attribute, Bool
    Output: String
    Description: Returns preffered abbreviation of attribute in case of using pref.abbr. for fe, 
                 othervise returns attribute names with underscores instead of spaces
    */ 
    if (is_preferred_abbreviation==true) {
        fe_name = attribute.getPreferredAbbreviation();
    } else {
        attr_name = attribute.getName();
        fe_name = attr_name.replaceAll(" ", "_"); 
    }
    return fe_name
}

function getHierarchicalTree(entity) {
    leaves = entity.getHierarchicalLeaves();
    hierarchy_tree = new java.util.HashSet();
    hierarchy_tree.add(entity);
    if (entity.isHierarchicalEntityType()) {
        for (var i=0; i<leaves.length; i++) {
            leaf = leaves[i];
            hierarchy_tree.add(leaf);
            parent = leaf.getHierarchicalParent();
            is_downwrapped = parent.getAttributeInherType()=='All atributes';
            // Igore the ones that are downwrapped
            if (!is_downwrapped) {
                while (parent.getName() != entity.getName()) {
                    hierarchy_tree.add(parent);
                    parent = parent.getHierarchicalParent();
                }
            }
        }
    }
    return hierarchy_tree;
}


function getOverlappingAttributesOfHierarchy(entity) {
    hierarchy_tree = getHierarchicalTree(entity).toArray();
    attributes_to_replace = new java.util.ArrayList();
    attr_fold_map = new java.util.HashMap();
    for (var i=0; i<hierarchy_tree.length; i++) {
        ent1 = hierarchy_tree[i];
        attrs = ent1.getAttributeSet();
        folded_attrs = ent1.getFoldedAttributesMap();
        keys = folded_attrs.keySet().toArray();
        for (var j=0; j<keys.length; j++) {
            attr1_id = keys[j];
            attr2_id = folded_attrs.get(attr1_id);
            attr1 = attrs.getObjectByID(attr1_id);
            attr2 = attrs.getObjectByID(attr2_id);
             if (attr1 != null && attr2 != null) {
		    	   orig_attr1 = attr1.getOriginatingAttribute();
		        orig_attr2 = attr2.getOriginatingAttribute();
		        attributes_to_replace.add(orig_attr1.getName());
		        attr_fold_map.put(attr1, attr2);
		    } else {
		    	app_view.logMessage("---- WARNING: Entity " + entity.getName() + " can't use the mapping, the attribute doesn't exist");
		    }
        }
    }
    return [attributes_to_replace, attr_fold_map]
}


function createMappingForAttrAndOverlapping(relational_model, attr_fold_map, attribute, column) {
    f_attr_name = attribute.getName();
    folded = attr_fold_map.get(attribute);
    relational_model.getRMExtendedMap().createMapping(attribute, column);
    app_view.logMessage("------- Created mapping from attribute " + attribute + " to column " + column);
    if (folded != null) {
        relational_model.getRMExtendedMap().createMapping(folded, column);
        app_view.logMessage("------- Created mapping from attribute " + folded.getName() + " to column " + column.getName());
    }
}

function addMappingsFromRemovedColumn(relational_model, table, column_to_be_removed, target_column) {
    /*
    Input: RelationalModel, Table, Column, Column
    Output: None
    Description: finds existing mappings from column_to_be_removed and copies them to target_column
    */
    maps = table.getMappingsToEntities();
    for (var j=0; j<maps.length; j++) {
        map = maps[j];
		// find source entity
		source_ent = model.design.getLogicalDesign().getEntitySet().getByName(map.getName());
		// find source attributes
		maps_col = column_to_be_removed.getMappingsFor(source_ent);
        if (maps_col.length > 0) {
			for (var m=0; m<maps_col.length; m++) {
				source_attr_name = maps_col[m].getName();
				//app_view.logMessage("-- Source entity: " + map.getName() + ", attribute: " + source_attr_name);
				source_attribute = source_ent.getElementByName(source_attr_name);
                // Add mapping from this attribute to target column
                relational_model.getRMExtendedMap().createMapping(source_attribute, target_column);
				relational_model.setDirty(true);
			}
		}
    }
}]]>
		</script>
	</scr>
</custom_transformation_scripts>